<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="Perl Weekly Challenge - Perl 5 & Perl 6"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #029.">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.55.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 029</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 029</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Oct 20, 2019</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p6-review-challenge-029.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    

<hr />

<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>

<hr />

<h2 id="task-1-expansion">Task #1: Expansion</h2>

<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2019/10/perl-weekly-challenge-29-file-type-and-digital-clock.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-029/">Week 29 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>

<p>The challenge reads as follows:</p>

<p><em>Write a script to demonstrate brace expansion. For example, script would take command line argument Perl {Daily,Weekly,Monthly,Yearly} Challenge and should expand it and print like below:</em></p>

<pre><code>Perl Daily Challenge
Perl Weekly Challenge
Perl Monthly Challenge
Perl Yearly Challenge
</code></pre>

<p>The specification is not very detailed, and we will not attempt to provide a full-fledged templating system, as this already exists. So we will limit our implementation to the following: an initial sentence fragment, followed by a single list of options between curly brackets, followed by a final sentence fragment.</p>

<h2 id="my-solution">My Solution</h2>

<p>We will supply a command line argument in the form of a string between quote marks, and provide for a default value for the purpose of testing. The program also attempts to normalize spaces in the output, since it is difficult to predict the exact format (number of spaces) supplied by the user.</p>

<pre><code class="language-Perl6">use v6;

sub MAIN (Str $input = 'Perl {Daily,Weekly,Monthly,Yearly} Challenge') {
    my $match = $input ~~ /(&lt;-[{]&gt;+) '{' (&lt;-[}]&gt;+) '}' (.+)/;
    my ($start, $options, $end) = map { ~$_ }, $match[0 .. 2];
    s:g/^ \h+ | \h+ $// for $start, $options, $end;
    say &quot;$start $_ $end&quot; for $options.split(/\s*','\s*/);
}
</code></pre>

<p>Running the program using the default value and with a poorly formatted input string displays the following satisfactory results:</p>

<pre><code>$ perl6 brace-expansion.p6
Perl Daily Challenge
Perl Weekly Challenge
Perl Monthly Challenge
Perl Yearly Challenge

$ ./perl6 brace-expansion.p6 &quot;Perl {Daily,  Weekly  ,  Monthly,Yearly   }   Challenge&quot;
Perl Daily Challenge
Perl Weekly Challenge
Perl Monthly Challenge
Perl Yearly Challenge
</code></pre>

<h2 id="alternate-solutions">Alternate Solutions</h2>

<p>It appears that I was a bit lazy with my bare-bone solution: many challengers contributed solutions that were richer with features, especially the ability to process several groups of braces, using either grammars or recursive subroutines (or both).</p>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/arne-sommer/perl6/ch-1.p6">Arne Sommer</a> contributed a fairly concise and clever program. Consider his multi <code>MAIN</code> subroutine doing the first pattern matching within the signature and the loop to split the pattern within braces in the body of the function, <em>and</em> calling itself recursively in the event there are more brace patterns to be processed:</p>

<pre><code class="language-Perl6">multi MAIN ($string where $string ~~ /^(.*?) \{ (.*?) \} (.*)/)
{
  MAIN(&quot;$0$_$2&quot;) for $1.Str.split(&quot;,&quot;);
}
multi MAIN ($string)
{
  say $string;
}
</code></pre>

<p>The second multi <code>Main</code> subroutine is called only when there are no more brace subpatterns to be processed. Quite impressive and really nice. Congrats, Arne.</p>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/noud/perl6/ch-1.p6">Noud</a>&rsquo;s solution is also quite concise:</p>

<pre><code class="language-Perl6">sub brace_expansion(Str $s) {
    if ($s ~~ /(.*)\{(.*)\}(.*)/) {
        [&quot;$_[0]$_[1]$2&quot; for brace_expansion(Str($0)) X $1.split(',')];
    } else {
        [$s];
    }
}
</code></pre>

<p>I&rsquo;m impressed by Noud&rsquo;s main code line:</p>

<pre><code class="language-Perl6">        [&quot;$_[0]$_[1]$2&quot; for brace_expansion(Str($0)) X $1.split(',')];
</code></pre>

<p>which does quite a lot in a single statement (I like especially the use of the <code>X</code> cross product operator in this context). Yes, Perl 6 can be very expressive when used by such talented people as Arne and Noud.</p>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/daniel-mita/perl6/ch-1.p6">Daniel Mita</a> used quite clever nested <code>given</code> statements to process several input phrases:</p>

<pre><code class="language-Perl6">sub MAIN (
  *@phrase where * &gt; 0,
  --&gt; Nil
) {
  given @phrase.join: ' ' -&gt; $str {
    given $str.match: /^ ( .*? ) '{' ( .* ) '}' ( .*? ) $/ {
      when .[1].so {
        for .[1].split: ',' -&gt; $split {
          &quot;$_[0]$split$_[2]&quot;.say;
        }
      }
      default { $str.say }
    }
  }
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/kevin-colyer/perl6/ch-1.p6">Kevin Colyer</a> also wrote a program able to handle several brace expansions. This is his <code>expand</code> subroutine doing the bulk of the work:</p>

<pre><code class="language-Perl6">sub expand(*@texts) {
    my @expanded;
    for @texts -&gt; $t {
        if $t.starts-with: '{' and $t.ends-with: '}' {
             @expanded.push: [ $t.substr(1,*-1).split(',') ];
        } else {
            @expanded.push:  [ $t ];
        }
    }
    # reduce array using cross multiplier
    return [X] @expanded;
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/mark-senn/perl6/ch-1.p6">Mark Senn</a>&rsquo;s program is accompanied with interesting and lengthy comments that I would urge you to read from the linked page (and possibly provide some answers to his questions), but will omit these comments from this review.</p>

<pre><code class="language-Perl6">sub MAIN(*@arg);
{
    (@arg.elems)
        or  @arg = 'Perl', '{Daily,Weekly,Monthly,Yearly}', 'Challenge';

    # Convert the @arg array to a @term array.
    my @term = ();
    for @arg  {
        if  /^^ \{ (.*?) \} $$/  {
            push @term, $0.split(',');
        }  else  {
            push @term, $_;
        }
    }
    # I like the following line the best.
    ([X] @term).map({.join(' ').say});
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/markus-holzer/perl6/ch-1.p6">Markus Holzer</a> wrote a very complete program, including a full-fledged grammar for brace expansion and a detailed test plan. Markus&rsquo;s program is too long to quote here (but I would really advise you to follow the link and look in detail to his solution). Anyway, I arbitrarily decided to quote only his grammar (since we haven&rsquo;t discussed so many grammars in our reviews so far):</p>

<pre><code class="language-Perl6">grammar BraceExpansion
{
    regex TOP           { &lt;start-txt&gt; [ &lt;list&gt; | &lt;range&gt; ] &lt;end-txt&gt; }
    regex start-txt     { .* &lt;?before [&lt;list&gt; || &lt;range&gt;]&gt; }
    regex end-txt       { &lt;save-char&gt;*? }
    regex save-char     { &lt;-[ \&quot; \&amp; \( \) \` \' \; \&lt; \&gt; \| \{ \} ]&gt; }
    regex list-element  { &lt;list&gt; | &lt;-[ \&quot; \! \$ \&amp; \( \) \` \' \; \&lt; \&gt; \|]&gt;  }
    regex a-to-z        { &lt;[ a..z A..Z ]&gt; }
    regex num           { \-? &lt;[ 0..9 ]&gt;+ }
    regex range         { &lt;alpha-range&gt; | &lt;num-range&gt; }
    regex num-range     { \{ &lt;num&gt;  \. \. &lt;num&gt; [ \. \. &lt;num&gt; ]? \} }
    regex alpha-range   { \{ &lt;a-to-z&gt; \. \. &lt;a-to-z&gt; [ \. \.&lt;num&gt; ]? \} }
    regex list          { \{ &lt;list-element&gt;+ % ',' \} }
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/ozzy/perl6/ch-1.p6">Ozzy</a> also wrote a grammar to parse the input string. Ozzy also used quite cleverly the <code>X~</code> cross product operator and concatenation operator:</p>

<pre><code class="language-Perl6">sub MAIN ( Str $string = 'Perl {Daily,Weekly,Monthly,Yearly} Challenge' ) {

    grammar G {
        token TOP           { ( &lt;h&gt; \{ &lt;alt&gt;+ % ',' \} &lt;t&gt; )+ }
        token h             { &lt;[\w\s]&gt;* }
        token alt           { &lt;[\w\s]&gt;+ }
        token t             { &lt;[\w\s]&gt;* }
    }

    my @m = G.parse($string)[0];
    my @r = &quot;&quot;;

    for ^@m.elems -&gt; $i {
        @r = (@r X~ @m[$i]&lt;h&gt; X~ @m[$i]&lt;alt&gt; X~ @m[$i]&lt;t&gt;);
    }
    .say for @r;
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/joelle-maslak/perl6/ch-1.p6">Joelle Maslak</a> wrote an awesome program handling both juxtaposed and nested curly braces. Of course, she used a grammar for this, then recursively exploring the parse tree. Joelle&rsquo;s Grammar is as follows:</p>

<pre><code class="language-Perl6">grammar Expansion {
    rule TOP      {
        ^
        &lt;element&gt;*
        $
    }
    token element  { &lt;string&gt; | &lt;curly&gt; }
    token string   { &lt;-[ \{ \} ]&gt;+ }
    token curly    { \{ &lt;option&gt;+ % ',' \} }
    token option   { &lt;innerele&gt;* }
    token innerele { &lt;innerstr&gt; | &lt;curly&gt; }
    token innerstr { &lt;-[ \{ \} \, ]&gt;+ }
}
</code></pre>

<p>But, while the grammar is in a sense the most powerful feature used by Joelle, the real work of her program is done in this subroutine:</p>

<pre><code class="language-Perl6">sub expansion(@arr is copy, $tree) {
    if $tree&lt;element&gt;:exists {
        # Handle each element.
        for @($tree&lt;element&gt;) -&gt; $ele {
            @arr = expansion(@arr, $ele);
        }
        return @arr;
    } elsif $tree&lt;innerele&gt;:exists {
        for @($tree&lt;innerele&gt;) -&gt; $ele {
            @arr = expansion(@arr, $ele);
        }
        return @arr;
    } elsif $tree&lt;string&gt;:exists {
        return @arr.map: { $_ ~ $tree&lt;string&gt; };
    } elsif $tree&lt;innerstr&gt;:exists {
        return @arr.map: { $_ ~ $tree&lt;innerstr&gt; };
    } elsif $tree&lt;curly&gt;:exists {
        my @arr-copy = @arr;
        @arr = [];
        for @($tree&lt;curly&gt;&lt;option&gt;) -&gt; $ele {
            @arr.append: expansion(@arr-copy, $ele);
        }
        return @arr;
    } else {
        die;
    }
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/ruben-westerberg/perl6/ch-1.p6">Ruben Westerberg</a> has an <code>expand</code> subroutine making most of the work:</p>

<pre><code class="language-Perl6">$_= @*ARGS.join(&quot; &quot;);
my $matches=m:g/\{.*?\}/;
my @entries;
@entries.push:  [.Str.split: /&lt;[\{\}\,]&gt;/, :skip-empty] for $matches.list;

expand($_,[],@entries,$matches.list).map(*.say);

sub expand($line,@stack,@entries, @positions) {
        my @results;
        if (@stack == @entries ) {
                my $l=$line;
                my $offset=0;
                for @stack.keys {
                        $l.substr-rw(@positions[$_].from-$offset, @positions[$_].chars)=@stack[$_];
                        $offset+=@positions[$_].chars-@stack[$_].chars;
                }
                return ($l,);
        }
        else {
                my @s;
                my @e=|@entries[@stack.elems];
                for @e  {
                        @s= (|@stack[], |$_);
                        @results.push( |expand($line, @s,@entries, @positions));
                }
                return @results;
        }
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/ulrich-rieke/perl6/ch-1.p6">Ulrich Rieke</a> provided a fairly concise script:</p>

<pre><code class="language-Perl6">#works only if there are no spaces in the expansion bracket!
sub MAIN( **@ARGS ) {
  my $howoften = @ARGS.elems - 2 ;
  for (1..$howoften) -&gt; $i {
      say &quot;@ARGS[0] @ARGS[$i] @ARGS[*-1]&quot; ;
  }
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/yet-ebreo/perl6/ch-1.p6">Yet Ebreo</a>&rsquo;s solution is using a recursive <code>expand</code> subroutine and is also quite concise once you remove lengthy comments as I did here (but follow the link if you want to read the comments):</p>

<pre><code class="language-Perl6">sub expand ($string) {
    my $mstring = $string;
    if ($mstring ~~ /\{(&lt;-[{}]&gt;*)\}/) {
        my ($l,$m,$r) = ($/.prematch,$0,$/.postmatch);
        for ($m.split(&quot;,&quot;)) {
            expand($l~$_~$r);
        }
    } else {
         say $mstring;
    }
}
</code></pre>

<p>To me, the code tends to be clearer without these comments, but that may just be me, YMMV.</p>

<p><a href="https://www.braincells.com/perl/2019/10/perl_weekly_challenge_week_29.html">Jaldhar H. Vyas</a> was away in a location with poor Internet access and therefore unable to complete the challenge in time. He nonetheless completed the challenge afterwards. He wrote an <code>expand</code> subroutine that first captures the data between braces, then splits ths captured string and use a <code>map</code> to build the various output strings:</p>

<pre><code class="language-Perl6">sub expand(Str $string) {
    $string ~~ / \{(.+)\} /;

    return $0.split(/\,\s*/).map({
        my $word = $_;
        (my $expansion = $string) ~~ s/\{.+\}/$word/;
        $expansion;
    });
}

sub MAIN(Str $string) {
    .say for expand($string);
}
</code></pre>

<h2 id="task-2-calling-a-c-function-from-perl-6">Task #2: Calling a C Function from Perl 6</h2>

<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2019/10/perl-weekly-challenge-29-file-type-and-digital-clock.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-029/">Week 29 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>

<p>The challenge reads as follows:</p>

<p>*Write a script to demonstrate calling a <strong>C function</strong>. It could be any user defined or standard <strong>C</strong> function.*</p>

<p>Note to the reader: it is now more or less official that Perl6 is going to be renamed &ldquo;Raku.&rdquo; This series of blogs will have to get used to it, but I won&rsquo;t switch to Raku immediately, since there is no Raku compiler or ecosystem yet.</p>

<h2 id="my-solutions">My Solutions</h2>

<p>Calling a function from a compiled C library is actually quite simple, using the <a href="https://docs.perl6.org/language/nativecall">NativeCall</a> module.</p>

<p>The documentation linked above says that the simplest imaginable use of <code>NativeCall</code> would look something like this:</p>

<pre><code class="language-Perl6">use NativeCall;
sub some_argless_function() is native('something') { * }
some_argless_function();
</code></pre>

<p>The documentation then explains further that the first line imports various traits and types. The next line looks like a relatively ordinary Perl 6 sub declaration—with a twist. We use the &ldquo;native&rdquo; trait in order to specify that the sub is actually defined in a native library. The platform-specific extension (e.g., .so or .dll), as well as any customary prefixes (e.g., &lsquo;lib&rsquo;) will be added for you.</p>

<p>The first time you call &ldquo;some_argless_function&rdquo;, the &ldquo;libsomething&rdquo; will be loaded and the &ldquo;some_argless_function&rdquo; will be located in it. A call will then be made. Subsequent calls will be faster, since the symbol handle is retained.</p>

<p>Of course, most functions take arguments or return values, but even that is quite simple. And I did not have any problem calling an existing function from the standard C library, but that&rsquo;s not a very interesting problem. I really wanted to do the whole thing, including building and using my own C library,</p>

<p>The only real difficulty for me was to build a C library for the purpose of this challenge. Although I haven&rsquo;t written any serious program in C for more than 15 years, I still remember enough about the C language to be able to write simple C functions without trouble, except for the irritating fact that a C compiler is much less user-friendly than Perl (for example, the C compiler complained when I omitted semi-colons (<code>;</code>) before closing curly braces, which, of course, you can do in Perl), but that&rsquo;s secondary. No, the difficulty for me was elsewhere: not having used the GCC compiler and related tools for anything serious for so many years, I had to navigate through the GCC documentation and some examples on the Internet to find out how to build a static or shared library with it and do quite a number of tests before it actually worked. As you&rsquo;ve understood, I&rsquo;m really not an expert on compiling and properly linking C libraries, so the solutions presented below may not be the best, but, at least, they worked for me.</p>

<h3 id="starting-with-a-very-simple-c-function">Starting With a Very Simple C Function</h3>

<p>I started with a very simple C <code>calc.c</code> program providing an single <code>add</code> function:</p>

<pre><code class="language-C">#include &lt;stdio.h&gt;
int add (int a, int b) {
    return a + b;
}
</code></pre>

<p>and a simple Perl 6 script calling it:</p>

<pre><code class="language-Perl6">use NativeCall;

sub add(int32, int32)
    returns int32
    is native('./calc.dll')
    { * }

say add(3, 4);
</code></pre>

<p>Note that the Perl 6 script uses Perl 6 <a href="https://docs.perl6.org/language/nativetypes">native types</a> (such as <code>int32</code>) for the variables passed to the C function.</p>

<p>After a number of faulty tries, I was able to find the right GCC compiling and linking flags and build a shared library, and run the program:</p>

<pre><code>$ gcc -c -fPIC calc.c -o calc.o

$ gcc -shared calc.o -o calc.dll

$ perl6 calc.p6
7
</code></pre>

<p>Note that these examples are run on Cygwin, so they use the Linux bash syntax, but the C library receives a Windows name (<code>*.dll</code>).</p>

<p>After some further tests, I found that the compilation of the C library with GCC can be made simpler:</p>

<pre><code>$ gcc -shared -o calc.dll calc.c
</code></pre>

<p>If this were a tutorial on using C functions in Perl 6, I would have to explain in details the <code>gcc</code> options and probably to show how a <code>makefile</code> could automatize all this. But I&rsquo;m just a beginner with C functions in Perl 6, I certainly cannot claim to offer a tutorial on this subject. My only ambition is to show how I solved a specific task.</p>

<h3 id="benchmarking-a-pure-perl-6-program-and-a-native-c-library">Benchmarking a Pure Perl 6 Program and a Native C Library</h3>

<p>Now that we know how to run a basic function from a C library, we can try something more interesting: benchmarking a pure Perl 6 subroutine against a native C function. For this, I chose to use a recursive implementation of the Fibonacci sequence, since execution times get very long even for moderately large input. Of course, it is possible to memoize the recursive Fibonacci subroutine to obtain very small execution times, but I don&rsquo;t want to do it (at least not for the time being, we&rsquo;ll do it later), since I want to compare naïve recursive implementations to compare their durations.</p>

<p>The following <code>fibonacci.c</code> program provides a recursive <code>fib</code> function:</p>

<pre><code class="language-C">#include &lt;stdio.h&gt;
int fib (int a) {
    if (a == 0 || a == 1) {
        return 1;
    } else {
        return fib(a -1 ) + fib(a - 2);
    }
}
</code></pre>

<p>The <code>fibo.p6</code> program below uses both the native <code>fib</code> function and a pure Perl 6 <code>fib-p6</code> subroutine and record their execution times:</p>

<pre><code class="language-Perl6">use v6;
use NativeCall;

sub fib(int32)
    returns int32
    is native('./fibonacci.dll')
    { * }

sub fib-p6 (Int $num) {
    return 1 if $num == 0 or $num == 1;
    return fib-p6($num - 1) + fib-p6($num - 2);
}

sub MAIN (Int $num where * &gt;= 0 = 36 ) {
    my $start-time = INIT now;
    say &quot;C library function: &quot;, fib($num);
    say &quot;Duration C function: &quot;, now - $start-time;
    my $now = now;
    say &quot;P6 subroutine: &quot;, fib-p6 $num;
    say &quot;Duration P6 subroutine: &quot;, now - $now;
}
</code></pre>

<p>Building the shared library and running the benchmark shows the following result:</p>

<pre><code>$ gcc -shared -o fibonacci.dll fibonacci.c

$ perl6 fibo.p6
C library function: 24157817
Duration C function: 0.1306511
P6 subroutine: 24157817
Duration P6 subroutine: 37.425447
</code></pre>

<p>The result is really impressive: 0.13 seconds for the C <code>fib</code> function and 37 seconds for <code>fib-p6</code> the pure Perl 6 implementation. With the default 36 input value, the C function runs 286 times faster!</p>

<p>This being said, using the proper algorithm is often much better than using a faster programming language (when possible). Let&rsquo;s try to memoize manually the <code>fib-p6</code> pure Perl 6 subroutine by storing the Fibonacci numbers in a <code>@fibo</code> array for fast lookup:</p>

<pre><code class="language-Perl6">sub fib-p6 (Int $num) {
    state @fibo = 1, 1;    # initialization that removes the need for a base case
    @fibo[$num] = fib-p6($num - 1) + fib-p6($num - 2) unless defined @fibo[$num];
    return @fibo[$num];
}
</code></pre>

<p>Note that there are some possibilities for memoizing automatically a function, but I preferred to do it manually to show how it works and how simple it is, rather than giving an impression of magics.</p>

<p>The memoized pure Perl 6 subroutine is now about 130 times faster than the C function:</p>

<pre><code>$ perl6 fibo.p6
C library function: 24157817
Duration C function: 0.129651
P6 subroutine: 24157817
Duration P6 subroutine: 0.000997
</code></pre>

<p>I have to deeply thank Mohammad Anwar for having forced me with this challenge to go through this somewhat painful process, as I now have in my toolbox a very useful instrument that can be used when Perl 6 is not quite fast enough. I hope this blog post will be a useful example for others.</p>

<h2 id="alternative-solutions">Alternative Solutions</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/arne-sommer/perl6/ch-2.p6">Arne Sommer</a> used the <code>toupper</code> function of the standard C library (probably <code>libc</code> or <code>glibc</code>):</p>

<pre><code class="language-Perl6">use NativeCall;

sub toupper(uint8) returns uint8 is native('c', v6) { * }

sub to-upper ($string)
{
  return $string.comb.map({ toupper($_.ord).chr }).join;
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/daniel-mita/perl6/ch-2.p6">Daniel Mita</a> also used a standard C library function, <code>getrandom</code>. In the event of an error, his program also uses the <code>strerror</code> function to retrieve the string describing the error.</p>

<pre><code class="language-Perl6">sub MAIN (
  UInt  $bytes = 8, #= Number of random bytes (defaults to 8)
  UInt :$flags = 0,
  --&gt; Nil
) {
  given Buf.allocate: $bytes {
    given .&amp;getrandom: $bytes, $flags {
      when -1 {
        die sub strerror( int32 --&gt; Str ) is native {*}(
          cglobal |( 'c', v6; 'errno'; int32 ) );
      }
      when * &lt; $bytes { die 'got fewer bytes than requested' }
    }
    .say;
  }
}

sub getrandom ( Buf, size_t, uint32 --&gt; ssize_t ) is native {*}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/kevin-colyer/perl6/ch-2.p6">Kevin Colyer</a> used functions from the <code>libqrencode</code> library to process QR codes:</p>

<pre><code class="language-Perl6">use NativeCall;

constant LIBQRENCODE = '/usr/lib/x86_64-linux-gnu/libqrencode.so.3';

# Level of error correction. (lowest to highest)
enum  QRecLevel &lt;QR_ECLEVEL_L QR_ECLEVEL_M QR_ECLEVEL_Q QR_ECLEVEL_H&gt;;

class QRcode is repr('CStruct') {
    has int32           $.version;
    has int32           $.width;
    has Pointer[uint8]  $.data; # sized width*width
}

# QRcode* QRcode_encodeString8bit   (   const char *    string, int     version, QRecLevel  level )
sub QRcode_encodeString8bit ( Str is encoded('utf8'), uint8, uint8 ) returns QRcode is native( LIBQRENCODE ) { * }
sub QRcode_free             ( QRcode )                                              is native( LIBQRENCODE ) { * }
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/markus-holzer/perl6/ch-2.p6">Markus Holzer</a> used the <code>MessageBoxW</code> function of a C Microsoft library, which pops up a message box.</p>

<pre><code class="language-Perl6">use NativeCall;

constant WCHAR              = uint16;
constant INT                = int32;
constant UINT               = uint32;
constant HANDLE             = Pointer[void];
constant LPWCTSTR           = CArray[WCHAR];
constant MB_ICONEXCLAMATION = 0x00000030;

sub MessageBoxW( HANDLE, LPWCTSTR, LPWCTSTR, UINT ) is native('user32') returns INT { * };

MessageBoxW( my $handle, to-c-str(&quot;Raku is awesome&quot;), to-c-str(&quot;Hello World&quot;), MB_ICONEXCLAMATION );

sub to-c-str( Str $str ) returns CArray[WCHAR]
{
    my @str := CArray[WCHAR].new;
    for ( $str.comb ).kv -&gt; $i, $char { @str[$i] = $char.ord; }
    @str[ $str.chars ] = 0;
    @str;
}
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/noud/perl6/ch-2.p6">Noud</a> wrote a <code>rot13</code> C function performing ROT13 encryption (where all letters are shifted in the alphabet by 13 positions so that the same program can be used for both encrypting and decrypting):</p>

<pre><code class="language-C">#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *rot13(char *s) {
    const size_t s_len = strlen(s);
    char *result = malloc((s_len + 1) * sizeof(char));

    for (size_t i = 0; i &lt; s_len; i++) {
        if (isalpha(s[i])) {
            if ((tolower(s[i]) - 'a') &lt; 13) {
                result[i] = s[i] + 13;
            } else {
                result[i] = s[i] - 13;
            }
        } else {
            result[i] = s[i];
        }
    }

    result[s_len] = '\0';

    return result;
}
</code></pre>

<p>The shared C library can be build with the following <code>make.sh</code> shell script:</p>

<pre><code class="language-sh">gcc -shared -o rot13.so rot13.c
</code></pre>

<p>And this is the Perl 6 program:</p>

<pre><code class="language-Perl6">use NativeCall;

sub rot13(Str) returns Str is native('./rot13.so') {*};

my $enc = rot13(&quot;hello perl weekly challenge!&quot;);
my $dec = rot13($enc);

say &quot;ROT13 encryption: $enc&quot;;
say &quot;ROT13 decryption: $dec&quot;;
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/joelle-maslak/perl6/ch-2.p6">Joelle Maslak</a> used a native <code>sleep</code> C function (presumably from one of the Unix/Posix libraries, such as <code>unistd</code>)</p>

<pre><code class="language-Perl6">use v6;

use NativeCall;

sub MAIN(UInt:D $seconds = 2) {
    my $ret = native-sleep($seconds);
    say &quot;Sleep returned a value of $ret&quot;;
}

my sub native-sleep(uint64 --&gt;uint64) is native is symbol('sleep') { * }
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/roger-bell-west/perl6/ch-2.p6">Roger Bell West</a> used the standard C <code>printf</code> function:</p>

<pre><code class="language-Perl6">use NativeCall;

our sub cpf(Str, Str --&gt; int32) is native(sub{'libc.so.6'}) is symbol('printf') { * }

cpf(&quot;%s\n&quot;,'a string passed from perl6');
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/ruben-westerberg/perl6/ch-2.p6">Ruben Westerberg</a> used the <code>getuid</code> C function (presumably from one of the Unix/Posix libraries, such as <code>inistd</code>):</p>

<pre><code class="language-Perl6">use NativeCall;
sub getuid() returns uint32   is native { * };
put &quot;User ID: &quot;~getuid;
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/ulrich-rieke/perl6/ch-2.p6">Ulrich Rieke</a> used the <code>strcmp</code> function of the standard C library:</p>

<pre><code class="language-Perl6">use NativeCall ;
constant LIBC = '/lib/x86_64-linux-gnu/libc.so.6' ;
sub strcmp( CArray[uint8], CArray[uint8]) returns int32 is native(LIBC) { * } ;
</code></pre>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-029/yet-ebreo/perl6/ch-2.p6">Yet Ebreo</a>&rsquo;s solution looks very much like my second solution: he implemented a C function to compute a Fibonacci number, probably something like this (at least, that what he used in his Perl 5 implementation):</p>

<pre><code class="language-C">unsigned long fib(int n) {
    if ( n == 0 )
        return 0;
    else if ( n == 1 )
        return 1;
    else
        return ( fib(n-1) + fib(n-2) );
}
</code></pre>

<p>He then proceeded to compare the C function with a naïve pure Perl 6 implementation and with a memoized (<code>is cached</code>) Perl 6 implementation:</p>

<pre><code class="language-Perl6">use NativeCall;
use experimental :cached;
sub fib(int32) returns int32 is native('fib.so') {*}

sub MAIN () {

    my $start = now;
    print (perl_fib($_)~&quot; &quot;) for 1..36;

    say &quot;\nRun Time (Perl): &quot;~(now - $start)~&quot; sec\n&quot;;

    $start = now;
    print (perl_fib_cached($_)~&quot; &quot;) for 1..36;

    say &quot;\nRun Time (Perl-Cached): &quot;~(now - $start)~&quot; sec\n&quot;;

    $start = now;
    print (fib($_)~&quot; &quot;) for 1..36;

    say &quot;\nRun Time: (NativeCall)&quot;~(now - $start)~&quot; sec\n&quot;;
}

sub perl_fib($n)  { ($n == 0) ?? 0 !! ($n == 1) ?? 1 !! perl_fib($n-1)+perl_fib($n-2) }
sub perl_fib_cached($n) is cached { ($n == 0) ?? 0 !! ($n == 1) ?? 1 !! perl_fib_cached($n-1)+perl_fib_cached($n-2) }
</code></pre>

<p>Running Yet&rsquo;s program yields the following output:</p>

<pre><code># perl6 .\ch-2.p6 32
# 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352
# Run Time (Perl): 74.794843 sec
#
# 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352
# Run Time (Perl-Cached): 0.029755 sec
#
# 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352
# Run Time: (NativeCall)0.31090124 sec
</code></pre>

<p>We can see here again that the C function is much faster than the naïve pure Perl 6 implementation, but the P6 memoized version (<code>Perl-Cached</code>) is much faster than the C function.</p>

<p><a href="https://www.braincells.com/perl/2019/10/perl_weekly_challenge_week_29.html">Jaldhar H. Vyas</a> was away in a location with poor Internet access and therefore unable to complete the challenge in time. He nonetheless completed the challenge afterwards. He first wrote a C program containing a simple <code>hello</code> function displaying &ldquo;Hello world!&rdquo; on the screen. This is the C function:</p>

<pre><code class="language-C">void hello() {
    puts(&quot;Hello world!&quot;);
}
</code></pre>

<p>This is the <code>Hello</code> Perl 6 module using using the C <code>hello</code> function:</p>

<pre><code class="language-Perl6">use v6;
unit module Hello;

use NativeCall;

sub libhello is export {
    return '../c/libhello.so';
}

sub hello() is native(&amp;libhello) is export {*};
</code></pre>

<p>And, this is an example of Perl 6 code calling the aforesaid module.</p>

<pre><code class="language-Perl6">use lib '.';
use Hello;

hello();
</code></pre>

<h2 id="see-also">SEE ALSO</h2>

<p>Three blog posts this time:</p>

<p>Arne Sommer: <a href="https://perl6.eu/bracen-c.html">https://perl6.eu/bracen-c.html</a>;</p>

<p>Yet Ebrao: <a href="https://doomtrain14.github.io/pwc/2019/10/13/pwc_calling_c.html">https://doomtrain14.github.io/pwc/2019/10/13/pwc_calling_c.html</a>. Yet&rsquo;s blog post really relates to his Perl 5 implementation of the challenge, but it still does shed some light on his Perl 6 implementation.</p>

<p>Jaldhar H. Vyas: <a href="https://www.braincells.com/perl/2019/10/perl_weekly_challenge_week_29.html">https://www.braincells.com/perl/2019/10/perl_weekly_challenge_week_29.html</a>.</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important (send me an e-mail or just raise an issue against this GitHub page).</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h1>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->


<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

