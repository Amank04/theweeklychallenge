<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Raku Weekly Review: Challenge - #047">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.55.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Raku Weekly Review: Challenge - #047</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Raku Weekly Review: Challenge - #047</h2>
                    <div class="portfolio-meta">
                        <span>Friday, Feb 21, 2020</span>|
                        <span> Tags:
                            raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p6-review-challenge-047.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    

<p>Continues from <a href="/blog/p6-review-challenge-046/">previous week</a>.</p>

<p>Welcome to the Raku review for Week 047 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-047/">original tasks</a> and <a href="/blog/recap-challenge-047/">recap</a> of the weekly challenge.</p>

<h2 id="getting-in-touch">Getting in Touch</h2>

<p><a href="mailto:rjt@cpan.org"><img src="http://ry.ca/misc/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>

<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="http://ry.ca/misc/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>

<p><a href="https://twitter.com/perlwchallenge"><img src="http://ry.ca/misc/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>

<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<h3 id="task-1-task1"><a href="#task1">Task 1</a></h3>

<p>[ <a href="#arne-sommer1">Arne Sommer</a>  | <a href="#jaldhar-h-vyas1">Jaldhar H. Vyas</a>  | <a href="#javier-luque1">Javier Luque</a>  | <a href="#kevin-colyer1">Kevin Colyer</a>  | <a href="#laurent-rosenfeld1">Laurent Rosenfeld</a>  | <a href="#luca-ferrari1">Luca Ferrari</a>  | <a href="#mark-anderson1">Mark Anderson</a>  | <a href="#markus-holzer1">Markus Holzer</a>  | <a href="#noud1">Noud Aldenhoven</a>  | <a href="#ruben-westerberg1">Ruben Westerberg</a>  | <a href="#simon-proctor1">Simon Proctor</a>  | <a href="#ulrich-rieke1">Ulrich Rieke</a>  ]</p>

<h3 id="task-2-task2"><a href="#task2">Task 2</a></h3>

<p>[ <a href="#alicia-bielsa2">Alicia Bielsa</a>  | <a href="#arne-sommer2">Arne Sommer</a>  | <a href="#athanasius2">Athanasius</a>  | <a href="#colin-crain2">Colin Crain</a>  | <a href="#jaldhar-h-vyas2">Jaldhar H. Vyas</a>  | <a href="#javier-luque2">Javier Luque</a>  | <a href="#kevin-colyer2">Kevin Colyer</a>  | <a href="#luca-ferrari2">Luca Ferrari</a>  | <a href="#mark-anderson2">Mark Anderson</a>  | <a href="#markus-holzer2">Markus Holzer</a>  | <a href="#noud2">Noud Aldenhoven</a>  | <a href="#ruben-westerberg2">Ruben Westerberg</a>  | <a href="#ryan-thompson2">Ryan Thompson</a>  | <a href="#simon-proctor2">Simon Proctor</a>  | <a href="#ulrich-rieke2">Ulrich Rieke</a>  ]</p>

<h3 id="blogs-blogs"><a href="#blogs">Blogs</a></h3>

<hr />

<hr />

<h1 id="task1">Task #1 - Roman Calculator</h1>

<p>The first task is to write a script that accepts two Roman numbers and an arithmetic operator. It should then calculate the result and return it as another Roman number. For example:</p>

<pre><code>perl ch-1.pl V + VI
XI
</code></pre>

<p>The Raku solutions for this task, while lengthy at an average of 66 lines, are still shorter than the Perl solutions by about <sup>1</sup>&frasl;<sub>3</sub>. This is a very crude metric, but it feels about right, combined with my own sense of expressiveness in the Raku solutions.</p>

<p>A few people used modules, several re-used their solutions from <a href="/blog/p6-review-challenge-010/">Week 010</a>, while the rest wrote all new Roman number routines.</p>

<hr />

<h2 id="arne-sommer1">Arne Sommer</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/arne-sommer/raku/ch-1.p6">Arne Sommer&rsquo;s solution</a> uses a modified version of his Roman number code from Week 10, which Arne has put into a <code>Number::Roman</code> library (not included with his submission). Here is the main logic:</p>

<pre><code class="language-raku">use Number::Roman :to, :from;
unit sub MAIN (Str $first, Str $operator, Str $second);
my $f = from-roman($first);
my $s = from-roman($second);
given $operator
{
  when '+' { say to-roman($f + $s) };
  when '-' { say to-roman($f - $s) };
  when 'x' { say to-roman($f * $s) };
  when '*' { say to-roman($f * $s) };
  when '/' { say to-roman(Int($f) / Int($s)) };
}
</code></pre>

<p><code>given ... when</code> is a good choice here. Arne also provides some other solutions, such as one using <code>multi MAIN</code> subs instead, which I&rsquo;ll just show the signatures of:</p>

<pre><code class="language-raku">multi MAIN (Str $first, &quot;+&quot;, Str $second);
multi MAIN (Str $first, &quot;-&quot;, Str $second);
multi MAIN (Str $first, '*', Str $second);
multi MAIN (Str $first, 'x', Str $second);
multi MAIN (Str $first, &quot;/&quot;, Str $second);
</code></pre>

<p>Arne&rsquo;s blog does have a code listing for <code>Number::Roman</code>, which I would highly suggest reading, as he discusses several interesting aspects of this challenge and his solution.</p>

<p><strong>Blog</strong> › <a href="https://raku-musings.com/roman-gap.html">The Roman Gap with Raku</a></p>

<h2 id="jaldhar-h-vyas1">Jaldhar H. Vyas</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/jaldhar-h-vyas/raku/ch-1.p6">Jaldhar H. Vyas&rsquo;s solution</a> seems to mirror his Perl solution, whereby numbers go through a multi-step process of <code>unprefix</code>, <code>reorder</code> and <code>normalize</code> steps:</p>

<pre><code class="language-raku">sub unprefix(Str $num) {
    my $unprefixed = $num;
    my @from = qw/ CM    CD   XC    XL   IX    IV   /;
    my @to =   qw/ DCCCC CCCC LXXXX XXXX VIIII IIII /;
    for 0 ..^ @from.elems -&gt; $i {
        $unprefixed = $unprefixed.subst(@from[$i], @to[$i], :g);
    }
    return $unprefixed;
}
sub reorder(Str $num) {
    my %order = (
        'M' =&gt; 0, 'D' =&gt; 1, 'C' =&gt; 2, 'L' =&gt; 3, 'X' =&gt; 4, 'V' =&gt; 5, 'I' =&gt; 6
    );
    return $num.comb.sort({ %order{$^a} &lt;=&gt; %order{$^b} }).join;
}
sub normalize(Str $num) {
    my $normalized = $num;
    my @from = qw/ IIIII IIII VV VIV XXXXX XXXX LL LXL CCCCC CCCC DD DCD /;
    my @to =   qw/ V     IV   X  IX  L     XL   C  XC  D     CD   M  CM  /;
    for 0 ..^ @from.elems -&gt; $i {
        $normalized = $normalized.subst(@from[$i], @to[$i], :g);
    }
    return $normalized;
}
</code></pre>

<p>The <code>MAIN</code> sub accepts the two numbers and an <code>$op</code>, <code>+</code> or <code>-</code>. Pay close attention to how Jaldhar implements the operations:</p>

<pre><code class="language-raku">multi sub MAIN(
    Str $num1, #= Number in Roman numerals
    Str $op where { /\+/ || /\-/ }, #= Arithmetic operation (+ or -)
    Str $num2, #= Number in Roman numerals
    ) {
    if $op eq '+' {
        say normalize(reorder(unprefix($num1) ~ unprefix($num2)));
    } elsif $op eq '-' {
        my $un1 = unprefix($num1);
        my $un2 = unprefix($num2);
        while ($un2.chars) {
            ($un1, $un2) = largestOrder(|removeCommon($un1, $un2));
        }
        say normalize($un1);
    }
}
</code></pre>

<p>These operations are very interesting, in that they don&rsquo;t actually convert the Roman numbers to Arabic at any point! I believe Jaldhar is the only one to do it this way in this challenge.</p>

<p>For example, with the addition operator, Jaldhar simply concatenates the two Roman numbers before passing them through his normalization process. This works because his lower level subs are, by design, extremely permissive in what they accept, and the <code>normalize</code> sub ensures the answer is put in proper Roman form.</p>

<p>Similarly, the subtraction operator works by expanding the numbers and removing common substrings.</p>

<h2 id="javier-luque1">Javier Luque</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/javier-luque/raku/ch-1.p6">Javier Luque&rsquo;s solution</a> uses a dispatch table to implement the operations:</p>

<pre><code class="language-raku">sub MAIN($equation) {
    my %operators = (
        '+' =&gt; -&gt; $a , $b { rtoa($a) + rtoa($b) },
        '-' =&gt; -&gt; $a , $b { rtoa($a) - rtoa($b) },
        'x' =&gt; -&gt; $a , $b { rtoa($a) * rtoa($b) },
        '/' =&gt; -&gt; $a , $b { rtoa($a) / rtoa($b) },
    );
    if ($equation ~~ /^(\w+)\s*(\+|\-|x|\/)\s*(\w+)$/) {
        say ator(%operators{$1}($0.Str, $2.Str).Int);
    } else {
        say &quot;Invalid input&quot;;
    }
}
</code></pre>

<p>Then, citing inspiration from the <a href="https://examples.p6c.dev/index.html">Perl 6 Examples</a> site, Javier uses a <code>multi</code> sub, <code>rtoa</code>, to convert from Roman to Arabic, shown here, in part:</p>

<pre><code class="language-raku"># Inspired by:
# https://examples.p6c.dev/categories/euler/prob089-andreoss.html
multi rtoa() { 0 }
multi rtoa(Str $r where $r.chars &gt; 1 ) {
    rtoa(| $r.comb)
}
multi rtoa('I',      |a) { 1   + rtoa(|a) }
multi rtoa('I', 'V', |a) { 4   + rtoa(|a) }
multi rtoa('V',      |a) { 5   + rtoa(|a) }
...
multi rtoa('C', 'M', |a) { 900 + rtoa(|a) }
multi rtoa('M',      |a) { 1000 + rtoa(|a) }
</code></pre>

<p>The corresponding <code>ator</code> sub uses <code>given ... when</code>:</p>

<pre><code class="language-raku">sub ator(Int $n) returns Str {
    given $n {
        when $n &gt;= 1000 { 'M'  ~ ator($n- 1000) }
        when $n &gt;= 900  { 'CM' ~ ator($n - 900) }
        ...
        when $n &gt;= 4    { 'IV' ~ ator($n - 4) }
        when $n &gt;= 1    { 'I'  ~ ator($n - 1) }
        default        { '' }
    }
}
</code></pre>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/10/perl-weekly-challenge-047/">047 – Perl Weekly Challenge</a></p>

<h2 id="kevin-colyer1">Kevin Colyer</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/kevin-colyer/raku/ch-1.p6">Kevin Colyer&rsquo;s solution</a> has <code>toRoman</code> and <code>fromRoman</code> subs that use arrays, and iterate over them pairwise. Here is the <code>toRoman</code> sub::</p>

<pre><code class="language-raku">sub toRoman($i is copy) {

    my @t=[1000 , &quot;M&quot;, 900 , &quot;CM&quot;, 500 , &quot;D&quot;, 400 , &quot;CD&quot;, 100 , &quot;C&quot;, 90 ,
        &quot;XC&quot;, 50 , &quot;L&quot;, 40 , &quot;XL&quot;, 10 , &quot;X&quot;, 9 , &quot;IX&quot;, 5 , &quot;V&quot;, 4 , &quot;IV&quot;, 1 , &quot;I&quot;];
    my $rn;
    return &quot;Error - Negative Value&quot; if $i &lt; 0;
    while $i {
        for @t -&gt; $d,$n {
            if $i-$d&gt;=0 {
                $rn~=$n;
                $i-=$d;
                last;
            }
        }
    }
    return $rn;
}
</code></pre>

<p>Here, Kevin opportunistically subtracts the maximum value possible each time through the loop, and appends the Roman numeral to the result string.</p>

<p>Kevin&rsquo;s main logic uses a <code>given ... when</code> block to handle the four basic arithmetic operators:</p>

<pre><code class="language-raku">#| Roman Numberal Calculator - Numeral1 +-/* Numeral2 (/ and * require quoting)
sub MAIN(Str $numeral1, Str $operation, Str $numeral2) {
    my $n1=fromRoman($numeral1);
    my $n2=fromRoman($numeral2);
    given $operation {
        when '+' { toRoman($n1+$n2).say };
        when '-' { toRoman($n1-$n2).say };
        when '*' { toRoman($n1*$n2).say };
        when '/' { toRoman(Int($n1/$n2)).say };
        default { say &quot;Unknown operation '$operation'&quot; }
    }
}
</code></pre>

<h2 id="laurent-rosenfeld1">Laurent Rosenfeld</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/laurent-rosenfeld/raku/ch-1.p6">Laurent Rosenfeld&rsquo;s solution</a> reuses the <code>from-roman</code> and <code>to-roman</code> code from his Week 10 solution. It wasn&rsquo;t reviewed at that time, though, so I&rsquo;ll highlight the <code>from-roman</code> sub here:</p>

<pre><code class="language-raku">subset Roman-str of Str where $_ ~~ /^&lt;[IVXLCDMivxlcdm]&gt;+$/;
my %rom-tab = &lt; I 1   V 5   X 10   L 50   C 100  D 500  M 1000
               IV 4  IX 9   XL 40  XC 90  CD 400   CM 900 &gt;;
my @ordered_romans = reverse sort { %rom-tab{$_} }, keys %rom-tab;

sub from-roman (Roman-str $roman) {
    my $numeric = 0;
    my $prev_letter = &quot;M&quot;;
    for $roman.uc.comb -&gt; $letter {
        $numeric -= 2 * %rom-tab{$prev_letter}
            if %rom-tab{$letter} &gt; %rom-tab{$prev_letter};
        $numeric += %rom-tab{$letter};
        $prev_letter = $letter;
    }
    return $numeric;
}
</code></pre>

<p>I really like the use of the <code>Roman-str</code> subset here, serving as argument validation. The sub itself <code>comb</code>s over the input string, and if the next letter is larger (i.e., it has a larger value as a Roman numeral), then the current letter must be subtracted. Otherwise, it is added. Laurent&rsquo;s logic is to <em>always</em> add the number, and then subtract it twice if the next letter is larger.</p>

<p>Laurent&rsquo;s main logic uses string <code>EVAL</code>, after validating the input, and supports any expression with at least two terms:</p>

<pre><code class="language-raku">my @input;
for @*ARGS {
    push @input, $_ if /&lt;[-+*\/]&gt;/;
    push @input, from-roman $_ if m:i/&lt;[ivxlcdm]&gt;+/;
}
die &quot;Need at least three parameters&quot; if @input &lt; 3; # we need at least 1 operator and two operands
my $result = EVAL join ' ', @input;
say &quot;@*ARGS[] = &quot;, to-roman $result;
</code></pre>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-47-roman-calculator-and-gapful-numbers.html">Roman Calculator and Gapful Numbers</a></p>

<h2 id="luca-ferrari1">Luca Ferrari</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/luca-ferrari/raku/ch-1.p6">Luca Ferrari&rsquo;s solution</a> has an interesting approach in his <code>convert-roman-to-arabic</code> sub:</p>

<pre><code class="language-raku">my %roman-to-arabic = :I(1), :V(5), :X(10), :L(50), :C(100), :D(500), :M(1000);
# Function to convert a roman number into an arabic one.
sub convert-roman-to-arabic( Str:D $roman  ) {
    my @arabic-digits = $roman.uc.comb.reverse.map: {
        state $last = 0;
        my $value = %roman-to-arabic{ $_ };
        $value *= -1 if $value &lt; $last;
        $last = $value;
        $value;
    };
    return [+] @arabic-digits;
}
</code></pre>

<p>Luca first reverses the string&rsquo;s character array, then finds the value of each letter. If that value is less than the previous one, that means we&rsquo;re in a subtractive part of the number (like <code>IX</code>), so Luca flips the sign. The result is the sum of all of these values.</p>

<p>The main logic uses a <code>do given ... when</code> block to feed the <code>$result</code>, which is then converted back to a Roman number with <code>convert-arabic-to-roman</code>.</p>

<pre><code class="language-raku">die &quot;Usage: $*PROGRAM &lt;operand&gt; &lt;operator&gt; &lt;operand&gt;&quot; if @*ARGS.elems != 3;
my $operand-a = convert-roman-to-arabic( @*ARGS[0] );
my $operand-b = convert-roman-to-arabic( @*ARGS[2] );
my $result = do given @*ARGS[1].trim {
    when '+' { $operand-a + $operand-b; }
    when '-' { $operand-a - $operand-b; }
    when '/' { $operand-a / $operand-b; }
    when '*' { $operand-a * $operand-b; }
};
say convert-arabic-to-roman( $result );
</code></pre>

<p><strong>Blog</strong> › <a href="https://fluca1978.github.io/2020/02/10/PerlWeeklyChallenge47.html#task1">Roman Number Calculator and Gapful Numbers</a></p>

<h2 id="mark-anderson1">Mark Anderson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/mark-anderson/raku/ch-1.p6">Mark Anderson&rsquo;s solution</a> provides two classes, that use grammars to assist with conversion. I&rsquo;ll show one of the classes here, but the other works similarly:</p>

<pre><code class="language-raku">grammar Roman2Arabic {
    token TOP {
        :my $*Arabic;
        &lt;Thousands&gt;? &lt;Hundreds&gt;? &lt;Tens&gt;? &lt;Ones&gt;?
    }
    token Thousands { [M ** 1..3] }
    token Hundreds  { [C [C ** 1..2|D|M]?] || [D [C ** 1..3]?] }
    token Tens      { [X [X ** 1..2|C|L]?] || [L [X ** 1..3]?] }
    token Ones      { [I [I ** 1..2|V|X]?] || [V [I ** 1..3]?] }
}
grammar Arabic2Roman {
    token TOP       {
        :my $*Roman;
        &lt;Thousands&gt;? &lt;Hundreds&gt;? &lt;Tens&gt;? &lt;Ones&gt;?
    }
    token Thousands { &lt;[123]&gt; &lt;?before \d ** 3&gt; }
    token Hundreds  { \d &lt;?before \d ** 2&gt; }
    token Tens      { \d &lt;?before \d&gt; }
    token Ones      { \d }
}
class Roman2ArabicActions {
    method TOP ($/) {
        make $*Arabic;
    }
    method Thousands ($/) {
        $*Arabic = 1000 * $/.chars;
    }
    method Hundreds ($/) {
        state %lookup = &lt;C CC CCC CD D DC DCC DCCC CM&gt; Z=&gt; [1 .. 9];
        $*Arabic += %lookup{ $/ } * 100;
    }
    method Tens ($/) {
        state %lookup = &lt;X XX XXX XL L LX LXX LXXX XC&gt; Z=&gt; [1 .. 9];
        $*Arabic += %lookup{ $/ } * 10;
    }
    method Ones ($/) {
        state %lookup = &lt;I II III IV V VI VII VIII IX&gt; Z=&gt; [1 .. 9];
        $*Arabic += %lookup{ $/ };
    }
}
</code></pre>

<p>There is also a calculator class that does all of the work of parsing and processing the operations:</p>

<pre><code class="language-raku">grammar Calculator {
    rule  TOP      {
        :my @*Arabics;
        :my $*Answer;
        :my $*Operator;
        &lt;Roman&gt; &lt;Operator&gt; &lt;Roman&gt;
    }
    token Roman    { &lt;[I V X L C D M]&gt;+ }
    token Operator { &lt;[+ x / -]&gt; }
}
class CalculatorActions {
    method TOP ($/) {
        make $*Answer if $*Answer;
    }
    method Roman ($match) {
        push(@*Arabics, Roman2Arabic.parse($match, :actions(
                        Roman2ArabicActions)).made);
        if ($*Operator) {
            given $*Operator {
                when &quot;+&quot; { $*Answer = [+] @*Arabics }
                when &quot;-&quot; { $*Answer = [-] @*Arabics }
                when &quot;x&quot; { $*Answer = [*] @*Arabics }
                when &quot;/&quot; { $*Answer = [/] @*Arabics }
            }
            $*Answer = Arabic2Roman.parse($*Answer, :actions(
                       Arabic2RomanActions)).made;
        }
    }
    method Operator ($/) {
        $*Operator = $/;
    }
}
</code></pre>

<p>After all that, the main logic is one statement:</p>

<pre><code class="language-raku">sub MAIN(*@args) {
    Calculator.parse(@args.Str, :actions(CalculatorActions)).made.say;
}
</code></pre>

<h2 id="markus-holzer1">Markus Holzer</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/markus-holzer/raku/ch-1.p6">Markus Holzer&rsquo;s solution</a> implements additive Roman numbers only, meaning 9 = <code>VIIII</code>. The short length of Markus&rsquo; solution really underscores how much more code is required to support the subtractive numbers:</p>

<pre><code class="language-raku">subset Roman of Str where * ~~ / ^ M* D* C * L* X* V* I* $ /;
my @r = :M(1000), :D(500), :C(100), :L(50), :X(10), :V(5), :I(1);
my %r = @r.Hash;
sub r2d( $r is copy ) {
    $r .= uc;
    %r{$r} || [+] $r.comb.map({  %r{$_} });
}
sub d2r( $d is copy ) {
    [~] gather while $d &gt; 0 {
         my ($k, $n) = @r.first( *.value &lt;= $d ).kv;
         take $k;
         $d -= $n;
    }
}
</code></pre>

<p>Markus also uses a <code>multi</code> main sub to parse the arithmetic operators.</p>

<pre><code class="language-raku">multi sub MAIN(Roman $n, '+', Roman $m) { say d2r( $n.&amp;r2d + $m.&amp;r2d ) }
multi sub MAIN(Roman $n, '-', Roman $m) { say d2r( $n.&amp;r2d - $m.&amp;r2d ) }
multi sub MAIN(Roman $n, &quot;×&quot;, Roman $m) { say d2r( $n.&amp;r2d × $m.&amp;r2d ) }
multi sub MAIN(Roman $n, '÷', Roman $m) { say d2r( ($n.&amp;r2d ÷ $m.&amp;r2d).Int ) }
</code></pre>

<h2 id="noud1">Noud Aldenhoven</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/noud/raku/ch-1.p6">Noud Aldenhoven&rsquo;s solution</a> defines a <code>@roman-symbols</code> array that can then be iterated over pairwise:</p>

<pre><code class="language-raku">my @roman-symbols = [
    1_000, &quot;M&quot;,
    900, &quot;CM&quot;,
    500, &quot;D&quot;,
    ...
    4, &quot;IV&quot;,
    1, &quot;I&quot;
];
sub to-roman($i) {
    for @roman-symbols -&gt; $k, $v {
        if ($i &gt;= $k) {
            return $v ~ to-roman($i - $k);
        }
    }
    return '';
}
</code></pre>

<p>The <code>%operators</code> are a dispatch table:</p>

<pre><code class="language-raku">my %operators =
    '+' =&gt; { $_[0] + $_[1] },
    '*' =&gt; { $_[0] * $_[1] },
    '-' =&gt; { $_[0] - $_[1] },
    '/' =&gt; { Int($_[0] / $_[1]) },
    '%' =&gt; { $_[0] % $_[1] },
;
</code></pre>

<p>And the <code>MAIN</code> sub is then just a single statement:</p>

<pre><code class="language-raku">sub MAIN($a, $op, $b) {
    say to-roman(%operators{$op}((from-roman($a), from-roman($b))));
}
</code></pre>

<h2 id="ruben-westerberg1">Ruben Westerberg</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ruben-westerberg/raku/ch-1.p6">Ruben Westerberg&rsquo;s solution</a> is an interesting one. The <code>romanToDecimal</code> sub is relatively standard, but <code>decimalToRoman</code> is interesting:</p>

<pre><code class="language-raku">sub decimalToRoman ($input) {
    my @digits=$input.comb;
    my @p=&lt;I X C M&gt;;
    my @h=&lt;V L D&gt;;
    my $roman= join '', do for  @digits.kv {
        my $power=@digits-$^k-1;
        #decimalToRoman($^v,@digits-$^k-1);
        my @out;
        my $base=@p[$power];
        my $half=@h[$power];
        given $^v {
            when 1..3 {
                @out.append: $base xx $_;
            }
            when 4 {
                @out.push: $base;
                @out.push: $half;
            }
            when 5 {
                @out.push: $half;
            }
            when 6..8 {
                @out.push: $half;
                @out.append: $base xx ($_- 5);
            }
            when 9 {
                @out.push: $base;
                @out.push: @p[$power+1];
            }
        }
        |@out;
    }
}
</code></pre>

<p>Ruben is using <code>.kv</code> to split the decimal number into key/value pairs, so <code>@digits - $^k - 1</code> is the power of 10. He then makes a distinction between <code>@p</code> (the powers, i.e., 1, 10, 100, and 1000), and <code>@h</code> (half of a power, i.e., 5, 50, and 500).</p>

<p>Ruben&rsquo;s main logic uses <code>given ... when</code> for the operators, and also accepts either Roman or Arabic numbers in the input, which is one of those &ldquo;why not&rdquo; features, given it is so easy to implement:</p>

<pre><code class="language-raku">sub MAIN(Str $operand1,Str $operator,Str $operand2){
    #convert to decimal
    my ($o1,$o2)=($operand1,$operand2).map({
        when /&lt;[MDCLXVI]&gt;/ {romanToDecimal($_)};
         when /\d+/ {$_};
        &quot;Not a digit or roman numeral&quot;;
    });
    my $result= do {
        given $operator {
            when &quot;+&quot; {$o1+$o2};
            when &quot;-&quot; {$o1-$o2};
            when &quot;/&quot; {Int($o1/$o2)};
            when &quot;*&quot; {$o1*$o2};
            &quot;Unknown&quot;;
        }
    };
    put decimalToRoman($result);
}
</code></pre>

<h2 id="simon-proctor1">Simon Proctor</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/simon-proctor/raku/ch-1.p6">Simon Proctor&rsquo;s solution</a> appears to be partially influenced by his Week 10 solution, but the <code>from-roman</code> sub has been significantly modified:</p>

<pre><code class="language-raku">subset RomanStr of Str where * ~~ /^ &lt;[M C D X L V I]&gt;+ $/;

sub from-roman( RomanStr $roman is copy ) {
    my %roman-map = (:1000M, :900CM, :500D, :400CD, :100C, :90XC,
                     :50L, :40XL,  :10X, :9IX, :5V, :4IV, :1I );
    my $out = 0;
    while my $match = $roman ~~ s!^ &quot;M&quot; | &quot;CM&quot; | &quot;D&quot; | &quot;CD&quot; |
                                    &quot;C&quot; | &quot;XC&quot; | &quot;L&quot; | &quot;XL&quot; |
                                    &quot;X&quot; | &quot;IX&quot; | &quot;V&quot; | &quot;IV&quot; | &quot;I&quot;
                                    !! {
        $out += %roman-map{$match};
    }
    $out;
}
</code></pre>

<p>Simon&rsquo;s used the method of defining all possible Roman numerals <em>and their valid pairs,</em> and then matching them in descending order. This is a concise and effective algorithm.</p>

<p>What is perhaps most insightful about Simon&rsquo;s solution is his handling of <code>MAIN</code>. Often with programs like this that accept commandline input, you won&rsquo;t know if you&rsquo;ll be given a single string, like <code>&quot;VII + X&quot;</code>, or whether each argument will be separated, like <code>&quot;VII&quot;, &quot;+&quot;, &quot;X&quot;</code>, so handling both is <a href="https://en.wikipedia.org/wiki/Robustness_principle">permissive</a> and often the most sensible thing to do. Here&rsquo;s Simon&rsquo;s approach:</p>

<pre><code>subset RomanStr of Str where * ~~ /^ &lt;[M C D X L V I]&gt;+ $/;
subset RomanInt of Int where 0 &lt; * &lt; 3001;
subset Operator of Str where * ~~ /^ ( &quot;*&quot; | &quot;+&quot; | &quot;-&quot; | &quot;/&quot; ) $ /;
multi sub MAIN (
    RomanStr $i, Operator $operator, RomanStr $j
) {
    say &quot;$i $operator $j = {perf-op( $operator, $i, $j )}&quot;;
}
multi sub MAIN (
    Str $compound where m!^ (&lt;[M C D X L V I]&gt;+)  &quot; &quot;? ( &quot;*&quot; | &quot;+&quot; | &quot;-&quot; | &quot;/&quot; ) &quot; &quot;? (&lt;[M C D X L V I]&gt;+) $!;
) {
    MAIN( $0.Str, $1.Str, $2.Str );
}
</code></pre>

<p>I admit to not taking advantage of Raku&rsquo;s more advanced signature features enough in my own code, so I love seeing examples like this that remind me of their potential.</p>

<h2 id="ulrich-rieke1">Ulrich Rieke</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ulrich-rieke/raku/ch-1.p6">Ulrich Rieke&rsquo;s solution</a> uses <a href="https://github.com/drforr/perl6-slang-roman"><code>Slang::Roman</code></a> for access to the <code>to-roman</code> function.</p>

<p>The <code>MAIN</code> logic uses <code>given ... when</code> to perform the arithmetic operations:</p>

<pre><code class="language-raku">sub MAIN( Str $entry ) {
    if  $entry ~~ /^^(&lt;[IVXLCM]&gt;+) \s+ (&lt;[\+\-\/\*]&gt;) \s+  (&lt;[IVXLCM]&gt;+)$$/ {
        my $first_operand = romanToArab( ~$0 ) ;
        my $second_operand = romanToArab( ~$2 ) ;
        my $result ;
        given ( ~$1 ) {
            when '+' { $result = $first_operand + $second_operand }
            when '-' { $result = $first_operand - $second_operand }
            when '/' { $result = $first_operand div $second_operand }
            when '*' { $result = $first_operand * $second_operand }
        }
        say to-roman( $result ) ;
    }
    else {
        say &quot;erroneous entry!&quot; ;
    }
}
</code></pre>

<hr />

<hr />

<h1 id="task2">Task #2 - Gapful Numbers</h1>

<p>The Gapful numbers are defined by <a href="https://oeis.org/A108343">OEIS sequence A108343</a></p>

<p>This task had us write a script to print the first 20 Gapful numbers. Gapful numbers are numbers, 100 or greater, that are divisible by the concatenation of their first and last digits. So, for example, 100 is a gapful number because 100 is divisible by 10. 102 is not, because 101 is not divisible by 12.</p>

<hr />

<p>The solutions for task #2 were all broadly similar, in that they fetch the first and last digit using features like <code>comb</code>, <code>substr</code>, or a regex, and then check for divisibility using the modulo (<code>%</code>) or divisibility (<code>%%</code>) operators.</p>

<p>Most solutions simply used a basic loop, while some created a lazy infinite sequence.</p>

<hr />

<h2 id="alicia-bielsa2">Alicia Bielsa</h2>

<p>Alicia Bielsa has been a Perl contributor to the Challenge since Week 4. <a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/alicia-bielsa/raku/ch-2.p6">Her solution</a> here is her first Raku solution submitted for the challenge!</p>

<p>The solution uses a slice of <code>$currentNumber.comb</code> to get the first (<code>0</code>) and last (<code>*-1</code>) digits. Those are concatenated together and then the modulo (<code>%</code>) operator checks for divisibility.</p>

<pre><code class="language-raku">sub MAIN () {
    my $totalGapfulNumbers = 20;
    my $totalGapfulNumbersFound = 0;
    my $currentNumber = 100;
    while ($totalGapfulNumbersFound &lt; $totalGapfulNumbers ) {
        my  ( $firstDigit, $lastDigit ) = $currentNumber.comb[0,*-1];
        my $firstLastNumber = $firstDigit~$lastDigit;
        if ($currentNumber % $firstLastNumber   == 0 ) {
                say &quot;Gapful number : $currentNumber&quot;;
                $totalGapfulNumbersFound++;
        }
        $currentNumber++;
    }
}
</code></pre>

<p>Congratulations on your first Raku submission, Alicia. I very much hope we&rsquo;ll see more.</p>

<h2 id="arne-sommer2">Arne Sommer</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/arne-sommer/raku/ch-2.p6">Arne Sommer&rsquo;s solution</a> first defines a lazy <code>$gapful</code> list, using <code>substr</code> and the <code>%%</code> divisibility operator to <code>grep</code> for gapful numbers. The following line simply takes the first 20 terms and prints them.</p>

<pre><code class="language-raku">my $gapful := (100 .. *).grep( { $_ %% ( .substr(0,1) ~ .substr(*-1,1) ) });
say &quot;First 20 Gapful numbers: { $gapful[^20].join(',') }.&quot;;
</code></pre>

<p><strong>Blog</strong> › <a href="https://raku-musings.com/roman-gap.html">The Roman Gap with Raku</a></p>

<h2 id="athanasius2">Athanasius</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/athanasius/raku/ch-2.p6">Athanasius&rsquo;s solution</a> loops and uses a combination of <code>split</code> and modulo to get the first and last digits. Athanasius also uses the modulo operator to check for divisibility:</p>

<pre><code class="language-raku">while $count &lt; TARGET {
    my UInt $div = ($num.split('', :skip-empty))[0] * 10 + $num % 10;
    if $num++ % $div == 0 {
        @gapfuls.push: $num - 1;
        ++$count;
    }
}
</code></pre>

<h2 id="colin-crain2">Colin Crain</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/colin-crain/raku/ch-2.p6">Colin Crain&rsquo;s solution</a> also defines a lazy list, but uses <code>.comb.head</code> and <code>.comb.tail</code> to get the first and last digits:</p>

<pre><code class="language-raku">my @o2 = (100..*).grep({ $_ %% (.comb.head ~ .comb.tail) });
say @o2[$_] for (0..19);
</code></pre>

<h2 id="jaldhar-h-vyas2">Jaldhar H. Vyas</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/jaldhar-h-vyas/raku/ch-2.p6">Jaldhar H. Vyas&rsquo;s solution</a> uses an intermediate <code>@digits</code> array, and then passes the first and last elements of that to <code>.join</code> before checking for divisibility with <code>%%</code>. Interestingly, the whole thing works within one <code>gather ... take</code> block:</p>

<pre><code class="language-raku">
#!/usr/bin/perl6
(gather {
    for (100 .. Inf) -&gt; $number {
        my @digits = $number.comb;
        if $number %% (@digits[0], @digits[*-1]).join(q{}) {
            take $number;
        }
    }
})[0 .. 19].join(', ').say;
</code></pre>

<h2 id="javier-luque2">Javier Luque</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/javier-luque/raku/ch-2.p6">Javier Luque&rsquo;s solution</a> uses a regex to pull out the first and last digits, and <code>%%</code> to check for divisibility:</p>

<pre><code class="language-raku">
# Test: perl6 ch-2.p6
my $n = 100;
my $p = 0;
while ($p &lt; 20) {
    $n ~~ /^(\d)\d*(\d)$/;
    my $g_divisor = $0 ~ $1;
    if ($n %% $g_divisor) {
        $p++;
        say $n ~ ' / ' ~ $g_divisor ~
            ' = ' ~ ($n / $g_divisor);
    }
    $n++;
}
</code></pre>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/10/perl-weekly-challenge-047/">047 – Perl Weekly Challenge</a></p>

<h2 id="kevin-colyer2">Kevin Colyer</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/kevin-colyer/raku/ch-2.p6">Kevin Colyer&rsquo;s solution</a> makes a lazy list using <code>substr</code> and <code>%%</code>:</p>

<pre><code class="language-raku">my @gapful = (100...Inf)
    .grep: {
        $_ %% ( $_.substr( 0, 1 ) * 10 + $_.substr( *-1, 1 ) )
    };
</code></pre>

<p>As with Arne&rsquo;s solution, printing the first 20 elements is now easy:</p>

<pre><code class="language-raku">@gapful[^20]&gt;&gt;.say;
</code></pre>

<h2 id="luca-ferrari2">Luca Ferrari</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/luca-ferrari/raku/ch-2.p6">Luca Ferrari&rsquo;s solution</a> uses a regex with named captures:</p>

<pre><code class="language-raku">my @found;
for 100 .. Inf {
    $_ ~~ / ^ $&lt;first&gt;=\d \d+ $&lt;last&gt;=\d $ /;
    my $divisor = ( $/&lt;first&gt; ~ $/&lt;last&gt; ).Int;
    @found.push: $divisor if $_ %% $divisor &amp;&amp; ! @found.grep: { $_ == $divisor };
    last if @found.elems == $limit;
}
&quot;Here it is what I found, first $limit Gapful Numbers:\n&quot;.say;
@found.sort.join( &quot;\n\t&quot; ).say;
</code></pre>

<p><strong>Blog</strong> › <a href="https://fluca1978.github.io/2020/02/10/PerlWeeklyChallenge47.html#task2">Roman Number Calculator and Gapful Numbers</a></p>

<h2 id="mark-anderson2">Mark Anderson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/mark-anderson/raku/ch-2.p6">Mark Anderson&rsquo;s solution</a> uses a regex with numbered captures:</p>

<pre><code class="language-raku">for (100 .. Inf) -&gt; $dividend {
    state $count;
    $dividend ~~ /^ (\d) \d+ (\d) $/;
    my $divisor = $0 ~ $1;
    if ($dividend %% $divisor) {
        say $dividend;
        $count++;
    }
    last if $count == 20;
}
</code></pre>

<h2 id="markus-holzer2">Markus Holzer</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/markus-holzer/raku/ch-2.p6">Markus Holzer&rsquo;s solution</a> is the most concise yet, <code>.say</code>ing the first 20 elements of a lazy sequence that uses a slice of <code>comb</code> to get the digits:</p>

<pre><code class="language-raku">.say for (100..*).grep({ $_ %% $_.comb[0,*-1].join })[^20]
</code></pre>

<h2 id="noud2">Noud Aldenhoven</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/noud/raku/ch-2.p6">Noud Aldenhoven&rsquo;s solution</a> uses a lazy sequence as well, with more explicit coercion:</p>

<pre><code class="language-raku">my @gapful = (100..Inf).grep({
    $_ % Int(Str($_).comb[0] ~ Str($_).comb[*-1]) == 0
});
@gapful[^20].say;
</code></pre>

<h2 id="ruben-westerberg2">Ruben Westerberg</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ruben-westerberg/raku/ch-2.p6">Ruben Westerberg&rsquo;s solution</a> also uses a lazy list, but with a <code>comb</code> slice:</p>

<pre><code class="language-raku">my $gapful=(100..Inf).grep({$_%% .comb[0,*-1].join.Int});
put $gapful[0..19];
</code></pre>

<h2 id="ryan-thompson2">Ryan Thompson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ryan-thompson/raku/ch-2.p6">My solution</a> uses a lazy sequence, too, but I decided to split <code>is-gapful</code> into its own sub, for maximum utility and perhaps slightly better readability:</p>

<pre><code class="language-raku">my @gapful = (100..∞).grep: &amp;is-gapful;
say @gapful[^20];
sub is-gapful( Int \n ) { n ≥ 100 and n %% n.comb[0,*-1].join }
</code></pre>

<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/02/gapful-numbers/">Gapful Numbers</a></p>

<h2 id="simon-proctor2">Simon Proctor</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/simon-proctor/raku/ch-2.p6">Simon Proctor&rsquo;s solution</a> finds the first <code>$count</code> gapful numbers in the following single statement:</p>

<pre><code class="language-raku">.say for (100..*).grep( { $^a %% $^a.comb[0,*-1].join.Int } )[^$count]
</code></pre>

<h2 id="ulrich-rieke2">Ulrich Rieke</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ulrich-rieke/raku/ch-2.p6">Ulrich Rieke&rsquo;s solution</a> also breaks <code>isGapful</code> into its own sub, and then uses a lazy sequence to print the first 20 gapful numbers:</p>

<pre><code class="language-raku">sub isGapful( Int $num is copy --&gt; Bool ) {
  my $first = $num.Str.comb.Array.shift ;
  my $last = $num.Str.comb.Array.pop ;
  my $divisor = ( $first ~ $last ).Int ;
  return $num %% $divisor ;
}
say (100, 101 ... *).grep( { isGapful( $_ ) } )[^20] ;
</code></pre>

<p><code>$first = $num.Str.comb.Array.shift</code> goes through a couple of explicit coercions in order to get the first element (and <code>$last</code> is similar). Something like <code>$first = $num.comb.tail</code> would also be semantically equivalent, here.</p>

<hr />

<hr />

<h2 id="blogs">See Also</h2>

<h3 id="blogs-this-week">Blogs this week:</h3>

<p><strong>Arne Sommer</strong> › <a href="https://raku-musings.com/roman-gap.html">The Roman Gap with Raku</a></p>

<p><strong>Dave Jacoby</strong> › <a href="https://jacoby.github.io/2020/02/12/counting-from-100-is-the-fun-part.html">Counting from 100 is the Fun Part</a></p>

<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/10/perl-weekly-challenge-047/">047 – Perl Weekly Challenge</a></p>

<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-47-roman-calculator-and-gapful-numbers.html">Roman Calculator and Gapful Numbers</a></p>

<p><strong>Luca Ferrari</strong> › <a href="https://fluca1978.github.io/2020/02/10/PerlWeeklyChallenge47.html">Roman Number Calculator and Gapful Numbers</a></p>

<p><strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/02/gapful-numbers/">Gapful Numbers</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

