<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Raku Weekly Review #048">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.66.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Raku Weekly Review #048</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Raku Weekly Review #048</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Mar 1, 2020</span>|
                        <span> Tags:
                            raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p6-review-challenge-048.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>Continues from <a href="/blog/review-challenge-047/">previous week</a>.</p>
<p>Welcome to the Raku review for Week 048 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-048/">original tasks</a> and <a href="/blog/recap-challenge-048/">recap</a> of the weekly challenge.</p>
<h2 id="getting-in-touch">Getting in Touch</h2>
<p><a href="mailto:rjt@cpan.org"><img src="http://ry.ca/misc/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="http://ry.ca/misc/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="http://ry.ca/misc/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<h3 id="task-1task1"><a href="#task1">Task 1</a></h3>
<p>[ <a href="#alicia-bielsa1">Alicia Bielsa</a>  | <a href="#arne-sommer1">Arne Sommer</a>  | <a href="#colin-crain1">Colin Crain</a>  | <a href="#jaldhar-h-vyas1">Jaldhar H. Vyas</a>  | <a href="#javier-luque1">Javier Luque</a>  | <a href="#kevin-colyer1">Kevin Colyer</a>  | <a href="#laurent-rosenfeld1">Laurent Rosenfeld</a>  | <a href="#luca-ferrari1">Luca Ferrari</a>  | <a href="#mark-anderson1">Mark Anderson</a>  | <a href="#markus-holzer1">Markus Holzer</a>  | <a href="#mohammad-anwar1">Mohammad S Anwar</a>  | <a href="#noud1">Noud Aldenhoven</a>  | <a href="#roger-bell-west1">Roger Bell West</a>  | <a href="#ruben-westerberg1">Ruben Westerberg</a>  | <a href="#ryan-thompson1">Ryan Thompson</a>  | <a href="#simon-proctor1">Simon Proctor</a>  | <a href="#xkr471">Jonas Berlin</a>  ]</p>
<h3 id="task-2task2"><a href="#task2">Task 2</a></h3>
<p>[ <a href="#alicia-bielsa2">Alicia Bielsa</a>  | <a href="#arne-sommer2">Arne Sommer</a>  | <a href="#colin-crain2">Colin Crain</a>  | <a href="#jaldhar-h-vyas2">Jaldhar H. Vyas</a>  | <a href="#javier-luque2">Javier Luque</a>  | <a href="#kevin-colyer2">Kevin Colyer</a>  | <a href="#laurent-rosenfeld2">Laurent Rosenfeld</a>  | <a href="#luca-ferrari2">Luca Ferrari</a>  | <a href="#mark-anderson2">Mark Anderson</a>  | <a href="#markus-holzer2">Markus Holzer</a>  | <a href="#mohammad-anwar2">Mohammad S Anwar</a>  | <a href="#noud2">Noud Aldenhoven</a>  | <a href="#roger-bell-west2">Roger Bell West</a>  | <a href="#ruben-westerberg2">Ruben Westerberg</a>  | <a href="#ryan-thompson2">Ryan Thompson</a>  | <a href="#simon-proctor2">Simon Proctor</a>  | <a href="#ulrich-rieke2">Ulrich Rieke</a>  | <a href="#xkr472">Jonas Berlin</a>  ]</p>
<h3 id="blogsblogs"><a href="#blogs">Blogs</a></h3>
<hr>
<hr>
<h1 id="task1">Task #1 - Survivor</h1>
<p>Here is the original task description:</p>
<p><em>There are 50 people standing in a circle in position 1 to 50. The person standing at position 1 has a sword. He kills the next person i.e. standing at position 2 and pass on the sword to the immediate next i.e. person standing at position 3. Now the person at position 3 does the same and it goes on until only one survives.</em></p>
<p><em>Write a script to find out the survivor.</em></p>
<hr>
<p>This is a classic problem in computer science otherwise known as the <a href="https://en.wikipedia.org/wiki/Josephus_problem">Josepheus problem</a>. There are several ways to tackle the problem, ranging from brute force methods all the way to the constant-time analytical solutions.</p>
<h2 id="looping-with-splice">Looping with <code>splice</code></h2>
<p>The <a href="https://docs.perl6.org/routine/splice"><code>splice</code></a> routine will remove element(s) at the given position if a <code>@replacement</code> argument is not given. Thus some solutions start with an array containing 1..50 and loop until that array has one element, using <code>splice</code> to remove the correct element.</p>
<p>Since this method requires explicit array indexing and the array changes length, it can be a bit error prone to implement, as evidenced by a couple of solutions that arrived at the wrong result. In particular, it&rsquo;s important to pay careful attention to the index wrap-around; since the sword skips one person, the index sometimes needs to be reset to 1, other times 0. Using the modulo (<code>%</code>) operator is a common trick for handling this.</p>
<h2 id="circular-linked-list">Circular linked list</h2>
<p><a href="https://en.wikipedia.org/wiki/Linked_list">Circular linked lists</a> are a very natural way to solve this problem. Raku does not have a built-in linked list type, but that&rsquo;s perhaps the fun of it: there are a few good ways to make a linked list for this problem. References work, of course, but it&rsquo;s also possible to make an O(1) linked list from a humble array of integers.</p>
<p><a href="http://www.ry.ca/2020/02/survivor-josepheus-problem/">My blog</a> has more discussion on circular linked lists and their use in this problem.</p>
<h2 id="looping-with-shiftpush">Looping with <code>shift</code>/<code>push</code></h2>
<p>A clever way to solve the problem involves storing the values 1..50 in an array, and then looping until the array has one element, with the following loop body (which also works in Perl):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    push @a, shift @a;  <span style="color:#75715e"># Rotation (&#34;Next&#34;)</span>
    shift @a;           <span style="color:#75715e"># Kill</span>
</code></pre></div><p>As to why this works, the rotation is what essentially moves the cursor along. It does not change the relative positions of each element. Then the next <code>shift</code> (kill) just removes the person at that position.</p>
<p>Here is an example for five people:</p>
<pre><code>Start              Rotation     Killed
1 2 3 4 5       -&gt; 2 3 4 5 1 -&gt; 3 4 5 1
    3 4 5 1     -&gt; 4 5 1 3   -&gt; 5 1 3
        5 1 3   -&gt; 1 3 5     -&gt; 3 5
            3 5 -&gt; 5 3       -&gt; 3 -&gt; DONE
</code></pre><h2 id="brute-force-loops">Brute force loops</h2>
<p>Yet another way to solve this challenge involves putting all of your people into an array of 1s (1 = alive, 0 = dead), and whenever you need to kill someone or pass the sword along, you simply advance the cursor until you find a 1.</p>
<p>It&rsquo;s a little inefficient, especially in the later rounds when most everyone is dead, but it certainly runs quickly enough for small problem sizes.</p>
<h2 id="alicia-bielsa1">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/alicia-bielsa/raku/ch-1.p6">Alicia Bielsa&rsquo;s solution</a> continues her foray into Raku submissions this week with the following:</p>
<pre><code class="language-raku" data-lang="raku">my $numberPeople = 50;
my $numberPeopleAlive = $numberPeople;
my @aPeople;
for 1..$numberPeople {
    my $nextPosition = $_ == $numberPeople ?? 1 !! $_ +1;
    @aPeople.push({'nextPosition' =&gt;  $nextPosition});
}
my $swordPosition  = 1;
while $numberPeopleAlive &gt; 1 {
    my $killPosition =  @aPeople[ $swordPosition-1 ]&lt;nextPosition&gt;;
    @aPeople[ $swordPosition-1 ]&lt;nextPosition&gt;  = @aPeople[ $killPosition-1 ]&lt;nextPosition&gt;;
    $swordPosition = @aPeople[ $killPosition-1 ]&lt;nextPosition&gt;;
    $numberPeopleAlive--;
}
print &quot;Last Position Alive : $swordPosition\n&quot;;
</code></pre><p>Alicia has come up with a circular linked list implementation. The explicit variable names make it easy to follow.</p>
<h2 id="arne-sommer1">Arne Sommer</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/arne-sommer/raku/ch-1.p6">Arne Sommer&rsquo;s solution</a> uses <code>splice</code>:</p>
<pre><code class="language-raku" data-lang="raku">unit sub MAIN (:$verbose);
my @people = 1 .. 50;
my $next = 1;
say &quot;: @people[] [Index: $next]&quot; if $verbose;
while @people.elems &gt; 1 {
  my $killed = @people.splice($next, 1);
  $next++;
  $next = 0 if $next &gt; @people.end;
  say &quot;: @people[] [K:$killed] [Next:$next]&quot; if $verbose;
}
say &quot;Living: @people[]&quot;;
</code></pre><p>Unfortunately, the solution returns 31, but the correct answer is 37. As seems to be typical with these <code>splice</code> implementations on both Perl and Raku, it&rsquo;s really easy to get the indexing wrong, since <code>splice</code> requires an explicit index, and also changes the length of the array.</p>
<p>Fortunately, the fix is simple: change <code>$next = 0</code> to <code>$next -= @people.elems</code>. Or, replace the <code>$next++</code> and <code>$next = 0 ...</code> lines with <code>$next = ($next + 1) % @people.elems</code>.</p>
<p><strong>Blog</strong> › <a href="https://raku-musings.com/surviving-dates.html">Surviving Dates with Raku</a></p>
<h2 id="colin-crain1">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/colin-crain/raku/ch-1.p6">Colin Crain&rsquo;s solution</a>, as with his Perl version, has some hilariously colourful commentary on the problem in an extended comment at the top, which is well worth a read. The code itself uses <code>splice</code>, deftly dodging any indexing errors with the modulo operator:</p>
<pre><code class="language-raku" data-lang="raku">sub survivor (Int:D $size where {$size &gt; 0}){
    my @circle = (0..$size-1);
    my $next = 0;
    while (  @circle.elems &gt; 1 ) {
        $next = ++$next % @circle.elems;
        @circle.splice($next, 1);
    }
    return @circle[0];
}
</code></pre><p>Colin explicitly documents his choice to use 0-based indexing, so his result of 36 instead of 37 is expected.</p>
<h2 id="jaldhar-h-vyas1">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/jaldhar-h-vyas/raku/ch-1.p6">Jaldhar H. Vyas&rsquo;s solution</a> uses a brute force method to iterate over a fixed length array:</p>
<pre><code class="language-raku" data-lang="raku">multi sub MAIN() {
    my @people = (0 .. 49);
    my $remaining = @people.elems;
    my $next = 0;
    my $victim = 1;
    while $remaining &gt; 1 {
        @people[$victim] = Nil;
        $remaining--;
        repeat {
            $next = ($next + 1) % 50;
        } until defined @people[$next];
        $victim = $next;
        repeat {
            $victim = ($victim + 1) % 50;
        } until defined @people[$victim];
    }
    say @people.grep({ defined $_; })[0] + 1;
}
</code></pre><p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/17/perl-weekly-challenge-048/">048 – Perl Weekly Challenge</a></p>
<h2 id="javier-luque1">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/javier-luque/raku/ch-1.p6">Javier Luque&rsquo;s solution</a> uses <code>push</code>/<code>shift</code> and <code>shift</code> to rotate the array and then remove the first person:</p>
<pre><code class="language-raku" data-lang="raku">sub MAIN() {
    my @people = 1..50;
    kill-and-switch(@people) while (@people.elems &gt; 1);
    say @people[0] ~&quot; is still alive&quot;;
}
# Kill and Switch
sub kill-and-switch(@people) {
    # switch
    push @people, shift @people;
    # kill
    shift @people;
}
</code></pre><p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/17/perl-weekly-challenge-048/">048 – Perl Weekly Challenge</a></p>
<h2 id="kevin-colyer1">Kevin Colyer</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/kevin-colyer/raku/ch-1.p6">Kevin Colyer&rsquo;s solution</a> uses a fixed-length array in <code>@circle</code>, and then uses a brute force method to choose the next victim:</p>
<pre><code class="language-raku" data-lang="raku"># fill the circle with 50 alive people = 1's
my @circle = 1 xx 50;
# helper function to loop around the circle looking for the next living person
sub nextAlive($i) {
    my $j=$i;
    loop {
        # choose next person
        $j++;
        # loop back if reached end of array
        $j=0 if $j&gt;= @circle.elems;
        # return index if that person is living...
        return $j if @circle[$j]==1;
        # prevent infinite loop check
        die &quot;No-one alive in circle&quot; if $i==$j;
        # and loop
    }
}
</code></pre><p>To find the ultimate survivor, a simple <code>loop</code> does the trick:</p>
<pre><code class="language-raku" data-lang="raku">my $i=0;
my $j=-1;
say &quot;1 has the sword...&quot;;
loop {
    # choose victim
    $j=nextAlive($i);
    # kill them
    @circle[$j]=0;
    say &quot;{$i+1} killed {$j+1}&quot;;
    # pass the sword on
    my $k=nextAlive($j);
    # check exit the loop if we have just passed sword to ourselves - we are the only living one left
    last if $i == $k;
    # pass the sword on
    $i=$k;
    say &quot; and gave sword to {$i+1}&quot;;
}
say &quot;So the survivor is {$i+1}&quot;;
</code></pre><h2 id="laurent-rosenfeld1">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/laurent-rosenfeld/raku/ch-1.p6">Laurent Rosenfeld&rsquo;s solution</a> uses the <code>push</code>/<code>shift</code>, <code>shift</code> technique:</p>
<pre><code class="language-raku" data-lang="raku">my $number = @*ARGS ?? @*ARGS[0] !! 50;
my $number = 50;
my @persons = 1 .. $number;
for (1.. $number - 1) {
    push @persons, shift @persons;
    shift @persons;
}
say &quot;Person @persons[] is the survivor.\n&quot;;
</code></pre><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-48-survivor-and-palindrome-dates.html">Survivor and Palindrome Dates</a></p>
<h2 id="luca-ferrari1">Luca Ferrari</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/luca-ferrari/raku/ch-1.p6">Luca Ferrari&rsquo;s solution</a> also uses a fixed-length array, and has a <code>next-alive</code> sub to find the next victim:</p>
<pre><code class="language-raku" data-lang="raku"># Implements the list rotation.
sub next-alive( @people, $current-person ) {
    my $next = $current-person;
    loop {
        $next++;
        $next = $next &gt;= @people.elems ?? $next % @people.elems !! $next;
        return $next if @people[ $next ].defined;
    }
}
</code></pre><p>The semantics of <code>@people</code> are a bit different: <code>False</code> means the person is alive but does not have the sword. <code>True</code> means the person has the sword.  <code>Nil</code> means the person is dead. The main loop iterates through and kills each person in turn:</p>
<pre><code class="language-raku" data-lang="raku">sub MAIN( Int :$how_many_people = 50 ) {
    my @people = False xx $how_many_people;
    @people[ 0 ] = True;
    while ( @people.grep( *.defined ) &gt; 1 ) {
        # find out who has the sword
        my $killer      = @people.first: *.so, :k;
        # then find out the next person to kill
        my $killed      = next-alive( @people, $killer );
        @people[ $killed ] = Nil;  # killed!
        @people[ $killer ] = False; # pass the sword
        # now get the next person that will hold the sword
        my $next-killer = next-alive( @people, $killed );
        @people[ $next-killer ] = True; # the next killer
    }
    &quot;The person who survives is { $_ + 1 }&quot;.say given @people.first: *.so, :k;
}
</code></pre><p><strong>Blog</strong> › <a href="https://fluca1978.github.io/2020/02/17/PerlWeeklyChallenge48.html#task1">Survivors and Palindrome Dates</a></p>
<h2 id="mark-anderson1">Mark Anderson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/mark-anderson/raku/ch-1.p6">Mark Anderson&rsquo;s solution</a> has a unique solution:</p>
<pre><code class="language-raku" data-lang="raku">my @people = 1 .. 50;
while @people &gt; 1 {
    my $last = @people[*-1];
    @people  = @people[@people.keys.grep(* %% 2)];
    shift @people if @people[*-1] == $last;
}
put @people;
</code></pre><p>While algorithmically, this is a brute force solution, it is rather refined: Mark has no doubt realized that every time the sword goes around the circle, it kills every other person. So he coded that explicitly, with <code>@people = @people[@people.keys.grep(* %% 2)]</code>.</p>
<h2 id="markus-holzer1">Markus Holzer</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/markus-holzer/raku/ch-1.p6">Markus Holzer&rsquo;s solution</a> shows a few different methods.</p>
<p>First, a concise solution using <code>splice</code>:</p>
<pre><code class="language-raku" data-lang="raku">given my @men = 1..50 { .push( .splice(0,2).first ) while .elems &gt; 1 };
say @men.first;
</code></pre><hr>
<p>Next, Markus had a go with a circular linked list implemenetation, and also lit up some pathways in my brain that I haven&rsquo;t used since I took that Latin class in university a long time ago:</p>
<pre><code class="language-raku" data-lang="raku">role Concatenationem { has $.vicinus is rw; }
class Moribunda is Int does Concatenationem { };
sub bicimare-sine-fine( Int $homines where * &gt; 1 ) {
    my $armis = my $primus = Moribunda.new(1);
    for 2..$homines
    {
        my $homine = Moribunda.new($_);
        $armis.vicinus = $homine;
        $armis = $homine;
    }
    $armis = $armis.vicinus = $primus;
    while $armis != $armis.vicinus
    {
        $armis = $armis.vicinus = $armis.vicinus.vicinus;
    }
    $armis;
}
say bicimare-sine-fine( 50 );
</code></pre><hr>
<p>Finally, Markus provided a solution that uses <code>rotor(2)</code> to split up the people into &ldquo;killer/victim tuples&rdquo; (obviously recognizing that every other person is killed, each time around the circle). It requires a special case for even/odd sized groups:</p>
<pre><code class="language-raku" data-lang="raku">sub rotor-kill( $n ) {
    my @men = 1..$n;
    while @men.elems &gt; 1 {
        if @men.elems %% 2 {
            # When the number of men is even, we know the very last man
            # in line will die and we can start the next round at the beginning.
            @men = @men.rotor(2).map: *.first;
        }
        else
        {
            # When the number of men is odd, the last man survives and will
            # kill the first in the next round, so we need to skip over the
            # poor fellow.
            @men = @men.rotor(2, :partial).skip.map: *.first;
        }
    }
    @men.first;
}
say rotor-kill( 50 );
</code></pre><h2 id="mohammad-anwar1">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/mohammad-anwar/raku/ch-1.p6">Mohammad S Anwar&rsquo;s solution</a> uses the <code>shift</code>/<code>push</code> technique:</p>
<pre><code class="language-raku" data-lang="raku">sub MAIN() {
    my @people = 1..50;
    while @people.elems &gt; 1 {
        my $sword = @people.shift;
        @people.shift;
        @people.push($sword);
    }
    say &quot;Survivor is at position @people[0]&quot;;
}
</code></pre><p><strong>The following comment is copied from my Perl review:</strong></p>
<p><em>I am really glad to see Mohammad not only participating in the challenge, but now blogging about his solutions as well! His first blog post (below) covers the past three weeks (Weeks 046, 047, and 048), and is a good introspective look at Mohammad&rsquo;s experience contributing solutions in Perl and his early steps in translating those solutions (and, I think, parts of his brain!) to Raku:</em></p>
<p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/my-first-date-with-raku">My first date with Raku</a></p>
<h2 id="noud1">Noud Aldenhoven</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/noud/raku/ch-1.p6">Noud Aldenhoven&rsquo;s solution</a> uses recursion, with the well-known recurrence relation <code>f(n, k) = (f(n - 1, k) + k - 1) mod n + 1.</code></p>
<pre><code class="language-raku" data-lang="raku">multi sub f(1, $k) { 1; }
multi sub f($n, $k) { (f($n - 1, $k) + $k - 1) % $n + 1; }
say &quot;Survivor: &quot;, f(50, 2);
</code></pre><p>The code comments contain a paraphrasing of <a href="https://en.wikipedia.org/wiki/Josephus_problem#The_general_case">Wikipedia</a>, which has additional background that might be of interest.</p>
<h2 id="roger-bell-west1">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/roger-bell-west/raku/ch-1.p6">Roger Bell West&rsquo;s solution</a> uses <code>splice</code>:</p>
<pre><code class="language-raku" data-lang="raku">my @list=(1..50);
my $n=0;
while (@list.elems &gt; 1) {
    $n++;
    if ($n&gt;@list.end) {
        $n=0;
    }
    splice @list,$n,1;
}
say @list[0];
</code></pre><p>As with his similar solution in Perl, Roger&rsquo;s solution here arrives at the wrong answer (31, instead of 37). This can be fixed by changing <code>$n = 0</code> to <code>$n -= @list.elems</code>, or by replacing the top two lines of the loop body with <code>$n = ($n + 1) % @list.elems</code>.</p>
<h2 id="ruben-westerberg1">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/ruben-westerberg/raku/ch-1.p6">Ruben Westerberg&rsquo;s solution</a> also uses splice, but uses modulo arithmetic to ensure the index wrap works correctly:</p>
<pre><code class="language-raku" data-lang="raku">my @sur=1..50;
my $i=0;
@sur.splice($i=($i+1)%@sur,1)  while @sur &gt; 1;
put &quot;Survivor: @sur[]&quot;;
</code></pre><h2 id="ryan-thompson1">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/ryan-thompson/raku/ch-1.p6">My solution</a> is a circular linked list implementation:</p>
<pre><code class="language-raku" data-lang="raku">my Int @ll = 0, |[1..$N].rotate;
my Int $cur = 1;
@ll[$cur] = @ll[ @ll[$cur] ] and $cur = @ll[$cur] until @ll[$cur] == $cur;
say $cur;
</code></pre><p>A linked list is a high level description of a data structure. The underlying implementation can vary, and in this case, I&rsquo;m using an array of numbers. The array <em>index</em> is the current person, and the <em>value</em> at that index is the <em>next</em> person in the linked list. I&rsquo;m using two linked list operations, here (<code>$cur</code> is the &ldquo;cursor&rdquo;, or index of the current element):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">@ll[$cur] <span style="color:#f92672">=</span> @ll[@ll[$cur]]  <span style="color:#75715e"># &#34;delete&#34; -- Delete element to the right</span>
    $cur  <span style="color:#f92672">=</span> @ll[    $cur ]  <span style="color:#75715e"># &#34;next&#34;   -- Go to next element in list</span>
</code></pre></div><p>My blog also discusses an analytic O(1) solution to the problem, if you are interested.</p>
<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/02/survivor-josepheus-problem/">Survivor (Josepheus problem)</a></p>
<h2 id="simon-proctor1">Simon Proctor</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/simon-proctor/raku/ch-1.p6">Simon Proctor&rsquo;s solution</a> has two <code>MAIN</code> methods; one using <code>splice</code>:</p>
<pre><code class="language-raku" data-lang="raku">#| Calculate the survior of the swordsmen suicide pact
multi sub MAIN(
    UInt $swords = 50, #= Number of swordsmen (default 50)
) {
    my @men = [1..$swords];
    while ( @men.elems &gt; 1 ) {
        my ( $alive, $dead ) = @men.splice(0,2);
        @men.push($alive);
    }
    say &quot;Survivor of $swords is number {@men[0]}&quot;;
}
</code></pre><p>And the other uses math:</p>
<pre><code class="language-raku" data-lang="raku"># Find p where p ** 2 &lt; s (swordsmen)
# The survior is the nth odd number where n = s - p
#| Calculate mathematically
multi sub MAIN(
    &quot;math&quot;,
    UInt $swords = 50, #= Number of swordsmen
) {
    my $low-power = (1,* * 2...*).first(* &gt; $swords) div 2;
    say &quot;Survivor of $swords is number {(1,3,5...*)[$swords - $low-power]}&quot;;
}
</code></pre><p>Simon&rsquo;s math solution still loops, to find the power of 2 less than <code>$swords</code>.  It&rsquo;s possible to do this in constant time with <code>log($swords, 2).floor</code>. I bet Simon knows this, as his blog talks about &ldquo;fun uses of Raku sequences,&rdquo; which I can absolutely relate to.</p>
<p><strong>Blog</strong> › <a href="https://dev.to/scimon/perl-weekly-challenge-week-42-2oo2">Perl Weekly Challenge : Week 48</a></p>
<h2 id="xkr471">Jonas Berlin</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/xkr47/raku/ch-1.p6">Jonas Berlin&rsquo;s solution</a> uses a custom class, extending <code>Array</code>, with a custom <code>Iterator</code>:</p>
<pre><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6
class Pwc048_1 is Array {
    method iterator {
        class :: does Iterator {
            has $.index is rw = 0;
            has $.array is required;
            method pull-one {
                my $val = $.array.AT-POS($.index++);
                $.index %= $.array.elems;
                $.array.splice($.index, 1);
                if ($.array.elems) {
                    $.index %= $.array.elems;
                    $val;
                } else {
                    IterationEnd;
                }
            }
        }.new(array =&gt; self)
    }
}
my $arr = Pwc048_1.new();
$arr.append(1...50);
say &quot;Survivors, in order: &quot;, $arr;
</code></pre><p>Internally the <code>Iterator</code> uses <code>splice</code> to remove the victims. Iterating through the array results in the following sequence:</p>
<pre><code>[1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 1 5 9 13 17 21 25 29 33 37 41 45 49 5 13 21 29 37 45 5 21 37 5 37]
</code></pre><p>I like to see solutions like this, that showcase different language features.</p>
<hr>
<hr>
<h1 id="task2">Task #2 - Palindrome Dates</h1>
<p>Write a script to print all Palindrome Dates between 2000 and 2999. The format of date is <strong>mmddyyyy</strong>. For example, the first one was on October 2, 2001 as it is represented as <code>10022001</code>.</p>
<hr>
<p>The solutions from this task can be broken into the following main categories:</p>
<h3 id="solutions-using-date">Solutions using <code>Date</code></h3>
<p>Many people used Raku&rsquo;s included <code>Date</code> class to help them iterate through and/or validate dates they obtained.</p>
<h3 id="solutions-that-did-not-use-date">Solutions that did not use <code>Date</code></h3>
<p>Others realized that, in fact, the dates meeting the specification can be validated very easily, or, if you are careful with how you set up your loops, don&rsquo;t need to be validated at all.</p>
<hr>
<h2 id="alicia-bielsa2">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/alicia-bielsa/raku/ch-2.p6">Alicia Bielsa&rsquo;s solution</a> uses the <code>Date</code> class to validate palindromic strings generated by flipping and splitting the year:</p>
<pre><code class="language-raku" data-lang="raku">for 2000..2999 {
    my $mmdd = $_.flip;
    my $date = Date.new($_,  $mmdd.substr(0,2), $mmdd.substr(2,2));
    CATCH {
        default {  }
    }
    say $mmdd ~ $_;
}
</code></pre><h2 id="arne-sommer2">Arne Sommer</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/arne-sommer/raku/ch-2.p6">Arne Sommer&rsquo;s solution</a> uses nested loops to build up candidate strings that he then validates with his own code:</p>
<pre><code class="language-raku" data-lang="raku">for 0..2 -&gt; $y2 {
  for 0..9 -&gt; $y3 {
    for 0..1 -&gt; $y4 {
      for 0..1 -&gt; $m1 {
        for 0..9 -&gt; $m2 {
          for 0..2 -&gt; $d1 {
            next unless $m1 == $y4 &amp;&amp; $m2 == $y3 &amp;&amp; $d1 == $y2;
            next if $m1 == 0 == $m2;
                next if $m1 == 1 &amp;&amp; $m2 &gt; 2;
            say $m1 ~ $m2 ~ $d1 ~ '22' ~ $y2 ~ $y3 ~ $y4;
          }
        }
      }
    }
  }
}
</code></pre><p>Due to the careful setup of the nested loops, Arne only needs to do some very basic filtering of the dates.</p>
<p><strong>Blog</strong> › <a href="https://raku-musings.com/surviving-dates.html">Surviving Dates with Raku</a></p>
<h2 id="colin-crain2">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/colin-crain/raku/ch-2.p6">Colin Crain&rsquo;s solution</a> generates candidates by looking at each year and its <code>flip</code>ped counterpart:</p>
<pre><code class="language-raku" data-lang="raku">sub MAIN () {
    ## make a list of valid candidates
    my @candidates = (2000..2999).map({$_.flip ~ $_}).grep({validate($_)});
    ## a little prettification and output
    .map({S/^(..)(..)/$0-$1-/}).put for @candidates;
}
</code></pre><p>The <code>validate</code> sub then rejects any invalid dates:</p>
<pre><code class="language-raku" data-lang="raku">sub validate ($candidate) {
## returns true is the given string represents a valid mmddyyyy date
## does not consider leap years, in this case they are logically irrelevant
    my @mlen  = 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;
    my ($m, $d ) = $candidate.comb(2);
    return      $m &gt; 12
             || $m == 0
             || $d &gt; @mlen[$m-1]
             || $d == 0             ?? 0 !! 1;
}
</code></pre><h2 id="jaldhar-h-vyas2">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/jaldhar-h-vyas/raku/ch-2.p6">Jaldhar H. Vyas&rsquo;s solution</a> uses a hard-coded list of (reversed) months and checks that against the two-digit year to get a list of valid <code>@years</code>:</p>
<pre><code class="language-raku" data-lang="raku">my @years = (2000 .. 2999).grep({
    / $&lt;year&gt; = (\d\d) $ /;
    (10, 20, 30, 40, 50, 60 , 70, 80, 90, 1, 11, 21).grep({ $_ == $/&lt;year&gt;})
});
</code></pre><p>With that, he can now <code>flip</code> the year to get the <code>$&lt;month&gt;</code> and <code>$&lt;day&gt;</code> with
a regex, and print out any dates where the day is less than 23:</p>
<pre><code class="language-raku" data-lang="raku">for @years -&gt; $year {
    $year.flip ~~ / ^ $&lt;month&gt; = (\d\d) $&lt;day&gt; = (\d\d) $ /;
    if $/&lt;day&gt; &lt; 23 {
        ($/&lt;month&gt;, $/&lt;day&gt;, $year).join(q{/}).say;
    }
}
</code></pre><h2 id="javier-luque2">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/javier-luque/raku/ch-2.p6">Javier Luque&rsquo;s solution</a> solution uses the <code>Date</code> class, and goes through every day between 2000-01-01 and 2999-12-31:</p>
<pre><code class="language-raku" data-lang="raku">sub MAIN () {
    my $current_date  = Date.new(2000, 1, 1);
    my $end_date = Date.new(2999, 12, 31);
    while ($current_date &lt; $end_date) {
        # Format month and day
        my $month = ($current_date.month &lt; 10) ??
            '0' ~ $current_date.month !!
            $current_date.month;
        my $day   = ($current_date.day &lt; 10) ??
            '0' ~ $current_date.day !!
            $current_date.day;
        # Date String
        my $date_string = $month ~ $day ~ $current_date.year;
        # Output the datestring if it's a palindrome
        say $date_string
            if ($date_string eq $date_string.flip);
        # Next Day
        $current_date = $current_date + 1;
    }
}
</code></pre><p>This returns the correct results in about 7.5 seconds on my system.</p>
<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/17/perl-weekly-challenge-048/">048 – Perl Weekly Challenge</a></p>
<h2 id="kevin-colyer2">Kevin Colyer</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/kevin-colyer/raku/ch-2.p6">Kevin Colyer&rsquo;s solution</a> uses a code ref to format the date per the specification:</p>
<pre><code class="language-raku" data-lang="raku">my $pwcformat= sub ($self) { sprintf &quot;%02d%02d%04d&quot;, .month, .day, .year given $self;};
</code></pre><p>This formatter is one of the optional arguments when creating a new <a href="https://docs.perl6.org/type/Date#(Dateish)_method_formatter"><code>Date</code></a> object:</p>
<pre><code class="language-raku" data-lang="raku">my $date=Date.new(year =&gt; 2001,month=&gt;10,day=&gt;2, formatter =&gt; $pwcformat);
my $end=Date.new(year =&gt; 3000,month=&gt;1,day=&gt;1);
</code></pre><p>Finally, Kevin simply loops over every day, printing the ones that are palindromic:</p>
<pre><code class="language-raku" data-lang="raku">while $date &lt; $end {
    my $d=$date.Str;
    say $date.yyyy-mm-dd ~ &quot; is palindrome: $d&quot; if $d eq $d.flip;
    $date.=succ;
}
</code></pre><h2 id="laurent-rosenfeld2">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/laurent-rosenfeld/raku/ch-2.p6">Laurent Rosenfeld&rsquo;s solution</a> loops over every year from 2000..2300 (see his blog, below, for the rationale for not needing to go all the way to 2999):</p>
<pre><code class="language-raku" data-lang="raku">for 2000 .. 2300 -&gt; $year {
    my ($month, $day) = ($year.flip ~~ /(\d\d)(\d\d)/)[0, 1];
    next if $month &gt; 12 or $month &lt; 1 or $day &gt; 31 or $day &lt; 1;
    say &quot;$month/$day/$year is a palindromic date.&quot;;
}
</code></pre><p>Laurent <code>flip</code>s each <code>$year</code>, and then pulls out the <code>$month</code> and <code>$day</code> with a capturing regex. He then prints every date that passes a simple validity check.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-48-survivor-and-palindrome-dates.html">Survivor and Palindrome Dates</a></p>
<h2 id="luca-ferrari2">Luca Ferrari</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/luca-ferrari/raku/ch-2.p6">Luca Ferrari&rsquo;s solution</a> iterates over the year range, <code>flip</code>s the year, and skips any dates that fail a basic validity check:</p>
<pre><code class="language-raku" data-lang="raku">sub MAIN( Int :$year-start? = 2000,
          Int :$year-end?   = 2999 ) {
    for $year-start .. $year-end {
        $_ ~~ / ^ $&lt;day&gt;=\d ** 2 $&lt;month&gt;=\d ** 2 $ /;
        my $month = $/&lt;month&gt;.flip;
        my $day   = $/&lt;day&gt;.flip;
        next if  $month &gt; 12 || $month == 0;
        next if $day &gt; 31 || $day == 0;
        &quot;Palindrome date %02d%02d%04d&quot;.sprintf( $month, $day, $_ ).say if try Date.new( :year( $_),
                                                                                    :month( $month),
                                                                                    :day( $day ) );
    }
}

</code></pre><p><strong>Blog</strong> › <a href="https://fluca1978.github.io/2020/02/17/PerlWeeklyChallenge48.html#task2">Survivors and Palindrome Dates</a></p>
<h2 id="mark-anderson2">Mark Anderson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/mark-anderson/raku/ch-2.p6">Mark Anderson&rsquo;s solution</a> is self-described as &ldquo;just brute force&rdquo;, and it lives up to that description!</p>
<p>It also uses a custom formatter:</p>
<pre><code class="language-raku" data-lang="raku">my $mdy = sub ($self) {
              sprintf &quot;%02d%02d%04d&quot;, .month, .day, .year given $self;
          }
my $dt = Date.new(
    year      =&gt; 2000,
    month     =&gt; 1,
    day       =&gt; 1,
    formatter =&gt; $mdy
);
while ($dt.year &lt; 3000) {
    my $str = sprintf &quot;%s&quot;, $dt;
    if ($str eq $str.flip) {
        printf &quot;%02d/%02d/%04d\n&quot;, .month, .day, .year given $dt;
    }
    #$dt += 1; # Formatting may be lost with this line
               # so I'm doing the below hack for now.
               # (The issue has been fixed in Rakudo Star RC-1)
    $dt = $dt.succ.clone(formatter =&gt; $mdy);
}
</code></pre><p>This solution runs in about 4.5 minutes on my system.</p>
<h2 id="markus-holzer2">Markus Holzer</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/markus-holzer/raku/ch-2.p6">Markus Holzer&rsquo;s solution</a> also uses a formatter, but iterates over each year, rather than each day:</p>
<pre><code class="language-raku" data-lang="raku">my $formatter = sub { sprintf '%02d%02d%04d', .month, .day, .year given $^date };
.say for (2000..2999)
    # filter out most of the impossible years
    .grep({
        0 &lt; .substr(2,2).flip &lt; 13 &amp;&amp;
        0 &lt; .substr(0,2).flip &lt; 32 })
    # Try making a date, this fails sometimes, eg for the year 1311 -&gt; 11311311
    # which is not a valid date. That doesn't happen for 2000 to 29999 though.
    .map({
        try Date.new($_, |.flip.comb(2), :$formatter ) })
    # So we need to filter these out
    .grep({
        .so });
</code></pre><h2 id="mohammad-anwar2">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/mohammad-anwar/raku/ch-2.p6">Mohammad S Anwar&rsquo;s solution</a> uses <code>Date</code> with a custom formatter, checking the <code>flip</code>ped version for palindromes:</p>
<pre><code class="language-raku" data-lang="raku">sub MAIN() {
    my $fmt  = { sprintf &quot;%02d%02d%04d&quot;, .month, .day, .year };
    my $date = Date.new(2000, 1, 1, formatter =&gt; $fmt);
    while $date.year &lt;= 2299 {
        my $date-as-str = $date.Str;
        if $date-as-str eq $date-as-str.flip {
            say &quot;$date-as-str is a Palindrome date.&quot;;
        }
        ++$date;
    }
}
</code></pre><p>This solution requires Rakudo Star RC-1 or newer.</p>
<p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/my-first-date-with-raku">My first date with Raku</a></p>
<h2 id="noud2">Noud Aldenhoven</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/noud/raku/ch-2.p6">Noud Aldenhoven&rsquo;s solution</a> realizes that palindromic dates within this range can be found directly, without the need to validate them at all, provided the range is carefully chosen:</p>
<pre><code class="language-raku" data-lang="raku">for 1..12 X ^3 -&gt; ($m, $d) {
    say ($m div 10), ($m % 10), $d, 2, 2, $d, ($m % 10), ($m div 10);
}
</code></pre><p>A minor issue is that this solution prints the dates out of order.</p>
<h2 id="roger-bell-west2">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/roger-bell-west/raku/ch-2.p6">Roger Bell West&rsquo;s solution</a> has a nested loop to check each year, month, and day:</p>
<pre><code class="language-raku" data-lang="raku">for 2000..2999 -&gt; $y {
  for 1..12 -&gt; $m {
    for 1..31 -&gt; $d {
      if ($d==31 &amp;&amp; ($m==4 || $m==6 || $m==9 || $m==11)) {
        next;
      } elsif ($m==2 &amp;&amp; $d==30) {
        next;
      } elsif ($m==2 &amp;&amp; $d==29 &amp;&amp; ($y % 4 != 0 || ($y % 100 == 0 &amp;&amp; $y % 400 != 0))) {
        next;
      }
      my $u=sprintf('%02d%02d%04d',$m,$d,$y);
      if ($u eq $u.flip) {
        say $u;
      }
    }
  }
}
</code></pre><p>Each candidate date is then passed through a quick validator, before it is <code>flip</code>ped and compared, to see if it is a palindrome.</p>
<h2 id="ruben-westerberg2">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/ruben-westerberg/raku/ch-2.p6">Ruben Westerberg&rsquo;s solution</a> uses <code>Date</code> with a custom formatter:</p>
<pre><code class="language-raku" data-lang="raku">my $f={sprintf &quot;%02d%02d%04d&quot;, .month,.day,.year};
put (Date.new(&quot;2000-01-01&quot;,formatter=&gt;$f)..Date.new(&quot;2999-01-01&quot;))
    .grep({my $str= .Str;$str.flip eq $str})
    .map({ &quot;Date is a palindrone: &quot;~Date.new($_)~&quot;\n&quot;}).join;
</code></pre><p>This will not work in Rakudo Star versions prior to RC-1.</p>
<h2 id="ryan-thompson2">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/ryan-thompson/raku/ch-2.p6">My solution</a> relies on a little analysis (see blog, below) to loop over only the valid palindromic dates:</p>
<pre><code class="language-raku" data-lang="raku">for (&lt;02 12 22&gt; X (1..12)».fmt('%02d')».flip.sort).flat -&gt; $dd, $yy {
    say &quot;{$yy.flip}-$dd-{$dd.flip}$yy&quot;;
}
</code></pre><p>The results are in sorted order. (Note the <code>.sort</code> you see only sorts the 12 months. It could be moved outside the loop to avoid two unnecessary calls, but it didn&rsquo;t make any measurable difference, so I left it.)</p>
<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/02/palindrome-dates/">Palindrome Dates (mm/dd/yyyy)</a></p>
<h2 id="simon-proctor2">Simon Proctor</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/simon-proctor/raku/ch-2.p6">Simon Proctor&rsquo;s solution</a> uses <code>Date</code> with a custom formatter to both validate and format the dates, before <code>.flip</code>ping them to check for palindromes:</p>
<pre><code class="language-raku" data-lang="raku">#| Find the palendromic numbers (writen mmddyyy) between 2000-01-01 and 2999-01-01
sub MAIN() {
    my sub df( Date $d) {
        # Bleh American dates
        sprintf &quot;%02d%02d%04d&quot;, .month, .day, .year given $d;
    }
    constant START = Date.new(2000,1,1,formatter =&gt; &amp;df);
    constant END = Date.new(2999,12,31, formatter =&gt; &amp;df);
    my @out;
    for (1..12) -&gt; $month {
        for (1..31) -&gt; $day {
            my $date;
            my $year = sprintf( &quot;%02d%02d&quot;, $month, $day ).flip;
            try {
                $date = Date.new($year,$month,$day,formatter =&gt; &amp;df);
            }
            next unless $date;
            next unless START &lt;= $date &lt;= END;
            @out.push($date);
        }
    }
    .say for @out.sort;
}
</code></pre><p><strong>Blog</strong> › <a href="https://dev.to/scimon/perl-weekly-challenge-week-42-2oo2">Perl Weekly Challenge : Week 48</a></p>
<h2 id="ulrich-rieke2">Ulrich Rieke</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/ulrich-rieke/raku/ch-2.p6">Ulrich Rieke&rsquo;s solution</a> uses <code>Date</code> as well, iterating one day at a time with a capturing regexp to pull out the date parts for reordering into mm/dd/yyyy format. He then checks for a palindrome with <code>.flip</code>:</p>
<pre><code class="language-raku" data-lang="raku">my $currentDate = Date.new( 1999 , 12 , 31 ) ;
my $reordered ;
my @palindromedates ;
repeat {
  $currentDate += 1 ;
  my $datestr = $currentDate.Str ;
  $datestr ~~ /(\d ** 4) '-' (\d+ ) '-' (\d+)/ ;
  $reordered = ~$2 ~ ~$1 ~ ~$0 ;
  if ( $reordered eq $reordered.flip ) {
      @palindromedates.push( $reordered ) ;
  }
} until ( $currentDate.year == 2999 &amp;&amp; $currentDate.month == 12 &amp;&amp;
      $currentDate.day == 31 ) ;
.say for @palindromedates ;
</code></pre><h2 id="xkr472">Jonas Berlin</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-048/xkr47/raku/ch-2.p6">Jonas Berlin&rsquo;s solution</a> uses <code>Date</code> in a <code>try { ... }</code> block to validate dates he generates by <code>flip</code>ping and <code>match</code>ing each year and pulling out the <code>mm</code> and <code>dd</code> parts, to reduce the search space by a factor of 365:</p>
<pre><code class="language-raku" data-lang="raku">(2000...2999)
        .map({
            try {
                    Date.new(($_, $_.flip.match(/^(..)(..)/).map(*.Str)).flat.join(&quot;-&quot;))
            }
        })
        .grep(*.defined)
        .map({ sprintf &quot;%02d%02d%04d&quot;, .month, .day, .year })
        .say
</code></pre><hr>
<hr>
<h2 id="blogs">See Also</h2>
<h3 id="raku-blogs-this-week">Raku Blogs this week:</h3>
<p><strong>Arne Sommer</strong> › <a href="https://raku-musings.com/surviving-dates.html">Surviving Dates with Raku</a></p>
<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/17/perl-weekly-challenge-048/">048 – Perl Weekly Challenge</a></p>
<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-48-survivor-and-palindrome-dates.html">Survivor and Palindrome Dates</a></p>
<p><strong>Luca Ferrari</strong> › <a href="https://fluca1978.github.io/2020/02/17/PerlWeeklyChallenge48.html">Survivors and Palindrome Dates</a></p>
<p><strong>Mohammad S Anwar</strong> › <a href="https://perlweeklychallenge.org/blog/my-first-date-with-raku">My first date with Raku</a></p>
<p><strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/02/survivor-josepheus-problem/">Survivor (Josepheus problem)</a> | <a href="http://www.ry.ca/2020/02/palindrome-dates/">Palindrome Dates (mm/dd/yyyy)</a></p>
<p><strong>Simon Proctor</strong> › <a href="https://dev.to/scimon/perl-weekly-challenge-week-42-2oo2">Perl Weekly Challenge : Week 48</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

