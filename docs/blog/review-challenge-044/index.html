<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Perl Weekly Review: Challenge - #044">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.55.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Perl Weekly Review: Challenge - 044</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Perl Weekly Review: Challenge - 044</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Jan 26, 2020</span>|
                        <span> Tags:
                            Perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p5-review-challenge-044.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    

<p>Continues from <a href="/blog/review-challenge-043/">previous week</a>.</p>

<p>Feel free to <a href="https://github.com/manwar/perlweeklychallenge">submit a merge request or open a ticket</a> if you found any issues with this post. We highly appreciate and welcome your feedback. You can also <a href="http://ry.ca/contact">contact me (Ryan) directly</a>, with any feedback on this review.</p>

<p>For a quick overview, go through the <a href="/blog/perl-weekly-challenge-044/">original tasks</a> and <a href="/blog/recap-challenge-044/">recap</a> of the weekly challenge.</p>

<p>Additional feedback to our Perl Weekly Challenge’s <a href="https://twitter.com/perlwchallenge?lang=en">Twitter account</a> is much appreciated.</p>

<h1 id="task-1-only-100-please">Task #1 - Only 100, Please!</h1>

<p><em>You are given a string “123456789”. Write a script that would insert ”+” or ”-” in between digits so that when you evaluate, the result should be 100.</em></p>

<p>There are either eleven or twelve possible expressions that equal 100:</p>

<pre><code>100 == +1+2+3-4+5+6+78+9    100 == +12+3-4+5+67+8+9
100 == +1+2+34-5+67-8+9     100 == +12-3-4+5-6+7+89
100 == +1+23-4+5+6+78-9     100 == +123+4-5+67-89
100 == +1+23-4+56+7+8+9     100 == +123-4-5-6-7+8-9
100 == -1+2-3+4+5+6+78+9    100 == +123+45-67+8-9
100 == +12+3+4+5-6-7+89     100 == +123-45-67+89
</code></pre>

<p>The description says, &ldquo;in between digits,&rdquo; though, so the canonical answer is probably eleven expressions. A few people (including me) probably knew this but opted to allow a leading negative anyway.</p>

<p>Some other solutions chose to allow for more operators than just + or -. This greatly expands the search space, but produces some interesting results.</p>

<p>Without further ado, here are the submissions:</p>

<h2 id="adam-russell">Adam Russell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/adam-russell/perl/ch-1.pl">Adam&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/AI::Genetic">AI::Genetic</a> to solve this problem with, yes, you read that right: a genetic algorithm (GA). <code>AI::Genetic</code> is pure-perl with no non-core dependencies, so if you are looking for a way to dip your toe into GAs, this might be a place to start.</p>

<p>Here&rsquo;s a look at Adam&rsquo;s fitness function:</p>

<pre><code class="language-perl">sub fitness{
    my($genes) = @_;
    my $s = NUMBERS;
    my $total = 0;
    my @operands = ($total);
    for my $gene (@{$genes}){
        if(my($i) = $gene-&gt;() =~ m/get_([1-4])/){
            return (-1 * NUMBERS) if(@operands == 2);
            return (-1 * NUMBERS) if(length($s) &lt; $i);
            push @operands, $gene-&gt;($s);
            $s = substr($s, $i);
        }
        if($gene-&gt;() =~ m/add/){
            return (-1 * NUMBERS) if(@operands != 2);
            $total = add(@operands);
            @operands = ($total);
        }
        if($gene-&gt;() =~ m/subtract/){
            return (-1 * NUMBERS) if(@operands != 2);
            $total = subtract(@operands);
            @operands = ($total);
        }
    }
    return 100 - $total if $total &gt; 100;
    return $total - 100;
}
</code></pre>

<p><a href="https://en.wikipedia.org/wiki/Genetic_algorithm">Genetic algorithms</a> are a very large topic inside the even larger topic of artificial intelligence, but essentially, this <code>fitness()</code> function returns a number based on how close the expression comes to the target value, 100. The higher the value <code>fitness()</code> returns, the more likely it is to reproduce and pass on some of its properties (genes).</p>

<p>Thus, without needing to come up with any problem-specific algorithm, Adam&rsquo;s GA code will slowly, over many generations, inch its way toward a solution. By &ldquo;slowly,&rdquo; I mean it took 45 seconds and 1,050,000 total individuals considered, to find one solution. It&rsquo;s certainly an interesting way to solve this particular problem! I like Adam&rsquo;s outside-the-box thinking on this one (and challenge #2).</p>

<p><strong>Adam&rsquo;s Blog</strong> › <a href="https://adamcrussell.livejournal.com/15036.html">Evolving more code with AI::Genetic</a></p>

<h2 id="alicia-bielsa">Alicia Bielsa</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/alicia-bielsa/perl/ch-1.pl">Alicia&rsquo;s solution</a> takes a constructive approach, iteratively adding to an <code>@aResults</code> array containing numbers and operators (+ or -). Once that is done, she loops through again to calculate the result and print it, if it equals 100:</p>

<pre><code class="language-perl">foreach my $matchIndex ( 0..$#aMatches ){
    my $match = $aMatches[$matchIndex];
    if ($match eq '+'){
        $previousFlagSum = $currentFlagSum;
        $currentFlagSum = 1;
    } elsif ($match eq '-'){
       $previousFlagSum = $currentFlagSum;
        $currentFlagSum = 0;
    } else {
        $currentNumber .= $match ;
        unless ($matchIndex == $#aMatches ){
            next;
        }
    }
    $previousNumber = $currentNumber ;
    $currentNumber = 0;

    next unless (defined $previousFlagSum );
    if ( $previousFlagSum  ){
        $total += $previousNumber;
    } else {
        $total -= $previousNumber;
    }
</code></pre>

<h2 id="andrezgz">Andrezgz</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/andrezgz/perl/ch-1.pl">Andrezgz&rsquo;s solution</a> searches all 3⁸ possible ways to insert +, -, or the empty string between each digit, in a unique way:</p>

<pre><code class="language-perl">my @digits = split //, '123456789';
my $initial = shift @digits;
my @values = ( '' , ' + ' , ' - ' );

foreach my $n (0 .. (3**8)-1) {
    my $equation = $initial;
    my @combination = split //, sprintf &quot;%08d&quot;, to_base3($n);
    $equation .= $values[ $combination[$_] ] . $digits[$_] for (0 .. @digits - 1);
    print &quot;$equation\n&quot; if (eval $equation == 100);
}
</code></pre>

<p>Note that <code>@combination</code> is a base 3 number, and the <code>$equation</code> is built up by inserting a value from <code>@digits = ('', '+', '-')</code>:</p>

<p>It&rsquo;s a clever way to think about the problem.</p>

<h2 id="cheok-yin-fung">Cheok-Yin Fung</h2>

<p><strong>New member</strong> <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/cheok-yin-fung/perl/ch-1.pl">Cheok-Yin Fung&rsquo;s solution</a> uses a variant of the base-3 method, using some interesting modulo arithmetic to set each &ldquo;digit&rdquo;:</p>

<pre><code class="language-perl">my @poweroft = (6561,2187, 729, 243, 81, 27, 9, 3, 1);
for my $i (1..6560) {
    my @ooo = (0,0,0,0,0,0,0,0);    # 0 -&gt; conjuction , 1 -&gt; plus , 2 -&gt; minus
    for my $j (0..7) {
        $ooo[$j] = int($i % $poweroft[$j]) / int($poweroft[$j+1]) ;
    }
    ...
}
</code></pre>

<p>The <code>int($i % $poweroft[$j]) / int($poweroft[$j+1])</code> expression ensures that each digit of <code>@ooo</code> will be in the range 0..2. Then, Cheok-Yin Fung assembles the result, conjoining objects when necessary:</p>

<pre><code class="language-perl">    my @objects = (1,0,0,0,0,0,0,0,0);
    my $objectindex = 0;
    for my $j (0..7) {
        if ($ooo[$j] == 0) {
            $objects[$objectindex] = $objects[$objectindex]*10 + $digits[$j+1];
        } else {$objectindex++; $objects[$objectindex] = $digits[$j+1];}
    }

    my $result = $objects[0];
    $objectindex = 0;

    for my $j (0..7) {
        if ($ooo[$j] == 1) {$objectindex++; $result += $objects[$objectindex]; }
        if ($ooo[$j] == 2) {$objectindex++; $result -= $objects[$objectindex]; }
    }
</code></pre>

<p>From here, they need only check if <code>$result == 100</code> and print out the expression if so. The program finds all solutions.</p>

<p>Please join me in welcoming <strong>Cheok-Yin Fung</strong> to our team! If this week is any indication, they are sure to send some interesting solutions going forward.</p>

<h2 id="colin-crain">Colin Crain</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/colin-crain/perl/ch-1.pl">Colin&rsquo;s solution</a> builds up the expressions in a novel way:</p>

<pre><code class="language-perl">my @list = ( 1..9 );
my @equations = shift @list;
my $idx = 0;

for my $new ( @list ){
    while (my $target = splice @equations, $idx, 1){
        for (' + ', ' - ', ''){
            splice @equations, $idx, 0, $target . $_ . $new;
            $idx++;
        }
    }
    $idx = 0;
}
</code></pre>

<p>The top-level loop <code>$new</code> essentially adds new digits to the expression. The middle <code>while</code> loop removes the <code>$idx</code>-th equation from <code>@equation</code>, and the inner <code>for</code> loop replaces that with three more equations, for each of the three operations: addition, subtraction, and concatenation.</p>

<p>After this loop, <code>@equations</code> contains all 3⁸ = 6,561 possible equations, and from there it is a simple matter of <code>eval</code>-ing each one and printing out the ones that equal 100.</p>

<h2 id="daniel-mantovani">Daniel Mantovani</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/daniel-mantovani/perl/ch-1.pl">Daniel&rsquo;s solution</a> does something very similar to Andrezgz&rsquo;s. His version of the <code>to_base3()</code> sub is named <code>ter()</code>, which returns a list of digits:</p>

<pre><code class="language-perl">sub ter {
  my @m;
  my $n = shift;
  while ($n) {
    push @m, $n % 3;
    $n = int($n/3);
  }
  return @m;
}
</code></pre>

<p>The core logic is the <code>modify_string()</code> function:</p>

<pre><code class="language-perl">sub modify_string {
    my ($in, $mod) = @_;
    my @mods = ter($mod);
    # if @m vector has more than needed elements, return undef
    return undef if length($in) &lt; @mods + 1;
    my $result = '';
    for my $d (split '', $in) {
        # undefs at the end mean empty inter-digit appends
        my $m = (shift @mods) // 0;
        # just peek what to insert according to $m
        $result .= $d . ('', ' + ', ' - ')[$m];
    }
    return $result;
}
</code></pre>

<p>Daniel&rsquo;s extensive internal documentation reads very much like a blog, so his solution is worth a look if you would like to know more.</p>

<h2 id="darren-bottin">Darren Bottin</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/darren-bottin/perl/ch-1.pl">Darren&rsquo;s solution</a> is another that considers a leading negative sign to be acceptable, and thus produces twelve solutions.</p>

<p>Darren iterates over combinations using a <code>@combination</code> array that counts up in base-3, where each element maps to <code>@symbols</code>, to get the various groupings of characters, as well as handle the addition and subtraction:</p>

<pre><code class="language-perl">my @symbols =( &quot;,&quot;, '', &quot;,-&quot;); # Split, Join, Negate
my @combination = ( 1,(0) x 8); # Skip over the join option for the first digit
my $solutions_found=0;
while(1) {
    my $blend='';
    for my $blend_dig (0..8) {
        $blend .= $symbols[$combination[$blend_dig]].$numarray[$blend_dig];
    }
    ...
}
</code></pre>

<p>The <code>@symbols</code> correspond to:
  * <code>$symbols[0]</code> › Split here, numbers will be added.
  * <code>$symbols[1]</code> › Do not split here.
  * <code>$symbols[2]</code> › Split here, second number will be subtracted.</p>

<p>The <code>next_combination()</code> sub demonstrates how to write your own incrementer:</p>

<pre><code class="language-perl">sub next_combination() {
    # warn &quot;NEXT COMB&quot;;
    my $digit =8;
    my $dval = $combination[$digit]++;
    while ( $digit&gt;=0 and $dval &gt;= 2 ) { # carry left
        $combination[$digit]=0;
        $digit--;
        $dval = $combination[$digit]++;
    }
    return $digit;
}
</code></pre>

<h3 id="prolog">Prolog</h3>

<p>Darren also submitted a second <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/darren-bottin/prolog/ch-1.pro">solution in Prolog</a>, shown here in part:</p>

<pre><code class="language-prolog">perm_sum( X, [X],  ['+',X]). % Running total, Item, Backtrace
perm_sum(-X, [X],  ['-',X]).
perm_sum(XS, [X|L],['+',X|BT]) :-  perm_sum(LS,L,BT), XS is LS+X.
perm_sum(XS, [X|L],['-',X|BT]) :-  perm_sum(LS,L,BT), XS is LS-X.
bond_comb([],X,X).
bond_comb([X|XL],Y,[X|Z]) :- bond_comb(XL,Y,Z).  % single
bond_comb([X1,X2|XL],Y,Z) :- X12 is X1*10 + X2,
    bond_comb([X12|XL],Y,Z).         % combine digits
</code></pre>

<p>Darren considers a leading - to be allowed, so his script outputs twelve cases. The <code>perm_sum</code> and <code>bond_comb</code> clauses are what do most of the work. Clauses for both <code>+</code> and <code>-</code> ensure that the implicit recursion will branch for both values. Similarly, the <code>bond_comb</code> clauses handle the combining of digits into larger numbers, or not.</p>

<h2 id="dave-jacoby">Dave Jacoby</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/dave-jacoby/perl/ch-1.pl">Dave&rsquo;s solution</a> is implemented with a 9-nested loop, which considers every permutation of splits and operators. He uses string <code>eval</code> to obtain the result of each expression. I will omit some of the middle loops, here:</p>

<pre><code class="language-perl">my @vals = ('',' + ',' - ');
for my $i (@vals) {
    for my $j (@vals) {
        for my $k (@vals)
            ...
                for my $q (@vals) {
                    my $string = join '','1',$i,'2',$j,'3',$l,'4',$m,'5',$n,'6',$o,'7',$p,'8',$q,'9';
                    my $resp = eval $string;
                    next unless $resp == 100;
                    say qq{$resp = $string};
                }
            ...
        }
    }
}
</code></pre>

<p>Each loop variable <code>$i</code> .. <code>$q</code> will be one of <code>@vals</code>, to either join, add, or subtract.</p>

<p>There&rsquo;s a funny little bug: Dave&rsquo;s script actually outputs each correct solution three times. Can you spot why? Hint (<a href="https://rot13.com/">ROT13</a>): gur svk jbhyq znxr gur cebtenz zber rssvpvrag. Answer: x vf abg hfrq.</p>

<h2 id="dave-jacoby-2">Dave Jacoby #2</h2>

<p>Dave submitted a <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/dave-jacoby/perl/ch-1a.pl">second, revised solution</a>, which I found worthy of highlighting on its own. Here, Dave uses recursion to perform a search of all possible expressions:</p>

<pre><code class="language-perl">my $vals-&gt;@* = ( ' + ', ' - ', '' );
my $source-&gt;@* = ( 1, '', 2, '', 3, '', 4, '', 5, '', 6, '', 7, '', 8, '', 9 );

sub challenge ( $source, $vals, $index ) {
    # check to see if this is correct
    if ( $index &gt;= scalar $source-&gt;@* ) {
        my $string = join '', $source-&gt;@*;
        my $result = eval $string;
        say qq{  $result = $string } if $result == 100;
        return;
    }

    # recursively add to the array
    my $next-&gt;@* = map { $_ } $source-&gt;@*;
    for my $v ( $vals-&gt;@* ) {
        $next-&gt;[$index] = $v;
        challenge( $next, $vals, $index + 2 );
    }
    return;
}
</code></pre>

<h2 id="duane-powell">Duane Powell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/duane-powell/perl/ch-1.pl">Duane&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Math::BaseCalc">Math::BaseCalc</a> to convert numbers between bases, and by now I bet you can guess why.</p>

<p>Duane iterates from 0..3⁸-1, converting that to a base-3 number, which he then uses to interleave operators (or the empty string) between each digit. Actually, his code is easily configurable to use different operators, and different target sum and input number, so these are just the defaults.</p>

<pre><code class="language-perl">my %operator = (
    0 =&gt; '',
    1 =&gt; '+',
    2 =&gt; '-',
);

my $comb = 3 ** ((scalar @n) -1);  # 6561 combinations for 123456789
my $calc = new Math::BaseCalc(digits =&gt; [0,1,2]);
foreach (0 .. $comb-1) { # zero indexed
    my @op = split(//,sprintf &quot;%08d&quot;, $calc-&gt;to_base($_));
    my $e;
    # zipper together the two arrays (@n and @op) building str $e, for example 1+2+3+4+5+6+7+8+9
    foreach my $n (@n) {
        if (scalar @op) {
            my $op = pop @op;
            $e .= $n . $operator{$op};
        }
        else {
            $e .= $n;
        }
    }
    my $s = eval $e;
    say &quot;$e = $sum&quot; if ( $s == $sum );
}
</code></pre>

<h2 id="duncan-c-white">Duncan C. White</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/duncan-c-white/perl/ch-1.pl">Duncan&rsquo;s solution</a> is recursive, too. He uses <a href="https://metacpan.org/pod/Function::Parameters">Function::Parameters</a> instead of the <a href="https://perldoc.perl.org/feature.html#The-'signatures'-feature">experimental <code>signatures</code> feature</a>, but they both produce very similar looking code:</p>

<pre><code class="language-perl">fun mutate( $str, $ip, $nleft, $goal )
{
    foreach my $a (@ch) # @ch = ('', '+', '-')
    {
        my $s2 = $str;
        substr( $s2, $ip, 0, $a );
        my $ip2 = $ip+1+length($a);
        if( $nleft&gt;1 )
        {
            mutate( $s2, $ip2, $nleft-1, $goal );
        }
        if( $nleft==1 )
        {
            my $n = eval $s2;
            say &quot;FOUND $s2&quot; if $n==$goal;
        }
    }
}
</code></pre>

<p>Here, <code>$ip</code> is short for &ldquo;insertion point&rdquo;. The <code>mutate()</code> function inserts an operator at each possible position, in every possible permutation.</p>

<h2 id="e-choroba">E. Choroba</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/e-choroba/perl/ch-1.pl">Choroba&rsquo;s solution</a> this week combines a few short subroutines. The top-level <code>while (1) { ... }</code> loop sums up the intention nicely:</p>

<pre><code class="language-perl">while (1) {
    my $expression = apply(\@mask);
    say $expression if 100 == evaluate($expression);
    last unless grep $_ != MINUS, @mask;
    increment(\@mask);
}
</code></pre>

<p><code>@mask</code> corresponds to the base-3 number we&rsquo;ve seen in other solutions. The <code>increment()</code> sub, which computes the next <code>@mask</code>, is particularly elegant:</p>

<pre><code class="language-perl">sub increment {
    my ($mask) = @_;
    my $i = $#$mask;
    $mask-&gt;[$i--] = NOTHING while $mask-&gt;[$i] == MINUS;
    ++$mask-&gt;[$i];
}
</code></pre>

<p>The <code>apply()</code> sub then takes that <code>@mask</code> and interleaves the operators with the digits accordingly:</p>

<pre><code class="language-perl">sub apply {
    my ($mask) = @_;
    return $digits[0]
        . join &quot;&quot;,
          map $op{ $mask-&gt;[$_-1] } . $digits[$_],
          1 .. $#digits
}
</code></pre>

<p>And finally <code>evaluate()</code> uses a regex to split the expression into its terms and then simply sums them up:</p>

<pre><code class="language-perl">sub evaluate {
    my ($expression) = @_;
    my @terms = $expression =~ /[-+]?[0-9]+/g;
    return sum(@terms)
}
</code></pre>

<p><strong>Choroba&rsquo;s Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/01/perl-weekly-challenge-044-one-hundred-two-hundred.html">One Hundred, Two Hundred</a></p>

<h2 id="fabrizio-poggi">Fabrizio Poggi</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/fabrizio-poggi/perl/ch-2.pl">Fabrizio&rsquo;s solution</a> seems to be a <a href="https://en.wikipedia.org/wiki/Stochastic_optimization">stochastic algorithm</a>, iterating randomly to hopefully find a solution sooner. The following generates a random symbol:</p>

<pre><code class="language-perl">sub ex {
    my $sign = int(rand(3));
    if($sign == 0) {
        my $sym = &quot;+&quot;;
        return $sym;
    } else {
        if ($sign == 1) {
            my $sym = &quot;-&quot;;
            return $sym;
        } else {
            if ($sign == 2) {
                my $sym = &quot;&quot;;
                return $sym;
            }
        }
    }
}
</code></pre>

<p>I might have replaced the above with something like <code>sub ex { ('', '-', '+')[rand 3] }</code>, but the above works just as well.</p>

<p>Fabrizio then loops until a random expression equals 100:</p>

<pre><code class="language-perl">while (1) {
    $sum = 1 . ex() . 2 . ex() . 3 . ex() . 4 . ex() . 5
             . ex() . 6 . ex() . 7 . ex() . 8 . ex() . 9;
    $val = eval ($sum);
    last if ($val == 100);
}
</code></pre>

<p>I love stochastic algorithms. Under the right circumstances, they can move an intractable problem right off the critical execution path. They can give you better best- and average-case performance. The tradeoff, though, is that the worst-case performance is unbounded, due to the loss of determinism.</p>

<p>To illustrate this, I ran Fabrizio&rsquo;s code 10,000 times. The average case took 600 iterations, the minimum took just a <em>single</em> lucky iteration, while the worst case was 7,353.</p>

<h2 id="javier-luque">Javier Luque</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/javier-luque/perl/ch-1.pl">Javier&rsquo;s solution</a> is recursive:</p>

<pre><code class="language-perl">sub check_numbers {
    my ($n, $nums, $goal) = @_;

    if ($nums) {
        my ($n2, $new_numbers) = split('', $nums, 2);
        check_numbers($n . '+' . $n2, $new_numbers, $goal);
        check_numbers($n . '-' . $n2, $new_numbers, $goal);
        check_numbers($n . $n2, $new_numbers, $goal);
    } else {
        my $total = eval $n;
        say $n if ($total == $goal)
    }
}
</code></pre>

<p><code>$nums</code> is the string containing the remaining digits. Javier uses <code>split</code> with a limit (3rd argument) to partition <code>$nums</code> into <code>$n2</code> and <code>$new_numbers</code>. Thus, he is paring off one digit at a time, and then recursing once for each operation: addition, subtraction, and concatenation.</p>

<p>When <code>$nums</code> is empty (boolean false), the base case is triggered, and a simple check of whether <code>eval $n</code> is equal to the <code>$goal</code> amount determines whether the equation is printed or not.</p>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/01/21/perl-weekly-challenge-044/">Perl Weekly Challenge – 044</a></p>

<h2 id="laurent-rosenfeld">Laurent Rosenfeld</h2>

<p>Laurent submitted four solutions to challenge #1 this week, covering two fundamentally different approaches. I will look at the &ldquo;final forms&rdquo; of each:</p>

<h3 id="recursive">Recursive</h3>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/laurent-rosenfeld/perl/ch-1a.pl">Laurent&rsquo;s 1a solution</a> is defined recursively, building up expressions by <code>chop</code>ping off the last digit and recursing on each possible operation: addition, subtraction, or concatenation:</p>

<pre><code class="language-perl">sub combine {
    my ($combined, $source) = @_;
    if ($source eq &quot;&quot;) {
        say $combined if eval $combined == 100;
        return;
    }
    my $operand = chop $source;
    for my $op ('+', '-', '') {
        combine (&quot;$combined$op$operand&quot;, $source);
    }
}
my $source = reverse &quot;123456789&quot;;
my $combined = chop $source;
combine ($combined, $source);
</code></pre>

<h3 id="glob">Glob</h3>

<p>Laurent then had the insight that he could solve this problem with <code>glob</code>. <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/laurent-rosenfeld/perl/ch-1c.sh">His 1c solution</a> is an impressive one-liner:</p>

<pre><code class="language-perl">say for grep { 100 == eval } glob join &quot;{+,-,}&quot;, 1..9;
</code></pre>

<p>Notice that the <code>join</code> inserts the string <code>{+,-,}</code> between each digit, so <code>glob</code> can then generate all 3⁸ expressions. That&rsquo;s all there is to see. After that, it&rsquo;s a trivial matter of printing the expressions that <code>eval</code> to 100. I&rsquo;m a huge fan of this solution.</p>

<p><strong>Laurent&rsquo;s Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/01/perl-weekly-challenge-44-only-100-please-and-make-it-200.html">Only 100, Please and Make it 200</a></p>

<h2 id="peter-scott">Peter Scott</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/peter-scott/perl/ch-1.pl">Peter&rsquo;s solution</a> is another that iterates through all base-3 numbers and maps those to operators. Where Peter&rsquo;s solution differs, is in his use of <a href="https://metacpan.org/pod/List::MoreUtils">List::MoreUtils</a>&rsquo; <code>mesh()</code>:</p>

<pre><code class="language-perl">while ( 1 )
{
  my @ops = ternary( $n );
  my @interleave = ( map { $operators[$_] } @ops, 0 ); # Mesh wants same sizes
  my @formula = mesh @digits, @interleave;
  my $expr = join '', @formula;
  my $res = eval $expr;
  say &quot;$expr = $res&quot; and exit if $res == 100;
  $n++;
}
</code></pre>

<p>While Peter&rsquo;s code exits after finding the first solution, it will output all eleven if one simply removes the <code>and exit</code> from the penultimate line in the above block.</p>

<p><code>mesh</code> helps Peter produce some clean, easily understood code. I like it.</p>

<h2 id="roger-bell-west">Roger Bell West</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/roger-bell-west/perl/ch-1.pl">Roger&rsquo;s solution</a> is another that iterates in base-3, in the <code>@si</code> array in this case:</p>

<pre><code class="language-perl">my @base=(1..9);
my @sv=('','-','+');
my $maxdepth=8;
my @si=(0) x $maxdepth;
while (1) {
  my $str=join('',map {$base[$_].$sv[$si[$_]]} (0..$maxdepth-1)).$base[$maxdepth];
  my $tot=eval($str);
  if ($tot == 100) {
    print &quot;$str\n&quot;;
  }
  my $i=0;
  while ($i &lt; $maxdepth) {
    $si[$i]++;
    if ($si[$i] &lt;= $#sv) {
      last;
    }
    $si[$i]=0;
    $i++;
  }
  if ($i &gt;= $maxdepth) {
    last;
  }
}
</code></pre>

<p>Roger&rsquo;s code is easily understood. The <code>while</code> loop does everything. The expression is composed by pairing a digit with an operator (<code>@sv</code>), and incrementing in base-3 to set up the next iteration.</p>

<h2 id="ruben-westerberg">Ruben Westerberg</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/ruben-westerberg/perl/ch-1.pl">Ruben&rsquo;s solution</a> is still another take on base-3 iteration, with his own <code>baseToDec()</code> and <code>decToBase()</code> subs, which he was able to re-use from last week&rsquo;s challenge. Here is his main loop:</p>

<pre><code class="language-perl">while ($i&lt;$limit) {
    my $num=sprintf &quot;%08s0&quot;,decToBase(3,$i++);
    my @ops=map {tr/120/+-/d;$_}  split &quot;&quot;,$num;
    my $exp= join &quot;&quot;,map {$digits[$_],$ops[$_]} 0..8;
    my $sum=eval $exp;
    print &quot;sum: $sum from: $exp\n&quot; if $sum==100;
}
</code></pre>

<p>I like the use of <code>tr//d</code> to replace the base-3 numbers with their corresponding operators. Ruben uses string <code>eval</code> to get the result, which is safe, because the
string is entirely composed by his program, and could be proven to be safe if so desired.</p>

<h2 id="ryan-thompson">Ryan Thompson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/ryan-thompson/perl/ch-1.pl">My solution</a> is recursive, but divides up the recursive step a little differently:</p>

<pre><code class="language-perl">sub sum_split {
    my %o = @_;

    if (0 == length $o{num}) {
        my $sum = eval $o{exp} // return;
        say &quot;$sum == $o{exp}&quot; if $sum == $o{sum};
        return
    }

    # Partition $num and recurse
    for (1..length $o{num}) {
        my ($l, $r) = unpack &quot;A$_ A*&quot;, $o{num};
        my @cur_ops = length($o{exp}) &gt; 0 ? @ops : @prefix_ops;
        sum_split(%o, num =&gt; $r, exp =&gt; &quot;$o{exp}$_$l&quot;) for @cur_ops;
    }
}
</code></pre>

<p>Instead of essentially writing a base-3 counter as many did, my recursion step recurses on every 2-partition of the remaining string, using <code>unpack</code>. For example, 123 =&gt; (1:23, 12:3, 123:). From there, I then insert every operator. The base case uses string <code>eval</code> to get the result and outputs it if it equals the target.</p>

<p><code>@cur_ops</code> was necessary because I chose to allow the negative prefix. Allowing the negative prefix also means my program needed to check more solutions. I wanted to generalize the problem a bit, but I could have saved some complexity by sticking with the literal problem description.</p>

<p>I also did some experimentation with more operators, including the outrageous set <code>@ops = qw( + - * / % &gt;&gt; &lt;&lt; &amp; | )</code>. That took a few minutes to run, since the number of permutations jumps to a few hundred million. There were <a href="http://ry.ca/misc/all_ops.txt">22,675 solutions</a> (573KiB), like the following:</p>

<pre><code>100 = +1 + 2 + 3 / 4 &lt;&lt; 5 | 6 &amp; 78 - 9
</code></pre>

<p>Can you place parentheses in that expression and have it still <code>eval</code> to 100? I may have spent over an hour trying that with various examples from the output.</p>

<p><strong>My Blog</strong> › <a href="http://www.ry.ca/2020/01/only-100-please/">Only 100, Please</a></p>

<h2 id="saif-ahmed">Saif Ahmed</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/saiftynet/perl/ch-1.pl">Saif&rsquo;s solution</a> is another recursive one. Saif uses the replacement form of <code>substr</code> to insert the operator into the string:</p>

<pre><code class="language-perl">sub tryInsert{
    my ($str,$target,$marker)=@_;
    $marker //=1;         # $marker identifies the first insertion point
                          # further attempts ar from this point to the
                          # postion before the last character in the string
    foreach my $pos ($marker..((length $str)-1)){
        foreach my $operator(qw{+ -}){
          my $temp=$str;                      # put in a temporary string
          substr $temp,$pos,0,$operator;      # insert the operator
          print $temp.&quot;\n&quot;                    # print the reulting string
             if   eval (&quot;$temp&quot;)==$target;    # only if the result is our $target
          tryInsert($temp,$target,$pos+2);    # recurse with new insertion point
        }
    }
}
</code></pre>

<p>Saif&rsquo;s solution is concise, and efficient. Nice.</p>

<h2 id="wanderdoc">wanderdoc</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/wanderdoc/perl/ch-1.pl">wanderdoc&rsquo;s solution</a> goes back to the iterative approach we&rsquo;ve seen, with the help of two CPAN modules:</p>

<ul>
<li><a href="https://metacpan.org/pod/Algorithm::Combinatorics">Algorithm::Combinatorics</a> › <code>variations_with_repetition()</code></li>
<li><a href="https://metacpan.org/pod/List::MoreUtils">List::MoreUtils</a> › <code>zip()</code></li>
</ul>

<p>The core module <a href="https://perldoc.perl.org/Scalar/Util.html">Scalar::Util</a> is also used, for the <code>looks_like_number()</code> function. Now let&rsquo;s see how wanderdoc puts it all together:</p>

<pre><code class="language-perl">my @operators = ('+', '-', '');
my $string = &quot;123456789&quot;;
my @array = split(//,$string);
my $iter = variations_with_repetition( [@operators], $#array);
my %uniq;
while ( my $c = $iter-&gt;next ) {
     my @z = zip(@array, @$c);
     pop @z; # undef.
     my $formula = join('',@z);
     $uniq{ $formula }++;
     next if $uniq{ $formula } &gt; 1;

     my $sum = eval $formula;
     unless ( looks_like_number($sum) ) {
          print $@, $/;
          die &quot;Sum is ${sum}: Something went wrong.&quot;;
     }

     next unless 100 == $sum;
     print &quot;${formula} = ${sum}$/&quot;;
}
</code></pre>

<p><code>$iter</code> is an iterator that now spits out a <code>$string</code> length - 1 sized array of operators, like so:</p>

<pre><code>+ + + + + + + +
+ + + + + + + -
+ + + + + + +
+ + + + + + - +
+ + + + + + - -
+ + + + + + -
(etc.)
</code></pre>

<p>All that needs to be done is to <code>zip()</code> them together to interleave the operators into the <code>@array</code> of digits, and then string-<code>eval</code> the result.</p>

<hr />

<h1 id="task-2-make-it-200">Task #2 - Make it 200</h1>

<p><em>You have only $1 left at the start of the week. You have been given an opportunity to make it $200. The rule is simple with every move you can either double what you have or add another $1. Write a script to help you get $200 with the smallest number of moves.</em></p>

<p>This week&rsquo;s second challenge in some respects was easier than the first, since there is an extremely elegant and efficient greedy algorithm to find the optimal path: instead of starting with $1, we start with $200 and work our way backwards. Whenever we have an even number, divide by 2, otherwise, subtract 1. This guarantees we will find the shortest path, which can simply be returned in reverse order. See <a href="http://www.ry.ca/2020/01/make-it-200/">my blog</a> for some informal discussion on why this works.</p>

<p>While many people did implement the above algorithm, there were some excellent alternative solutions as well. For instance, many people simply brute-forced the small search space.</p>

<h2 id="adam-russell-1">Adam Russell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/adam-russell/perl/ch-2.pl">Adam&rsquo;s solution</a> again uses <code>AI::Genetic</code>. See my discussion of his challenge #1 solution for a bit more background, or check out <a href="https://adamcrussell.livejournal.com/14635.html">Adam&rsquo;s blog</a>. Here&rsquo;s the fitness function:</p>

<pre><code class="language-perl">sub fitness{
    my($genes) = @_;
    my $total = 1;
    my $count_no_op = 1;
    for my $gene (@{$genes}){
        $total = $gene-&gt;($total);
        $count_no_op++ if $gene-&gt;() =~ m/no/;
    }
    return 200 - $total if $total &gt;= 200;
    return ($total - 200) * $count_no_op;
}
</code></pre>

<p>The fitness function is much simpler this time. Here, it just returns the negative distance from 200, but multiplied by a count of the no-ops, to penalize individuals with genes turned off. While the challenge #1 GA took around 45 seconds to run on my system, this one took just 600ms.</p>

<p>The way Adam&rsquo;s program produces an <em>optimal</em> solution bears some explanation: Adam sets up 9 genes which can each take on either <code>no_op</code>, <code>add_one</code>, or <code>double</code>:</p>

<pre><code class="language-perl">my $genes = [];
for (0 .. 8){
    push @{$genes}, [\&amp;add_one, \&amp;double, \&amp;no_op],
}
</code></pre>

<p>This means his program will, regardless of how much evolution takes place, never consider solutions with more than 9 operations. And we know that the optimal solution takes exactly 9 operations.</p>

<p><strong>Adam&rsquo;s Blog</strong> › <a href="https://adamcrussell.livejournal.com/14635.html">Evolving code with AI::Genetic</a></p>

<h2 id="alicia-bielsa-1">Alicia Bielsa</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/alicia-bielsa/perl/ch-2.pl">Alicia&rsquo;s solution</a> uses the greedy algorithm to make short work of the problem:</p>

<pre><code class="language-perl">my $objective = 200;
while ($objective &gt; 1 ) {
    if ($objective % 2 == 0){
        push (@aMoves, 'double');
        $objective = $objective / 2;
    } else {
        push (@aMoves, 'add 1');
        $objective = $objective - 1;
    }
}
</code></pre>

<p>She then works through <code>reverse(@aMoves)</code> to pretty-print the results:</p>

<pre><code class="language-perl">my $amountMoney = 1;
foreach my $move (reverse(@aMoves)){
    if ($move eq 'double'){
        print &quot;Double $amountMoney &quot;;
        $amountMoney = $amountMoney * 2 ;
        print &quot;= $amountMoney\n&quot;;
    } else {
        print &quot;Add 1 to $amountMoney &quot;;
        $amountMoney = $amountMoney + 1 ;
        print &quot;= $amountMoney\n&quot;;
    }
}
</code></pre>

<h2 id="andrezgz-1">Andrezgz</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/andrezgz/perl/ch-2.pl">Andrezgz&rsquo;s solution</a> works through the search space by looping through every 10-bit number, mapping the 0s and 1s to <code>+ 1</code> and <code>* 2</code>, and finally string-<code>eval</code>-ing each operation. With that, Andrezgz then returns the first set of <code>@ops</code> that evaluates to 200.</p>

<pre><code class="language-perl">use constant MOVES_LIMIT =&gt; 10; # upper bound of moves to check

foreach my $n ( 0 .. (2 ** MOVES_LIMIT)-1 ) {
    my @ops = map { $_ ? '+ 1' : '* 2'} split //, sprintf(&quot;%b&quot;, $n);
    my $value = 1;
    $value = eval($value . $_) for (@ops);

    if ($value == 200) {
        @solution = @ops;
        last;
    }
}
</code></pre>

<p>This does find the shortest path, partly due to the choice of <code>MOVES_LIMIT =&gt; 10</code>, which is very close to the optimal solution length of 9.</p>

<h2 id="cheok-yin-fung-1">Cheok-Yin Fung</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/cheok-yin-fung/perl/ch-2.pl">Cheok-Yin Fung&rsquo;s solution</a> loops from 3..200, storing previous results in <code>@t</code>. For each number, they consider whether dividing by 2 or subtracting 1 would lead to a shorter sequence, by looking at the previous term in the sequence.</p>

<pre><code class="language-perl">my @t = (0, 0, 1);

for my $k (3..200) {
    if ($k % 2 == 0) {$t[$k] = 1+ &amp;min( $t[$k/2] , $t[$k-1])}
        else {$t[$k] = $t[$k-1]+1;}
}

print $t[200], &quot;\n&quot;;
</code></pre>

<p>This solution outputs the optimal number of operations. With a little bit of bookkeeping, it could output the sequence itself as well.</p>

<p>Both this solution and Cheok-Yin Fung&rsquo;s solution for challenge #1 strike me as being quite analytical, which I appreciate.</p>

<h2 id="colin-crain-1">Colin Crain</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/colin-crain/perl/ch-2.pl">Colin&rsquo;s solution</a> uses the greedy approach, succinctly:</p>

<pre><code class="language-perl">while ( $value != 1) {
    if ($value % 2 == 0){
        $value /= 2;
    }
    else {
        $value -= 1;
    }
    unshift @steps, $value;         ## we build the array of steps from back to front
                                    ## so there is no need to reverse it later
}
</code></pre>

<p>Colin&rsquo;s extended comments contain a lot of interesting analysis on his own journey toward proving that the greedy solution produces optimal results.</p>

<h2 id="cristina-heredia">Cristina Heredia</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/cristian-heredia/perl/ch-2.pl">Cristina&rsquo;s solution</a> uses the greedy method, but splits the problem into two subs, which call each other to reduce <code>$number</code> as quickly as possible. The code to output the solution is also included in the <code>remove()</code> sub:</p>

<pre><code class="language-perl">sub divide {
    while (($number %2 )==0) {
        $number = $number / 2;
        unshift @moves, 'double ';
    }
    remove();
}

sub remove {
    $number --;
    unshift @moves, '+1$ ';
    if ($number == 1 or $number == 0) {
        print &quot;The moves that you have to do are: \n&quot;;
        $total = @moves;
        print &quot;$total\n&quot;;
        print 'And they are: ';
        foreach (my $i = 0; $i &lt; @moves; $i++) {
            print &quot;@moves[$i]&quot;;
        }
    }
    else {
        divide();
    }
}
</code></pre>

<p>Cristina is one of a few people who take advantage of <code>unshift</code> to insert the moves at the beginning of the array, which saves having to do a <code>reverse</code> later. Efficiency-wise, it&rsquo;s not going to make any real difference here, but it does make for slightly cleaner code.</p>

<h2 id="daniel-mantovani-1">Daniel Mantovani</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/daniel-mantovani/perl/ch-2.pl">Daniel&rsquo;s solution</a> takes the greedy approach, appending a plain-English sentence to <code>@steps</code> for each operation:</p>

<pre><code class="language-perl">while ($target &gt; 1) {
    if ($target % 2) {
        push @steps, sprintf('Add $1 to $%i (new total $%i)', $target-1, $target);
        $target--;
    } else {
        push @steps, sprintf('Multiply $%i by 2 (new total $%i)', $target / 2, $target);
        $target /= 2;
    }
}
</code></pre>

<p>Daniel then outputs <code>@steps</code>:</p>

<pre><code class="language-perl">for my $i (1..@steps) {
    say &quot;Step #$i: &quot;, pop @steps;
}
</code></pre>

<h2 id="dave-jacoby-1">Dave Jacoby</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/dave-jacoby/perl/ch-2.pl">Dave&rsquo;s solution</a> sets up a queue in <code>@array</code> to do a breadth-first search (BFS) of the search space:</p>

<pre><code class="language-perl">my @array = (1);
for my $i (@array) {
    my $check = decode($i);
    if ( $check == 200 ) {
        say join &quot;\t&quot;, $check, $i, scalar @array;
        exit;
    }

    if ( $check &gt; 200 ) {
        next;
    }
    push @array, $i . 'p';
    push @array, $i . 'd';
}
</code></pre>

<p>The <code>decode()</code> sub takes a string like <code>1dppd</code> and returns 8, since (((1 * 2) + 1) + 1) * 2 = 8:</p>

<pre><code class="language-perl">sub decode ( $sample ) {
    my ( $i, @list ) = split m//, $sample;
    for my $l (@list) {
        $i += 1 if $l eq 'p';
        $i *= 2 if $l eq 'd';
    }
    return $i;
}
</code></pre>

<p>While you might be aware that adding or removing elements within the loop body is expressly discouraged in the <a href="https://perldoc.perl.org/perlsyn.html#Foreach-Loops">Perl documentation</a> for hopefully obvious reasons, the full truth is a bit more nuanced. Since Dave is only ever appending to the end of <code>@array</code>, ahead of the current index, Perl never has any reason to get confused, so this works as a sort of sneaky queue.</p>

<h2 id="duane-powell-1">Duane Powell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/duane-powell/perl/ch-2.pl">Duane&rsquo;s solution</a> is another greedy implementation:</p>

<pre><code class="language-perl">my @solution;
my $goal = 200;
push @solution, $goal;
while ($goal &gt; 1) {
    # if odd number deduct 1 making it even, otherwise divide by 2
    $goal = ($goal % 2) ? $goal-1 : $goal/2;
    # push this step into the solution set
    push @solution, $goal;
}
say join(',',reverse(@solution));
</code></pre>

<p>Duane&rsquo;s solution is concise, and outputs a minimalistic array of intermediate numbers (1,2,3,6,12,24,25,50,100,200), since anyone looking at that list can easily see whether each number is doubled or incremented.</p>

<h2 id="duncan-c-white-1">Duncan C. White</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/duncan-c-white/perl/ch-2.pl">Duncan C. White&rsquo;s solution</a> exhaustively searches by maintaining a list of all possible sequences, which he builds up one character at a time, ensuring the shortest solution will be found first:</p>

<pre><code class="language-perl">fun search( $initial, $goal ) {
    my $seq = &quot;&quot;;
    my @todo = ( [$initial, &quot;&quot;] );
    for(;;) {
        # Build a new list of todo pairs, twice as long as the old one.
        # stopping if we hit $goal
        my @newtodo;
        foreach my $pair (@todo) {
            my( $currvalue, $currseq ) = @$pair;
            return $currseq if $currvalue == $goal;

            push @newtodo, [ 2 * $currvalue, $currseq.&quot;d&quot; ];
            push @newtodo, [ $currvalue + 1, $currseq.&quot;i&quot; ];
        }
        @todo = @newtodo;
    }
}
</code></pre>

<p>It&rsquo;s an interesting way to iterate.</p>

<h2 id="e-choroba-1">E. Choroba</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/e-choroba/perl/ch-2.pl">Choroba&rsquo;s solution</a> searches with the help of a <code>%possibilities</code> hash to map seen values to the sequences of numbers:</p>

<pre><code class="language-perl">my %possibilities = (1 =&gt; []);
while (! exists $possibilities{200}) {
    for my $p (keys %possibilities) {
        $possibilities{ $_ } ||= [ @{ $possibilities{$p} }, $p ]
            for $p + 1, $p * 2;
    }
}

my @moves = @{ $possibilities{200} };
say scalar @moves, &quot;: @moves&quot;;
</code></pre>

<p>Starting from the degenerate case of <code>1 =&gt; []</code>, Choroba expands on that by looping over all known solutions and adding 1 and multiplying by 2, and adding those results to <code>%possibilities</code>. As soon as <code>$possibilities{200}</code> exists, that expression must be the shortest, since it was checked for on every move.</p>

<p><strong>Choroba&rsquo;s Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/01/perl-weekly-challenge-044-one-hundred-two-hundred.html">One Hundred, Two Hundred</a></p>

<h2 id="fabrizio-poggi-1">Fabrizio Poggi</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/fabrizio-poggi/perl/ch-2.pl">Fabrizio&rsquo;s solution</a> is another greedy implementation:</p>

<pre><code class="language-perl">push @array, $number;
do {
    if ($number % 2) {
        $result = $number-1;
        push @array, $result;
        $number = $result/2;
        push @array, $number;
    } else {
        $number = $number/2;
        push @array, $number;
    }
} while($number &gt; 1);

@array = reverse@array;
print &quot;@array\n&quot;;
</code></pre>

<p>This code conveys its intentions well, and does the task it was designed to do.</p>

<h2 id="javier-luque-1">Javier Luque</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/javier-luque/perl/ch-2.pl">Javier&rsquo;s solution</a> recursively explores all sequences of incrementing or doubling, up to an arbitrarily defined maximum length:</p>

<pre><code class="language-perl">sub add_or_double {
    my ($cash, $steps, $solution) = @_;
    $steps++;
    return undef if $steps &gt; 15; # Let's not recurse past 15

    if ($cash == 200) {
        if ($min_steps &gt; $steps) {
            $min_steps = $steps;
            $min_solution = $solution;
        }
    }
    add_or_double($cash * 2, $steps, $solution . 'd') if $cash * 2 &lt;= 200;
    add_or_double($cash + 1, $steps, $solution . 'a') if $cash + 1 &lt;= 200;
}
</code></pre>

<p>The base case (<code>$cash == 200</code>) looks at whether the current solution is shorter than the previous best solution, and replaces the best solution if so.</p>

<p>The recursive step simply calls <code>add_or_double()</code> with the cash either doubled or incremented, with a bit of housekeeping to manage the sequence, and to avoid going over the goal amount.</p>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/01/21/perl-weekly-challenge-044/">Perl Weekly Challenge – 044</a></p>

<h2 id="laurent-rosenfeld-1">Laurent Rosenfeld</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/laurent-rosenfeld/perl/ch-2.pl">Laurent&rsquo;s solution</a> works by starting at $1, attempting to increment between 0 and 30 times, greedily multiplying by 2 until it exceeds half the target, and then incrementing the rest of the way:</p>

<pre><code class="language-perl">for my $incr (0..30) {
    last if $incr &gt; $min_ops;
    my $current_val = START_VAL;
    my @steps = ( START_VAL );
    for my $add (1..$incr) {
        push @steps, &quot;+1&quot;;
        $current_val++;
    }
    while ($current_val &lt;= HALF_TARGET) {
        push @steps, &quot;*2&quot;;
        $current_val *= 2;
    }
    while ($current_val &lt; TARGET) {
        push @steps, &quot;+1&quot;;
        $current_val++;
    }
    my $nb_steps = scalar @steps;
    next if $nb_steps &gt;= $min_ops;
    $min_ops = $nb_steps;
    $best_so_far = $incr;
    $good_combinations{$incr} = [@steps];
}
</code></pre>

<p>This leads to a solution with 16 steps: <code>1 +1 +1 *2 *2 *2 *2 *2 *2 +1 +1 +1 +1 +1 +1 +1 +1</code>, which is higher than the optimal 9-step solution. Had Laurent kept going, I&rsquo;m certain he would have quickly found an optimal algorithm.</p>

<p><strong>Laurent&rsquo;s Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/01/perl-weekly-challenge-44-only-100-please-and-make-it-200.html">Only 100, Please and Make it 200</a></p>

<h2 id="roger-bell-west-1">Roger Bell West</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/roger-bell-west/perl/ch-2.pl">Roger&rsquo;s solution</a> uses a queue to implement a breadth-first search:</p>

<pre><code class="language-perl">my @seq=([1,[]]);
my $goal=200;

while (1) {
  my $s=shift @seq;
  if ($s-&gt;[0] == $goal) {
    print join(', ',map {['double','add 1']-&gt;[$_]} @{$s-&gt;[1]}),&quot;\n&quot;;
    last;
  }
  push @seq,[$s-&gt;[0]*2,[@{$s-&gt;[1]},0]];
  push @seq,[$s-&gt;[0]+1,[@{$s-&gt;[1]},1]];
}
</code></pre>

<p>Roger uses the familiar <code>while</code>/<code>shift</code> approach to implementing the queue, and uses an array of arrays to do some housekeeping, storing both the sequence and its value in each queue element, which avoids the need to do any parsing or extra computation later.</p>

<h2 id="ruben-westerberg-1">Ruben Westerberg</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/ruben-westerberg/perl/ch-2.pl">Ruben&rsquo;s solution</a> uses the greedy method, building up the reversed sequence in <code>@moves</code>:</p>

<pre><code class="language-perl">my $target=200;
my @moves;
my $d=$target;
while ($d!=1) {
    if ($d%2==0) {
        push @moves, &quot;Double&quot;;
        $d/=2;
    }
    else {
        push @moves, &quot;Add 1&quot;;
        $d-=1;
    }
}
</code></pre>

<p>The results are then pretty-printed with the following code:</p>

<pre><code class="language-perl">my $t=1;
printf &quot;Start: \t\t%3d\n&quot;,$t;
for (reverse @moves) {
    $t+=1 if /^A/;
    $t*=2 if /^D/;
    printf &quot;Move:\t%s:\t%3d\n&quot;,$_, $t;
}
</code></pre>

<pre><code>Start:            1
Move:   Double:   2
Move:   Add 1:    3
Move:   Double:   6
Move:   Double:  12
Move:   Double:  24
Move:   Add 1:   25
Move:   Double:  50
Move:   Double: 100
Move:   Double: 200
</code></pre>

<h2 id="ryan-thompson-1">Ryan Thompson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/ryan-thompson/perl/ch-2.pl">My solution</a> uses the greedy method, but then I also wrote a recursive method, to search all possible solutions of <em>n</em> moves or less. First, here&rsquo;s the greedy one:</p>

<pre><code class="language-perl">sub double_or_plus( $start, $end ) {
    my @path = $end;
    while ($end != $start) {
        $end = $end % 2 ? $end - 1 : $end / 2;
        unshift @path, $end;
    }
    @path;
}
</code></pre>

<p>And here&rsquo;s the exhaustive recursive one (both of these use the <code>signatures</code> feature, and <code>exhaustive()</code> uses <code>current_sub</code> as well):</p>

<pre><code class="language-perl">sub exhaustive( $start, $end, $max_path ) {
    my @shortest = (0) x ($max_path + 1);

    sub ( $start, $end, @path ) {
        push @path, $start;

        return if @path &gt; @shortest or $start &gt;  $end;
        @shortest = @path and return if $start == $end;

        __SUB__-&gt;($start + 1, $end, @path);
        __SUB__-&gt;($start * 2, $end, @path);
    }-&gt;($start, $end);

    @shortest;
}
</code></pre>

<p>My blog has an informal justification for why the greedy method will always be optimal. I wrote the exhaustive one mainly for fun, but also so I could say I validated the greedy results for every value past <code>$end = 100_000</code>.</p>

<p><strong>My Blog</strong> › <a href="http://www.ry.ca/2020/01/make-it-200/">Make it 200</a></p>

<h2 id="saif-ahmed-1">Saif Ahmed</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/saiftynet/perl/ch-2.pl">Saif&rsquo;s solution</a> traverses the search space iteratively, effectively doubling the length of <code>@options</code> each time:</p>

<pre><code class="language-perl">sub doubleOrAdd{        # this routine takes starting value and final target
  my ($start,$target)=@_;

  return print &quot;Number out of bounds\n&quot;         # too big takes too long and
         if $target&gt;100000 or $target&lt;$start;   # can't be smaller than $target

  my @options=(&quot;$start&quot;);                       # initialise list of operations,
  my $found=($start==$target);                  # do we already have goal?

  while (! $found){
      @options = map {(&quot;($_+1)&quot;,&quot;($_*2)&quot;)} @options; # add the two possible ops
      foreach  my $answer ( @options ) {      # test each of the sequences
        if ( eval(&quot;$answer&quot;)==$target) {      # against our target
            # number of moves is count of open brackets,remove these.
            print $answer=~s/\(//g,&quot; moves required\n&quot;;

            $answer=~s/^(\d+)/Start with \$$1,\n/;   # the starting number is 1st number
            $answer=~s/\+1\)/ add 1,\n/g;            # make the result human
            $answer=~s/\*2\)/ double it,\n/g;        # readable:

            print $answer;
            $found=1;last;                           # stop looking
        };
      };
    }
    print &quot; Now you have \$$target!&quot;;                # declare discovery
}
</code></pre>

<p>What I find most interesting is the way Saif builds up the pretty-printed output. When an answer is found, Saif will have a string like <code>(((((((((1+1)+1)*2)*2)*2)+1)*2)*2)*2)</code>, which the three substitution regexes pull apart and turn into plain English.</p>

<h2 id="wanderdoc-1">Wanderdoc</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-044/wanderdoc/perl/ch-2.pl">Wanderdoc&rsquo;s solution</a> is another greedy implementation, kept nice and straightforward:</p>

<pre><code class="language-perl">while ( $START &gt;= 1 )
{
     push @steps, [$START, $GOAL];
     if ( $START % 2 == 0 )
     {
          $START /= 2;
     }
     else
     {
          $START -= 1;
     }
}
</code></pre>

<p>wanderdoc&rsquo;s output step iterates over <code>reverse @steps</code> and prints a 3-column output of the step number, current value, and goal (always 200):</p>

<pre><code class="language-perl">my $counter = 0;
for my $step ( reverse @steps )
{
     print join(&quot;\t&quot;, $counter, @$step[0,1] ), $/;
     $counter++;
}

</code></pre>

<hr />

<hr />

<h2 id="see-also">SEE ALSO</h2>

<hr />

<h3 id="blogs-this-week">Blogs this week:</h3>

<p>(1) <strong>Adam Russell</strong> › <a href="https://adamcrussell.livejournal.com/15036.html">Challenge 1</a> | <a href="https://adamcrussell.livejournal.com/14635.html">Challenge 2</a></p>

<p>(2) <strong>E. Choroba</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/01/perl-weekly-challenge-044-one-hundred-two-hundred.html">One Hundred, Two Hundred</a></p>

<p>(3) <strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/01/21/perl-weekly-challenge-044/">Perl Weekly Challenge - 044</a></p>

<p>(4) <strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/01/perl-weekly-challenge-44-only-100-please-and-make-it-200.html">Only 100, Please, and Make it $200</a></p>

<p>(5) <strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/01/only-100-please/">Only 100 please</a> | <a href="http://www.ry.ca/2020/01/make-it-200/">Make it 200</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

