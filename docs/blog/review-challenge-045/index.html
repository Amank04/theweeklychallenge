<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Perl Weekly Review: Challenge - #045">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.55.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Perl Weekly Review: Challenge - #045</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Perl Weekly Review: Challenge - #045</h2>
                    <div class="portfolio-meta">
                        <span>Saturday, Feb 8, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p5-review-challenge-045.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    

<p>Welcome to the Perl review for Week 045 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-045/">original tasks</a> and <a href="/blog/recap-challenge-045/">recap</a> of the weekly challenge.</p>

<p>Continues from <a href="/blog/review-challenge-044/">previous week</a>.</p>

<h2 id="getting-in-touch">Getting in Touch</h2>

<p><a href="mailto:rjt@cpan.org"><img src="http://ry.ca/misc/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>

<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="http://ry.ca/misc/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>

<p><a href="https://twitter.com/perlwchallenge"><img src="http://ry.ca/misc/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>

<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
<li><a href="#task1">Task 1</a></li>
<li><a href="#task2">Task 2</a></li>
<li><a href="#blogs">Blogs</a></li>
</ul>

<hr />

<hr />

<h1 id="task1">Task #1 › Square Secret Code</h1>

<hr />

<h2 id="original-task-description">Original task description</h2>

<p>The square secret code mechanism first removes any space from the original message. Then it lays down the message in a row of 8 columns. The coded message is then obtained by reading down the columns going left to right.</p>

<p>For example, the message is <strong>“The quick brown fox jumps over the lazy dog”.</strong></p>

<p>Then the message would be laid out as below:</p>

<pre><code>thequick
brownfox
jumpsove
rthelazy
dog
</code></pre>

<p><strong>Figure 1</strong> › Partitioned Plaintext</p>

<p>The code message would be as below:</p>

<pre><code>tbjrd hruto eomhg qwpe unsl ifoa covz kxey
</code></pre>

<hr />

<h2 id="my-general-observations">My general observations</h2>

<p>There seem to be two main ways people approached this task:</p>

<h3 id="1-partitioning">1. Partitioning</h3>

<p>By first splitting the plaintext into column-width substrings, you end up with <strong>Figure 1</strong> (above). From there, you can simply append the first character of each string to your output, then the second character, and so on.</p>

<p>This method is perhaps the most obvious implementation of the problem description, as it follows the wording quite closely.</p>

<h3 id="2-split-and-modulo-arithmetic">2. <code>split</code> and Modulo Arithmetic</h3>

<p>For this method, you first <code>split</code> the plaintext into a list of chars. Then, you loop over the plaintext array, appending each character into its <code>$index % $columns</code> string in an array of <code>@columns</code>. Finally, you simply <code>join</code> the columns together.</p>

<p>This method is maybe a little less obvious, but lead to some concise solutions.</p>

<hr />

<p>If my plain English descriptions don&rsquo;t make complete sense yet, don&rsquo;t worry; there will be plenty of code examples of both methods below.</p>

<h2 id="adam-russell">Adam Russell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/adam-russell/perl/ch-1.pl">Adam Russell&rsquo;s solution</a> uses the <code>split</code> and modulo arithmetic method. He iterates over <code>@characters</code> to <code>push</code> characters into the array of arrays, <code>@buckets</code>:</p>

<pre><code class="language-perl">use constant SQUARE_SIZE =&gt; 8;
sub encode{
    my($message) = @_;
    $message =~ tr/ //d;
    my $encoded;
    my @buckets;
    my @characters = split(//, lc($message));
    for my $i (0 .. @characters){
       $buckets[$i % SQUARE_SIZE] = [] if !$buckets[$i % SQUARE_SIZE];
       push @{$buckets[$i % SQUARE_SIZE]}, $characters[$i] if $characters[$i];
    }
    for my $bucket (@buckets){
        $encoded .= join(&quot;&quot;, @{$bucket}) . &quot; &quot;;
    }
    return $encoded;
}
</code></pre>

<p>The solution is then built up by joining each of the <code>@buckets</code> together, and appending the result to the <code>$encoded</code> output string, with the space to separate the columns.</p>

<p><strong>Blog</strong> › <a href="https://adamcrussell.livejournal.com/15213.html">Perl Fun</a></p>

<h2 id="alicia-bielsa">Alicia Bielsa</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/alicia-bielsa/perl/ch-1.pl">Alicia Bielsa&rsquo;s solution</a> has an input loop that asks the user for a plaintext message. Her <code>encodeMessage</code> function uses the <code>split</code> and modulo method to encode the message:</p>

<pre><code class="language-perl">sub encodeMessage {
    my $message = shift;
    my @aSubMessages = ();
    my $messageEncoded = '';
    $message =~ s%\s+%%g;
    my @aEncodedGroups = ();
    my @aMessage = split ('', $message);
    foreach my $indexMessage  (0..$#aMessage) {
        my $indexSubgroup = $indexMessage % $columnLength ;
        unless  (defined $aEncodedGroups[$indexSubgroup]) {
            $aEncodedGroups[$indexSubgroup] = '';
        }
        $aEncodedGroups[$indexSubgroup] .= $aMessage[$indexMessage]; #t
    }
    $messageEncoded = join(' ', @aEncodedGroups);
    return $messageEncoded ;
}
</code></pre>

<p>The <code>$indexSubgroup = $indexMessage % $columnLength</code> line is what sets up the proper index, so that the next character in <code>@aMessage</code> is appended to the correct column in <code>@aEncodedGroups</code>.</p>

<p>Also notable, is that Alicia is one of a few people who allows for a configurable column width, through the <code>$columnLength</code> variable, which is a thoughtful touch.</p>

<h2 id="andrezgz">Andrezgz</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/andrezgz/perl/ch-1.pl">Andrezgz&rsquo;s solution</a> first converts the input to lowercase, and then filters out any remaining non-lowercase characters (such as numerics, symbols, and spaces):</p>

<pre><code class="language-perl">my $msg = join '',
          map {my $w = lc $_; $w =~ s/[[:^lower:]]//g; $w }
          @ARGV or die &quot;USAGE: $0 &lt;message&gt;&quot;;
</code></pre>

<p>After that, the solution is built up in a <code>%cols</code> hash with modulo arithmetic, with one member for each column:</p>

<pre><code class="language-perl">my %cols;
# each letter is appended to the corresponding column
$cols{$_ % 8} .= substr $msg, $_, 1 for (0 .. (length $msg) -1 );

# coded message is formed by printing each column string in order
print join ' ', map { $cols{$_} } sort keys %cols;
</code></pre>

<p>This is a really clean solution, and I particularly like the decision to filter out characters based on what is <em>allowed,</em> instead of what isn&rsquo;t. When possible, this method typically leads to safer, less error-prone code, as the programmer doesn&rsquo;t have to account for every possible thing a user might throw at them.</p>

<h2 id="arne-sommer">Arne Sommer</h2>

<p>Arne has submitted excellent Raku solutions for <em>all</em> 45 weeks in the challenge so far, which is absolutely fantastic. But this is, I believe, the first week Arne has submitted a Perl solution since all the way back in Week 023. Welcome back!</p>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/arne-sommer/perl/ch-1.pl">Arne Sommer&rsquo;s solution</a> is straightforward:</p>

<pre><code class="language-perl">my $string = $ARGV[0] || &quot;The quick brown fox jumps over the lazy dog&quot;;
$string =~ tr/ //d;
my @a = split(//, lc $string);

@a.shift;
@a.pop;

for my $word (0 .. 7) {
  my $index = $word;
  while (1) {
    defined $a[$index]
      ? print $a[$index]
      : print(&quot; &quot;) &amp;&amp; last;

   $index += 8;
  }
}
print &quot;\n&quot;;
</code></pre>

<p>One minor issue, is that the <code>@a.shift;</code> and <code>@a.pop;</code> lines aren&rsquo;t necessary, and in fact, these statements do nothing except some string concatenation in void context (which would have thrown a warning with <code>use warnings</code> enabled). On reading his blog, Arne was getting extra characters somehow, but that appears to no longer be the case, as this solution works perfectly. It&rsquo;s also very easy to understand.</p>

<p>Again, I&rsquo;m very glad to see Arne submitting Perl solutions, and hope to see more in the future! If you haven&rsquo;t already been following his blog, please do so; it&rsquo;s excellent.</p>

<p><strong>Blog</strong> › <a href="https://raku-musings.com/square-dumper.html">Square Dumper with Raku</a></p>

<h2 id="athanasius">Athanasius</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/athanasius/perl/ch-1.pl">Athanasius&rsquo;s solution</a> also has an input loop, and the encoder uses the partitioning method:</p>

<pre><code class="language-perl">sub encode {
    my  ($plain)  = @_;
    my   @rows;
    push @rows, substr($plain, 0, $COLUMNS, '') while $plain;
    my   $encoded = '';

    for my $col (0 .. $COLUMNS - 1) {
        $encoded .= ' ' if $encoded;

        for my $row (0 .. $#rows) {
            my $text  = $rows[$row];
            $encoded .= substr($text, $col, 1) if $col &lt; length $text;
        }
    }

    return $encoded;
}
</code></pre>

<p>As you can see, <code>@rows</code> is built up by partitioning <code>$plain</code> into chunks of up to <code>$COLUMN</code> characters. (The fourth argument to <code>substr</code> (<code>''</code>) is the replacement text, so those chunks get removed during the loop). The next two nested loops build up <code>$encoded</code> character by character from the strings in <code>@rows</code>.</p>

<p>Athanasius wrote a decoder as well:</p>

<pre><code class="language-perl">sub decode {
    my ($encoded) = @_;
    my  @rows     = split /\s+/, $encoded;
    my  $decoded  = '';

    for my $col (0 .. length($rows[0]) - 1) {
        $decoded .= substr($rows[$_], $col, 1) for 0 .. $#rows;
    }

    return $decoded;
}
</code></pre>

<p>The decoder is a little simpler as Athanasius was able to take advantage of the encoded format having spaces separating the rows, but the meat of the function is similar: the nested loops are essentially doing the inverse of what <code>encode</code> did, above.</p>

<h2 id="burkhard-nickels">Burkhard Nickels</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/perl/ch-1.pl">Burkhard Nickels&rsquo; solution</a> first <code>split</code>s the plaintext into a character array, <code>@l</code>. Then, Burkhard uses a nested loop that builds up the result (<code>$coded_msg</code>) by calculating the array indicies:</p>

<pre><code class="language-perl">$msg =~ s/\s//g;
$msg = lc($msg);
my @l = split(&quot;&quot;,$msg);

my $coded_msg;
for(my $i=0; $i&lt;=7; $i++) {
    for(my $j=$i; $j&lt;=$#l; $j+=8) {
        $coded_msg .= $l[$j];
    }
    $coded_msg .= &quot; &quot;;
}
print &quot;Coded   : $coded_msg\n&quot;;
</code></pre>

<p>The C-style <code>for</code> loops allow Burkhard to manipulate the starting index and increment of the inner loop, so <code>$j</code> will always be the next index to be appended to the result.</p>

<h3 id="python">Python</h3>

<p>Burkhard also submitted a <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/python/ch-1.py">Python solution</a>. Here&rsquo;s the encoder:</p>

<pre><code class="language-python">msg = re.sub('\s','',msg)
msg = msg.lower()
l = list(msg)

coded_msg = &quot;&quot;
for i in range(0,8):
    j = i
    e = len(l)
    while j &lt; e:
        coded_msg += l[j]
        j += 8
    coded_msg += &quot; &quot;

print &quot;Coded   : &quot;, coded_msg
</code></pre>

<p>The Python code uses the same algorithm as the above Perl solution.</p>

<p><strong>Blog</strong> › <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/perl/ch-1.pod">Square Secret Code</a></p>

<h2 id="cheok-yin-fung">Cheok-Yin Fung</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/cheok-yin-fung/perl/ch-1.pl">Cheok-Yin Fung&rsquo;s solution</a> decomposes the problem into three distinct parts. First, the plaintext is sanitized, and padded to be a multiple of 8 characters:</p>

<pre><code class="language-perl">$msg = lc($msg);
$msg =~ s/\s//g; # &amp;removespace($_);
$msg =~ s/\t//g;

#ADD WHITESPACE AT THE END SUCH THAT THE LINE HAS 8n CHARACTERS
my $copyoflengthofmsg = length($msg);
$msg .= &quot; &quot; x ($copyoflengthofmsg % 8);
</code></pre>

<p>Second, the plaintext is split into characters, and put into a two-dimensional array. <code>$i</code> and <code>$j</code> are maintained such that <code>@a</code> will have the characters in the same type of grid shown in the challenge description:</p>

<pre><code class="language-perl">my $numberofcols = 8;

foreach my $char (split //, $msg) {
    $a[$i][$j] = $char;
        $copyoflengthofmsg++;
    $j++;
    if ($j==$numberofcols) {$j = 0; $i++;}
}
</code></pre>

<p>Finally, Cheok-Yin Fung iterates over the <code>@a</code> grid to print out the solution:</p>

<pre><code class="language-perl">for $j (0..$numberofcols) {
    for $i (0..7) {
        $b[$p] = $a[$i][$j];
        if ($b[$p] ne &quot; &quot;) {print $b[$p];}
        $p++;
    }
    print &quot; &quot;;
}
</code></pre>

<h2 id="colin-crain">Colin Crain</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/colin-crain/perl/ch-1.pl">Colin Crain&rsquo;s solution</a> <code>split</code>s and uses modulo arithmetic:</p>

<pre><code class="language-perl">## eliminate spaces and nonword chars, lowercase rest in one pass
$input = lc( join '', grep { /\w/ } split //, $input );

## create the output array data structure
push my @output, [] for (1..8);

## fill the output arrays
push $output[$_%8]-&gt;@*, substr $input, ($_), 1  for (0..(length $input) - 1);

## display the output arrays
say join ' ', map {join '', $_-&gt;@* } @output;
</code></pre>

<p>This is an example of a good way to use the <a href="https://perldoc.perl.org/perlref.html#Postfix-Dereference-Syntax">post-deref</a> syntax, in my opinion; it actually aids the comprehension in this case. Colin&rsquo;s solution is compact, without being hard to follow.</p>

<h2 id="dave-cross">Dave Cross</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/dave-cross/perl/ch-1.pl">Dave Cross&rsquo; solution</a> outputs the result in the loop body, rather than building up a string first, but the result is the same:</p>

<pre><code class="language-perl">$msg =~ s/\s+//g;

my @lines = map { [ split // ] } $msg =~ /(.{1,8})/g;

for my $x (0 .. $#{$lines[0]}) {
  for my $y (0 .. $#lines) {
    print $lines[$y][$x] // '';
  }
  print ' ';
}

print &quot;\n&quot;;
</code></pre>

<p>Dave partitions <code>$msg</code> into 8 character (or less) chunks with a <code>/g</code> regex in list context, so it can be sent straight to <code>map</code>, where it is then split into characters and stored in an array of arrays.</p>

<h2 id="dave-jacoby">Dave Jacoby</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/dave-jacoby/perl/ch-1.pl">Dave Jacoby&rsquo;s solution</a> first filters out any non-lowercase characters, and then starts partitioning <code>$plaintext</code> into chunks of 8 characters or less, using <code>substr</code> and regexp substitution:</p>

<pre><code class="language-perl">sub encypher ( $plaintext ) {
    $plaintext = lc $plaintext;
    $plaintext =~ s/[^a-z]//gmx;
    my @work;

    while ( length $plaintext &gt;= 8 ) {
        my $eight = substr $plaintext, 0, 8;
        $plaintext =~ s/\w{8}//mix;
        push @work, $eight;
    }
    push @work, $plaintext;

    my @cyphertext;

    for my $i ( 0 .. scalar @work - 1 ) {
        my $word = $work[$i];
        for my $j ( 0 .. length $word ) {
            my $letter = substr $word, $j, 1;
            next unless scalar $letter;
            $cyphertext[$j][$i] = $letter;
        }
    }

    return join ' ', map { join '', $_-&gt;@* } @cyphertext;
}
</code></pre>

<p>After that, <code>@cyphertext</code> is a two-dimensional array (array of arrays, or AoA) built up with a by now familiar-looking nested loop. The <code>return</code> is made by sending each top-level element of <code>@cyphertext</code> through <code>map { join '', $_-&gt;@* }</code> to turn the array into a string, and then those strings are <code>join</code>ed by the leftmost <code>join ' '</code>.</p>

<p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/01/29/challenge-45-cyphers-and-quines.html">Challenge 45: Cyphers and Quines</a></p>

<h2 id="duane-powell">Duane Powell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/duane-powell/perl/ch-1.pl">Duane Powell&rsquo;s solution</a> is concise and clear:</p>

<pre><code class="language-perl">$code =~ s/ //g;
my @code = split(//,$code);

my @out;
my $m = 0;
$out[$m++ % $block] .= shift(@code) while (@code);
print &quot;$_ &quot; foreach (@out);
print &quot;\n&quot;;
</code></pre>

<p>The line doing the heavy lifting, <code>$out[$m++ % $block] .= shift(@code) while (@code)</code> is another good example of how modulo arithmetic really makes light work of this problem.</p>

<h2 id="duncan-c-white">Duncan C. White</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/duncan-c-white/perl/ch-1.pl">Duncan C. White&rsquo;s solution</a> provides both an encoder and decoder, as well as a way to change the number of columns. The encoder uses the modulo arithmetic method, but replaces the <code>split</code> with repeated calls to <code>substr $text, $pos, 1</code> to get one character at a time:</p>

<pre><code class="language-perl">use Function::Parameters;

fun encode( $text )
{
    my @columns;
    $text =~ s/\s+//g;        # remove all whitespace
    my $len = length($text);
    foreach my $pos (0..$len-1) {
        my $ch = substr($text,$pos,1);
        $columns[$pos%$ncolumns] //= &quot;&quot;;
        $columns[$pos%$ncolumns] .= $ch;
    }
    my $result = join( ' ', @columns );
    return $result;
}
</code></pre>

<p>The decoder splits the ciphertext on whitespace to obtain <code>@columns</code>. After that is a nested loop, whose body uses <code>s/(^\w)//</code> to trim (and capture) the first character from one of the <code>@columns</code>, appending it to the result:</p>

<pre><code class="language-perl">fun decode( $text )
{
    my @columns = split( /\s+/, $text );
    my $ncols = @columns;
    die &quot;decode: $text has $ncols columns, not $ncolumns\n&quot;
        unless $ncols == $ncolumns;
    my $npasses = length( $columns[0] );
    my $result = &quot;&quot;;
    foreach my $p (1..$npasses) {
        foreach (@columns) {
            if( $_ ) {
                s/(^\w)//;    # remove 1st char from column
                $result .= $1;
            }
        }
    }
    return $result;
}
</code></pre>

<h2 id="e-choroba">E. Choroba</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/e-choroba/perl/ch-1.pl">E. Choroba&rsquo;s solution</a>:</p>

<pre><code class="language-perl">sub square_secret_code {
    my ($message) = @_;
    my @code = (&quot;&quot;) x 8;
    for my $group (lc($message) =~ s/\s//gr =~ m/(.{1,8})/g) {
        $code[$_] .= (split //, $group)[$_] // &quot;&quot; for 0 .. 7;
    }
    return join ' ', @code
}
</code></pre>

<p>This solution is another example of using the <code>/g</code> modifier in list context. However, Choroba does one better and first removes spaces with the substitution <code>s/\s//gr</code>. The <code>/r</code> modifier is a personal favourite of mine, as instead of performing the substitution in place as usual, it returns a copy of the (modified) string instead. Without that, Choroba would have needed an extra couple of lines of code.</p>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/01/perl-weekly-challenge-045-square-secret-code-source-dumper.html">Perl Weekly Challenge 045: Square Secret Code &amp; Source Dumper</a></p>

<h2 id="jaldhar-h-vyas">Jaldhar H. Vyas</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/jaldhar-h-vyas/perl/ch-1.pl">Jaldhar H. Vyas&rsquo; solution</a> chunks the plaintext into <code>@rows</code> of 8 characters, and then uses a nested loop to append the <code>$i</code>th character from each row to the <code>$i</code>th column. The solution is then just <code>@cols</code>, separated by spaces:</p>

<pre><code class="language-perl">my $input = lc join q{ }, @ARGV;
$input =~ s/\s+//gmx;
my @rows;
while (length $input) {
    push @rows, substr $input, 0, 8, q{};
}

my @cols;
for my $row (@rows) {
    my @chars = split //, $row;
    for my $i (0 .. 7) {
        if ($chars[$i]) {
            $cols[$i] .= $chars[$i];
        }
    }
}

say join q{ }, @cols;
</code></pre>

<p><strong>Blog</strong> › <a href="https://www.braincells.com/perl/2020/02/perl_weekly_challenge_week_45.html">Perl Weekly Challenge: Week 45</a></p>

<h2 id="javier-luque">Javier Luque</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/javier-luque/perl/ch-1.pl">Javier Luque&rsquo;s solution</a> is another concise one with modulo arithmetic:</p>

<pre><code class="language-perl">$string =~ s/\s//g;
my @chars = split('', $string);
my @new_words;

for my $i (0..scalar(@chars)-1) {
    $new_words[$i % 8] .= $chars[$i];
}

say join ' ', @new_words;
</code></pre>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/01/30/perl-weekly-challenge-045/">PERL WEEKLY CHALLENGE – 045 – Perl Weekly Challenge</a></p>

<h2 id="laurent-rosenfeld">Laurent Rosenfeld</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/laurent-rosenfeld/perl/ch-1.pl">Laurent Rosenfeld&rsquo;s solution</a> uses the partition approach, printing the output on the fly:</p>

<pre><code class="language-perl">$msg =~ s/\s+//g;
my @letters = map { /.{1,8}/g; } $msg;
for my $i (0..7) {
    print map { substr  $_, $i, 1 if length $_ &gt;= $i} @letters;
    print &quot; &quot;;
}
</code></pre>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-45-square-secret-code-and-source-dumper.html">Perl Weekly Challenge 45: Square Secret Code and Source Dumper</a></p>

<h2 id="maxim-kolodyazhny">Maxim Kolodyazhny</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/maxim-kolodyazhny/perl/ch-1.pl">Maxim Kolodyazhny&rsquo;s solution</a> is a unique one:</p>

<pre><code class="language-perl">$_ = lc &lt;&gt;;
s/\s//g;

for my $i ( 0..7 ) {
    last if ( pos = $i ) == length;
    print
        $i ? ' ' : '',
        /(.).{0,7}/g;
}
</code></pre>

<p>Take careful note of Maxim&rsquo;s assignment to <code>pos</code>, as that is the key to the entire solution. <code>pos</code> sets the offset of the regexp match, and the regexp <code>/(.).{0,7}/g</code> captures every 8th character from that offset. The offset is then incremented the next time through, and it repeats, and thus the columns are printed, one character at a time.</p>

<p>Maxim also included an <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/maxim-kolodyazhny/perl/t/ch-1.t">external set of tests</a>.</p>

<h2 id="nazareno-delucca">Nazareno Delucca</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ndelucca/perl/ch-1.pl">Nazareno Delucca&rsquo;s solution</a> uses partitioning, and also allows for a user-specified column width:</p>

<pre><code class="language-perl">my $columns = shift || 8;
$message =~ s/\s+//g;
my @rows = unpack &quot;(A$columns)*&quot;, lc $message;

foreach my $word ( @rows ){
    my @chars = split //, $word;
    push @matrix, \@chars;
}

for (0..$columns) {
    for my $row( @matrix ) {
        $code .= shift @$row || '';
    }
    $code .= &quot; &quot;;
}

print &quot;$code\n&quot;;
</code></pre>

<p>The use of <code>unpack</code> is a good way to partition the string. Nazareno then splits the row strings to character arrays to simplify the following task of repeatedly peeling off the first character of each string.</p>

<h2 id="peter-scott">Peter Scott</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/peter-scott/perl/ch-1.sh">Peter Scott&rsquo;s solution</a> came as the following one-liner:</p>

<pre><code class="language-bash">perl -E '$_ = lc shift; tr/a-z//cd; @x = split //; $c=7; while (@x){ for ($i = 0; $i &lt;= $#x; $i += $c) { print splice @x, $i, 1} $c--; print &quot; &quot;} say &quot;&quot;' &quot;The quick brown fox jumps over the lazy dog&quot;
</code></pre>

<p>Adding some whitespace back in, we can see it is similar to the <code>split</code>-and-loop method, but is the only solution this week to use <code>splice</code>:</p>

<pre><code class="language-perl">$_ = lc shift;
tr/a-z//cd;
@x = split //;
$c = 7;
while (@x) {
    for ($i = 0; $i &lt;= $#x; $i += $c) {
        print splice @x, $i, 1
    }
    $c--;
    print &quot; &quot;
}
</code></pre>

<p><code>splice @x, $i, 1</code> is <code>$x[$i]</code> with the side effect of removing it from <code>@x</code>. Because the element is removed and the others shift positions, Peter compensates by decrementing <code>$c</code> after every column, since the interval between columns decreases by one.</p>

<p>Although <code>splice</code> will be slower, the effect is small (about 15% on a 60-character input string, increasing with length), and I do appreciate the alternative loop conditionals, here, compared to a purely arithmetic-indexed approach.</p>

<h2 id="rage311">Rage311</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/rage311/perl/ch-1.pl">Rage311&rsquo;s solution</a> uses the <code>split</code>/modulo method, and is beautifully concise:</p>

<pre><code class="language-perl">my @input = split //, &lt;&lt;&gt;&gt; =~ s/\s+//gr;

my @words;
$words[$_ % 8] .= $input[$_] for 0..$#input;

say join ' ', @words;
</code></pre>

<p>This is, I believe, Rage311&rsquo;s first Perl submission. Congrats! I hope to see a lot more like this one.</p>

<p>Rage311 also <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/rage311/rust/ch-1.rs">submitted a solution in Rust</a>, using the same algorithm. Here it is, for all you Rust fans out there:</p>

<pre><code class="language-rust">fn main() -&gt; io::Result&lt;()&gt; {
    let mut buffer = String::new();
    io::stdin().read_to_string(&amp;mut buffer)?;
    buffer = buffer.split_whitespace().collect();

    let mut final_words: Vec&lt;String&gt; = vec![&quot;&quot;.to_string(); 8];

    for i in 0..buffer.len() {
        final_words[i % 8].push(buffer.chars().nth(i).unwrap());
    }

    println!(&quot;{}&quot;, final_words.join(&quot; &quot;));

    Ok(())
}
</code></pre>

<h2 id="roger-bell-west">Roger Bell West</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/roger-bell-west/perl/ch-1.pl">Roger Bell West&rsquo;s solution</a> uses core module <a href="https://perldoc.perl.org/Getopt/Std.html"><code>Getopt::Std</code></a> to accept an arbitrary column width:</p>

<pre><code class="language-perl">use Getopt::Std;
my %o=(n =&gt; 8);
getopts('n:',\%o);
</code></pre>

<p>Then, after stripping spaces, his encoding looks like this:</p>

<pre><code class="language-perl">my $l=length($in)-1;
my @out;
foreach my $c (0..$o{n}-1) {
    my $out;
    for (my $k=$c;$k&lt;=$l;$k+=$o{n}) {
        $out.=substr($in,$k,1);
    }
    push @out,$out;
}
print join(' ',@out),&quot;\n&quot;;
</code></pre>

<p>As you can see, Roger uses a C-style <code>for</code> loop so he can increment by the column width (<code>$o{n}</code>) to pull every <code>$o{n}</code>-th character into his output array. The outer loop shifts the offset (<code>$c</code>) every time through. If speed was the goal, this could be ported to a C XS module with just a few minor changes.</p>

<h2 id="ruben-westerberg">Ruben Westerberg</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ruben-westerberg/perl/ch-1.pl">Ruben Westerberg&rsquo;s solution</a> avoids the need to deal with undefined values for strings that aren&rsquo;t a multiple of 8 characters in length by padding the string with spaces:</p>

<pre><code class="language-perl">$padded .= &quot; &quot; x (8+8-length($padded)%8);
</code></pre>

<p>Then, he partitions and splits the string into the <code>@rows</code> array-of-arrays, and iterates over it with a nested loop:</p>

<pre><code class="language-perl">my @rows;
my $steps=length($padded)/ 8;
push @rows, [split &quot;&quot;, substr $padded, $_*8,8] for (0..$steps-1);
my $out=&quot;&quot;;
for my $c (0..7) {
    for my $r (0..$steps-1) {
        $out.= join &quot;&quot;,$rows[$r]-&gt;[$c];
    }
}
$out=~s/ +/ /g;
$out=~s/ $//;
print $out;
</code></pre>

<p>His padded string does require a bit of trimming at the end, but after that, all that needs be done is <code>print $out</code>. Nice.</p>

<h2 id="ryan-thompson">Ryan Thompson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ryan-thompson/perl/ch-1.pl">My solution</a> uses the split/modulo method:</p>

<pre><code class="language-perl">sub encode {
    local $_ = lc shift;
    s/\s//g;
    my ($i, @s);

    map { $s[$i++ % COLUMNS] .= $_ } split '';

    join ' ', @s;
}
</code></pre>

<p>The last two lines do most of the work. Had I been going for brevity, I might have combined the <code>lc</code> and substitution regex on the same line as <code>split</code>:</p>

<pre><code class="language-perl">sub encode {
    my ($i, @s);
    $s[$i++ % COLUMNS] .= $_ for split '', lc shift =~ s/\s//gr;
    join ' ', @s
}
</code></pre>

<p>But I didn&rsquo;t feel that helped the code, so I left it as separate statements. I would be happy with either, though.</p>

<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/01/square-secret-code/">Square Secret Code</a></p>

<h2 id="saif-ahmed">Saif Ahmed</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/saiftynet/perl/ch-1.pl">Saif Ahmed&rsquo;s solution</a> also supports arbitrary columns, and uses the partition method to chunk the plaintext into <code>@splitChars</code> before the familiar-looking nested loop builds up <code>$result</code> character by character:</p>

<pre><code class="language-perl">sub pivotEncode{
   my $str=shift;
   my $cols=shift//8;
   $str=~s/\s//gm;                             # remove spaces
   @splitChars=($str=~/(.{$cols}|.+)/g);       # split into blocks
   my $result;                                 # initialise result
   foreach my $index (0..$cols-1) {            # now select character
      foreach my $row ( @splitChars ){         # in each block and
                                               # append it to result
        $result.= substr($row,$index,1) if ($index&lt;length $row)
      }
      $result.=&quot; &quot;;                            #intersperse spaces
   }
   return $result;                             # return encrypted
}
</code></pre>

<h2 id="ulrich-rieke">Ulrich Rieke</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ulrich-rieke/perl/ch-1.pl">Ulrich Rieke&rsquo;s solution</a> uses the partitioning method. I&rsquo;ll take you through his <code>encode</code> function one step at a time. First, he partitions the string (including any remaining portion less than 8 characters long):</p>

<pre><code class="language-perl">sub encode {
  my $str = shift ;
  my @strings ;
  my $times = int ( (length $str) / 8 ) ;
  my $pos = 0 ;
  for ( my $i = 0 ; $i &lt; $times ; $i++ ) {
      push @strings, substr( $str, $pos , 8 ) ;
      $pos += 8 ;
  }
</code></pre>

<p>At this point, <code>@strings</code> contains one string for each row. Next, Ulrich uses a nested loop and <code>substr($word, $i, 1)</code> to build up <code>$encoded</code> character by character:</p>

<pre><code class="language-perl">  push @strings , substr( $str, $pos ) ;
  my $encoded ;
  for ( my $i = 0 ; $i &lt; 8 ; $i++ ) {
      for my $word ( @strings ) {
    my $len = length $word ;
    if ( $len &gt; $i ) {
        $encoded .= substr( $word , $i , 1 ) ;
    }
      }
  }
</code></pre>

<p>By now, <code>$encoded</code> might look like <code>Tbjrdhrutoeomhgqwpeunslifoacovzkxey</code>, which is close, but needs spaces between the columns, which is what this next bit does, by splitting and then recombining via <code>join ' ', @encodedStrings</code>:</p>

<pre><code class="language-perl">  my $stringslen = scalar @strings ;
  my $len = length $encoded ;
  $times =  length $strings[-1]  ;
  my @encodedStrings ;
  $pos = 0 ;
  for ( my $i = 0 ; $i &lt; $times ; $i++ ) {
      push @encodedStrings, substr( $encoded , $pos , $stringslen ) ;
      $pos += $stringslen ;
  }
  my $theRest = 8 - $times ;
  for ( my $i = 0 ; $i &lt; $theRest ; $i++ ) {
      push @encodedStrings , substr( $encoded , $pos , $stringslen - 1 ) ;
      $pos += $stringslen - 1 ;
  }
  return ( join ( ' ' , @encodedStrings ) ) ;
}
</code></pre>

<h2 id="wanderdoc">Wanderdoc</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/wanderdoc/perl/ch-1.pl">Wanderdoc&rsquo;s solution</a> uses Leon Timmermans&rsquo; <a href="https://metacpan.org/pod/Const::Fast"><code>Const::Fast</code></a> in place of builtin constants:</p>

<pre><code class="language-perl">use Const::Fast; # To use the constant in the regex.
const my $SECRET =&gt; 8;
const my $REGEX =&gt; qr/(.{1,${SECRET}})/;
</code></pre>

<p>Wanderdoc then uses the partitioning method to break up the string:</p>

<pre><code class="language-perl">sub encoding_message {
     my $str = $_[0];
     $str =~ tr/ //ds;
     $str = lc $str;

     my @rows = map [split(//,$_)], ($str =~ /$REGEX/g);
     my @coded = map {
          my $idx = $_;
          my @slice = map $_-&gt;[$idx] // '', @rows; [@slice];
     } 0 .. $SECRET - 1;

     my $enc = join(' ', map join('',@$_), @coded);

     return $enc;
}
</code></pre>

<p>Notice that Wanderdoc uses a variation on the nested loop to create an array-of-arrays in <code>@coded</code>, that is then joined together for the solution.</p>

<p>Wanderdoc also provides a decoder, which looks very similar to the above portion of the encoder, but in reverse:</p>

<pre><code class="language-perl">sub decoding_message {
     my $str = $_[0];
     my @words = map [split(//,$_)], split(' ', $str);
     my @txt = map {
          my $idx = $_;
          my @slice = map $_-&gt;[$idx] // '', @words; [@slice];
     } 0 .. $#words;

     my $dec = join('', map join('',@$_), @txt);
}
</code></pre>

<hr />

<hr />

<h1 id="task2">Task #2 - Source Dumper</h1>

<p>Write a script that dumps its own source code. For example, say, the script name is <code>ch-2.pl</code>. The following command should return nothing:</p>

<pre><code class="language-sh">$ perl ch-2.pl | diff - ch-2.pl
</code></pre>

<hr />

<p>There are two ways to interpret this problem, resulting in very different solutions. A straight reading of the challenge, with no additional constraints, means our script can simply read its own source file and print it. For example:</p>

<pre><code class="language-perl">open my $fh, '&lt;', __FILE__; # or $0
print &lt;$fh&gt;;
</code></pre>

<p>Most people did something similar to this, and these solutions certainly pass the challenge! However, a few of us noticed that this challenge sounded an awful lot like a <a href="https://en.wikipedia.org/wiki/Quine_(computing)">quine</a>, so we took it a step further for (in my case) the fun of it. Quines are computer programs that not only produce a copy of their own source code, but they also have the additional constraint of <em>taking no input,</em> meaning, reading your own source code is not allowed.</p>

<h2 id="adam-russell-1">Adam Russell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/adam-russell/perl/ch-2.pl">Adam Russell&rsquo;s solution</a> is a proper quine, because it does not use any input (the last blank line is required):</p>

<pre><code class="language-perl">print&lt;&lt;''x2,&quot;\n&quot;
print&lt;&lt;''x2,&quot;\n&quot;

</code></pre>

<p>I&rsquo;ve previously seen this quine <a href="http://www.nyx.net/~gthompso/self_perl.txt">attributed to Robin Houston</a> some years ago, and it&rsquo;s long been one of my favourites, due to the clever use of heredocs.</p>

<p><strong>Blog</strong> › <a href="https://adamcrussell.livejournal.com/15213.html">Perl Fun</a></p>

<h2 id="alicia-bielsa-1">Alicia Bielsa</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/alicia-bielsa/perl/ch-2.pl">Alicia Bielsa&rsquo;s solution</a> uses <code>$0</code> to obtain the filename.</p>

<pre><code class="language-perl">open (my $fh_file , '&lt;', $0 ) or die &quot;Error reading file&quot;;
while (my $line = &lt;$fh_file&gt;) {
     print $line;
}
close ($fh_file);
</code></pre>

<p>Using the three-argument <code>open</code> is <a href="http://modernperlbooks.com/mt/2010/04/three-arg-open-migrating-to-modern-perl.html">always a good practice</a>, so I&rsquo;m glad to see Alicia use it here. It would, after all, be a terrible quine if your script was named <code>rm -rf . |</code> and used the two-argument <code>open</code> (please don&rsquo;t try this.)</p>

<h2 id="andrezgz-1">Andrezgz</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/andrezgz/perl/ch-2.pl">Andrezgz&rsquo;s solution</a> is another proper quine. The whole thing is nearly 100 lines long, but it&rsquo;s worth seeing, so I&rsquo;ll trim it down a bit (mostly removing comments) and show what&rsquo;s left, here. This should still be a quine, after my trimming:</p>

<pre><code class="language-perl">use v5.10;

my @s = (
q&amp;&amp;,
q&amp;say &lt;&lt;'EOT';&amp;,
q&amp;use v5.10;&amp;,
q&amp;EOT&amp;,
q&amp;&amp;,
q&amp;say 'my @s = (';&amp;,
q&amp;foreach my $line (@s) {&amp;,
q&amp;    say 'q'.chr(38).$line.chr(38).','&amp;,
q&amp;}&amp;,
q&amp;say ');';&amp;,
q&amp;&amp;,
q&amp;foreach my $line (@s) {&amp;,
q&amp;    say $line&amp;,
q&amp;}&amp;,
q&amp;&amp;,
q&amp;say &lt;&lt;'EOT';&amp;,
q&amp;__END__&amp;,
q&amp;&amp;,
q&amp;./ch-2.pl | diff - ch-2.pl&amp;,
q&amp;EOT&amp;,
q&amp;&amp;,
);

say &lt;&lt;'EOT';
use v5.10;
EOT

say 'my @s = (';
foreach my $line (@s) {
    say 'q'.chr(38).$line.chr(38).','
}
say ');';

foreach my $line (@s) {
    say $line
}

say &lt;&lt;'EOT';
__END__

./ch-2.pl | diff - ch-2.pl
EOT

__END__

./ch-2.pl | diff - ch-2.pl

</code></pre>

<p>The solution works by using various quoting operators to embed a copy of the source code within the code itself, which is a common yet powerful way to generate a quine.</p>

<h2 id="arne-sommer-1">Arne Sommer</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/arne-sommer/perl/ch-2.pl">Arne Sommer&rsquo;s solution</a> uses <code>$0</code> to get the script filename, and outputs it line by line:</p>

<pre><code class="language-perl">my $file = $0;

if (open(my $fh, $file)) {
    while (my $row = &lt;$fh&gt;) {
        print $row;
    }
    close $fh;
}
</code></pre>

<p>Arne also submitted <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/arne-sommer/perl/ch-2a.pl">another solution</a>, even more elegant than the first, which uses <a href="https://metacpan.org/pod/File::Slurper"><code>File::Slurper</code></a> to read <code>$0</code> instead:</p>

<pre><code class="language-perl">use File::Slurper 'read_text';
print read_text($0);
</code></pre>

<p>By the way, if you haven&rsquo;t already switched over to <code>File::Slurper</code> from <code>File::Slurp</code>, I encourage you to do so, as <code>::Slurper</code> fixes a lot of the problems in <code>::Slurp</code>, especially around the API and handling of encoding.</p>

<p><strong>Blog</strong> › <a href="https://raku-musings.com/square-dumper.html">Square Dumper with Raku</a></p>

<h2 id="burkhard-nickels-1">Burkhard Nickels</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/perl/ch-2.pl">Burkhard Nickels&rsquo; solution</a> is a source code printer that has gone through some serious research and development! It not only prints its own source code, but it can print the source code of any file. And that&rsquo;s not all: it can also highlight its own syntax with <a href="https://metacpan.org/pod/Text::VimColor"><code>Text::VimColor</code></a>, and even render HTML output if desired. It comes with full internal and <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/perl/ch-2.pod">external</a> documentation, too.</p>

<p>I won&rsquo;t quote the full source here, but I will share a few key parts. Here is the source code reader and argument processor:</p>

<pre><code class="language-perl">if($ARGV[0] and $ARGV[0] eq &quot;help&quot;) {
    ... # Full help text is here
}
elsif($ARGV[0] and $ARGV[0] eq &quot;high&quot;) {
    syntax_high($0,$ARGV[1]);
}
elsif($ARGV[0]) {
    syntax_high(@ARGV);
}
else {
    open(IN,$0) or die &quot;Cant open $0\n&quot;;
    while(&lt;IN&gt;) { print; }
    close IN;
}
</code></pre>

<p>As you can see, in all cases, the source code is read from <code>$0</code>, as we&rsquo;ve seen with other solutions.</p>

<p>The syntax highlighting component (in the sub <code>syntax_high()</code>) shows just how easy it is to get Vim syntax highlighting in HTML using <code>Text::VimColor</code>:</p>

<pre><code class="language-perl">    my $syntax = Text::VimColor-&gt;new(
        file =&gt; $file,
        filetype =&gt; 'perl',
        html_full_page =&gt; $full,
    );
    my $html = $syntax-&gt;html;
</code></pre>

<p>(Getting ANSI output instead would simply look like <code>my $ansi = $syntax-&gt;ansi</code>, according to the documentation.)</p>

<p>Burkhard also does a partial HTML parse with <code>split</code> to insert his own line numbering, because the <code>Text::VimColor</code> line numbering wasn&rsquo;t working for him.</p>

<p>I always like to see solutions like this, that go far above and beyond the challenge, as there is almost guaranteed to be something interesting or unexpected.</p>

<h3 id="python-1">Python</h3>

<p>Burkhard submitted a <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/python/ch-2.py">Python solution</a> for challenge #2 as well, which uses <code>__file__</code> to get the script&rsquo;s filename and then reads from that:</p>

<pre><code class="language-python">fh = open(__file__);
for line in fh:
    print(line),

fh.close
</code></pre>

<p><strong>Blog</strong> › <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/perl/ch-2.pod">Source Dumper</a></p>

<h2 id="colin-crain-1">Colin Crain</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/colin-crain/perl/ch-2.pl">Colin Crain&rsquo;s solution</a> reads the source code from <code>$0</code>, and prints it out, along with an observation about sections we&rsquo;d not normally think of as code, such as the <code>__DATA__</code> section:</p>

<pre><code class="language-perl">local $/ = undef;
open (my $fh, &quot;&lt;&quot;, $0) or die &quot;can't open this script thats running this code to read: $0 : $!&quot;;
print &lt;$fh&gt;;

__DATA__

even prints the data section, see?
</code></pre>

<h2 id="cristina-heredia">Cristina Heredia</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/cristian-heredia/perl/ch-2.pl">Cristina Heredia&rsquo;s solution</a> uses a call to <code>system</code> to run <a href="https://linux.die.net/man/1/cat">cat(1)</a> to print the contents:</p>

<pre><code class="language-perl">#Name of the script
my $program = 'ch-2.pl';
#Execute an unix command
system(&quot;cat $program&quot;);
</code></pre>

<p>Cristina opted to hard-code the name in <code>$program</code>. While this of course means the script can&rsquo;t be renamed or run from a different directory, it does mean that the single-string call to <code>system</code> is safe from spaces and metacharacters in the filename, since <code>$program</code> is trusted.</p>

<p>The POSIX-only solution is fine by me. My only suggestion would be to switch to the <code>system PROGRAM LIST</code> form. The single-argument form (above) won&rsquo;t work (and in fact could be vulnerable to abuse) if the script or given pathname contain spaces or shell metacharacters. This is better:</p>

<pre><code class="language-perl">system cat =&gt; $0
</code></pre>

<p>You could even use <code>exec</code> here, as there is no need to ever regain control after <code>cat</code> is finished:</p>

<pre><code class="language-perl">exec cat =&gt; $0
</code></pre>

<h2 id="dave-cross-1">Dave Cross</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/dave-cross/perl/ch-2.pl">Dave Cross&rsquo; solution</a> exploits the fact that the <code>DATA</code> filehandle is already opened and pointed at the start of the <code>__DATA__</code> block in the script (if the script has one), but you are still free to access the contents of the entire script, if you set the filehandle&rsquo;s position with <code>seek</code>:</p>

<pre><code class="language-perl">seek DATA, 0, 0;
print while &lt;DATA&gt;;
__END__
</code></pre>

<h2 id="dave-jacoby-1">Dave Jacoby</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/dave-jacoby/perl/ch-2.pl">Dave Jacoby&rsquo;s solution</a> uses <a href="https://perldoc.perl.org/Cwd.html"><code>Cwd</code></a>&rsquo;s <code>abs_path</code> function to get the absolute path of the script first:</p>

<pre><code class="language-perl">use Cwd qw{abs_path};

my $file = abs_path($0);
if ( -f $file &amp;&amp; open my $fh, '&lt;', $file ) {
    print join '', &lt;$fh&gt;;
}
</code></pre>

<p>From there, Dave does some error checking and uses the three-argument <code>open</code>, which is always a good idea. He prints the contents of the file with <code>join '', &lt;$fh&gt;</code>, which slurps the entire contents into a list which is then fed to <code>join</code>.</p>

<p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/01/29/challenge-45-cyphers-and-quines.html">Challenge 45: Cyphers and Quines</a></p>

<h2 id="duane-powell-1">Duane Powell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/duane-powell/perl/ch-2.pl">Duane Powell&rsquo;s solution</a> also makes a <code>system</code> call to <a href="https://linux.die.net/man/1/cat">cat(1)</a> to print the contents:</p>

<pre><code class="language-perl">system(&quot;cat $0&quot;);
</code></pre>

<p>The same comments I made to Cristina&rsquo;s use of the single-argument <code>system</code> apply here; <code>system cat =&gt; $0</code> is preferable.</p>

<h2 id="duncan-c-white-1">Duncan C. White</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/duncan-c-white/perl/ch-2.pl">Duncan C. White&rsquo;s solution</a> uses <code>$0</code> to obtain the script&rsquo;s filename, and loops through the lines:</p>

<pre><code class="language-perl">open( my $fh, '&lt;', $0 ) || die &quot;can't read $0\n&quot;;
while( &lt;$fh&gt; )
{
    chomp;
    say;
}
</code></pre>

<h2 id="e-choroba-1">E. Choroba</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/e-choroba/perl/ch-2.pl">E. Choroba&rsquo;s solution</a> is another Perl hacker who submitted a full quine:</p>

<pre><code class="language-perl">$_=q!print'$_=q*'.$_.'*;';s/\52/\41/g;print!;print'$_=q!'.$_.'!;';s/\52/\41/g;print
</code></pre>

<p>This one again uses the trick of quoting operators to embed a copy of the source, and munging those quoting characters so they are escaped or output as needed. You might think <code>tr/*/!/</code> would work, but it would transmute its own arguments in the quoted code, which is why the character codes in <code>s/\52/\42/g</code> are necessary.</p>

<p>According to Choroba&rsquo;s blog, this is a quine he came up with, entirely of his own invention, when he started programming Perl, and has tweaked it over the years into the version you see now.</p>

<p>Covering all the bases, he submitted a file reading version as well:</p>

<pre><code class="language-perl">seek *DATA, 0, 0;
print &lt;DATA&gt;
__DATA__
</code></pre>

<p>This one uses the <code>DATA</code> filehandle in a similar way as we saw with Dave Cross&rsquo; solution, above.</p>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/01/perl-weekly-challenge-045-square-secret-code-source-dumper.html">Perl Weekly Challenge 045: Square Secret Code &amp; Source Dumper</a></p>

<h2 id="jaldhar-h-vyas-1">Jaldhar H. Vyas</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/jaldhar-h-vyas/perl/ch-2.pl">Jaldhar H. Vyas&rsquo; solution</a> reads its own source file in slurpy fashion, and uses <a href="https://perldoc.perl.org/English.html"><code>English</code></a> to aid comprehension:</p>

<pre><code class="language-perl">use English qw/ -no_match_vars /;

open my $fh, '&lt;', $PROGRAM_NAME or die &quot;$OS_ERROR\n&quot;;
local $RS = undef;
print &lt;$fh&gt;;
</code></pre>

<p><code>English</code>, a core module, adds plain English aliases for most of Perl&rsquo;s punctuation variables, and manages to use three of them in just two lines of code:</p>

<ul>
<li>› <code>$PROGRAM_NAME</code> is <code>$0</code>, the script&rsquo;s filename</li>
<li>› <code>$OS_ERROR</code> is <code>$!</code>, <a href="http://man7.org/linux/man-pages/man3/errno.3.html">errno</a> error value (or description)</li>
<li>› <code>$RS</code> is <code>$/</code>, the input record separator, usually newline</li>
</ul>

<p><strong>Blog</strong> › <a href="https://www.braincells.com/perl/2020/02/perl_weekly_challenge_week_45.html">Perl Weekly Challenge - Week 45</a></p>

<h2 id="javier-luque-1">Javier Luque</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/javier-luque/perl/ch-2.pl">Javier Luque&rsquo;s solution</a> reads the file in <code>$0</code>, with UTF-8 encoding for good measure:</p>

<pre><code class="language-perl">open(my $fh, '&lt;:encoding(UTF-8)', $0) || die &quot;$@&quot;;
while (my $line = &lt;$fh&gt;) {
    print $line;
};
</code></pre>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/01/30/perl-weekly-challenge-045/">PERL WEEKLY CHALLENGE – 045 – Perl Weekly Challenge</a></p>

<h2 id="laurent-rosenfeld-1">Laurent Rosenfeld</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/laurent-rosenfeld/perl/ch-2.pl">Laurent Rosenfeld&rsquo;s solution</a> is another example of reading one&rsquo;s own source file via <code>$0</code>:</p>

<pre><code class="language-perl">my $progr = &quot;./$0&quot;;
open my $IN, &quot;&lt;&quot;, $progr or die &quot;Unable to open $progr $!&quot;;
print while &lt;$IN&gt;;
close $IN;
</code></pre>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-45-square-secret-code-and-source-dumper.html">Perl Weekly Challenge 45: Square Secret Code and Source Dumper</a></p>

<h2 id="maxim-kolodyazhny-1">Maxim Kolodyazhny</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/maxim-kolodyazhny/perl/ch-2.pl">Maxim Kolodyazhny&rsquo;s solution</a> reads its own source file. You know those two-argument <code>open</code> calls I&rsquo;ve been talking about? How about a one-argument <code>open</code>!</p>

<pre><code class="language-perl">use strict;
use warnings;

open 0 and print &lt;0&gt;;
</code></pre>

<p>This might require a bit of explanation if you&rsquo;ve never encountered a one-argument <code>open</code>. First, it&rsquo;s important to know that there is no special magic with &ldquo;0&rdquo; going on, here. Normally <code>open</code> requires at least two arguments. The two-argument <code>open</code> expects a filehandle, and an expression containing the filename.</p>

<p>When <code>open</code> is given just <em>one</em> argument, though, Perl takes the filename from the package scalar with the same name as the filehandle. In this case that scalar is <code>$0</code>, which is of course the script filename. After that, the <code>print &lt;0&gt;</code> part is just a normal read from the filehandle glob named &ldquo;0&rdquo; created with <code>open</code>.</p>

<p>Don&rsquo;t believe this works as I&rsquo;ve described it? Try it with a different name:</p>

<pre><code class="language-perl">$PROG = &quot;$0&quot;;
open PROG and print &lt;PROG&gt;
</code></pre>

<p>Then make the first line a lexical: <code>my $PROG = &quot;$0&quot;</code> and now it doesn&rsquo;t work. In fact, that&rsquo;s part of the reason we avoid bareword scalars these days; they <em>only</em> work with package globals, so it&rsquo;s not possible to give them lexical scope.</p>

<h2 id="nazareno-delucca-1">Nazareno Delucca</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ndelucca/perl/ch-2.pl">Nazareno Delucca&rsquo;s solution</a> uses the <code>__FILE__</code> function introduced in Perl 5.16 to get the filename:</p>

<pre><code class="language-perl">open(my $fh, &quot;&lt;&quot;, __FILE__) || die &quot;Couldn't open $0 for reading because: $! &quot;;
print &lt;$fh&gt;;
close($fh);
</code></pre>

<h2 id="rage311-1">Rage311</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/rage311/perl/ch-2.pl">Rage311&rsquo;s solution</a> reads the file in <code>$0</code>, complete with error handling and the three-argument <code>open</code>:</p>

<pre><code class="language-perl">die &quot;Unable to open file: $!&quot; unless
  open my $fh, '&lt;', $0;
print while &lt;$fh&gt;;
</code></pre>

<h2 id="roger-bell-west-1">Roger Bell West</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/roger-bell-west/perl/ch-2.pl">Roger Bell West&rsquo;s solution</a> eschews all modern Perl contrivances for the following concise solution:</p>

<pre><code class="language-perl">open F,$0;
print &lt;F&gt;;
</code></pre>

<h2 id="ruben-westerberg-1">Ruben Westerberg</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ruben-westerberg/perl/ch-2.pl">Ruben Westerberg&rsquo;s solution</a> shows that those modern features can look pretty, too:</p>

<pre><code class="language-perl">open my $f,&quot;&lt;&quot;,$0;
print $_ for ( &lt;$f&gt; );
</code></pre>

<h2 id="ryan-thompson-1">Ryan Thompson</h2>

<p>I submitted three solutions this week, to showcase three different and progressively more difficult ways this challenge could be solved.</p>

<p>First up—and I can&rsquo;t believe <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ryan-thompson/perl/ch-2a.pl">I actually committed this</a>—an <strong>empty file</strong> works as a valid script. This arguably meets the letter of the challenge, but probably not the spirit. All serious definitions of quines regard this as cheating, too.</p>

<p>So the next best thing is <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ryan-thompson/perl/ch-2.pl">my own version</a> of the source file reader:</p>

<pre><code class="language-perl">open my $fh, '&lt;', __FILE__;
print do { undef $/; &lt;$fh&gt; };
</code></pre>

<p>I opted to slurp <code>&lt;$fh&gt;</code> into a string, although I really didn&rsquo;t need to.</p>

<p>But my third solution, finally, is a real quine. The source code is not really human readable, but you can <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ryan-thompson/perl/ch-2b.pl">see it here</a>. It was, as it turns out, human <em>writeable,</em> although I wouldn&rsquo;t recommend replicating my methods.</p>

<p>Its output, when fed to a terminal, is displayed just a bit differently:</p>

<p><img src="http://www.ry.ca/wp-content/uploads/2020/02/image.png" alt="I &lt;3 Perl" /></p>

<p>When fed to <code>diff</code>, <code>diff</code> will happily compare the output—including all of the ANSI escape codes—and report no differences.</p>

<p>For a more human-readable introduction to what I did, I started with the following quine:</p>

<pre><code class="language-perl">$_=q&lt;&quot;ANSI ART HERE&quot;;print&quot;\$_=q&lt;$_&gt;;eval\n&quot;&gt;;eval
</code></pre>

<p>As discussed in my blog, I do not claim to have invented this quine, as it&rsquo;s pretty difficult to come up with a completely novel quine after all these years. Similar versions are rather ubiquitious in Perl quine discussions, due to how powerful the quoting operators are in Perl.</p>

<p>I then got to work with my amazing ANSI art skills, at the position shown. Maybe I could get rich selling signed prints.</p>

<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/02/quine/">Quine</a></p>

<p>## Saif Ahmed</p>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/saiftynet/perl/ch-2.pl">Saif Ahmed&rsquo;s solution</a> is another file read solution, with UTF-8 encoding:</p>

<pre><code class="language-perl">open (my $fh, '&lt;:encoding(UTF-8)', $0 ) ;
print while(&lt;$fh&gt;);
</code></pre>

<h2 id="ulrich-rieke-1">Ulrich Rieke</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/ulrich-rieke/perl/ch-2.pl">Ulrich Rieke&rsquo;s solution</a> reads the file via a filehandle glob:</p>

<pre><code class="language-perl">open (FH , &quot;&lt; $0&quot; ) or die &quot;Can't open file $0!\n&quot; ;
while ( &lt;FH&gt; ) {
  print ;
}
close (FH) ;
</code></pre>

<h2 id="wanderdoc-1">Wanderdoc</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/wanderdoc/perl/ch-2.pl">Wanderdoc&rsquo;s solution</a> reads <code>$0</code>:</p>

<pre><code class="language-perl">open my $in, &quot;&lt;&quot;, $0 or die &quot;$!&quot;;
for ( &lt;$in&gt; ) {print $_;}
</code></pre>

<hr />

<p>And that&rsquo;s it! Although a lot of these solutions were quite similar, it&rsquo;s amazing how much variation in style one can achieve in just two or three lines.</p>

<hr />

<hr />

<h2 id="blogs">SEE ALSO</h2>

<h3 id="blogs-this-week">Blogs this week:</h3>

<p>Great to see more people blogging again this week! I always enjoy reading them.</p>

<p><strong>Adam Russell</strong> › <a href="https://adamcrussell.livejournal.com/15213.html">Perl Fun</a></p>

<p><strong>Arne Sommer</strong> › <a href="https://raku-musings.com/square-dumper.html">Square Dumper with Raku</a></p>

<p><strong>Burkhard Nickels</strong> › <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/perl/ch-1.pod">Square Secret Code</a> | <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-045/burkhard-nickels/perl/ch-2.pod">Source Dumper</a></p>

<p><strong>Dave Jacoby</strong> › <a href="https://jacoby.github.io/2020/01/29/challenge-45-cyphers-and-quines.html">Challenge 45: Cyphers and Quines</a></p>

<p><strong>E. Choroba</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/01/perl-weekly-challenge-045-square-secret-code-source-dumper.html">Square Secret Code &amp; Source Dumper</a></p>

<p><strong>Jaldhar H. Vyas</strong> › <a href="https://www.braincells.com/perl/2020/02/perl_weekly_challenge_week_45.html">Perl Weekly Challenge Week 45</a></p>

<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/01/30/perl-weekly-challenge-045/">045 – Perl Weekly Challenge</a></p>

<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-45-square-secret-code-and-source-dumper.html">Square Secret Code and Source Dumper</a></p>

<p><strong>Luca Ferrari</strong> › <a href="https://fluca1978.github.io/2020/01/29/PerlWeeklyChallenge45.html">Encoded messages and self-source-code-printing</a></p>

<p><strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/01/square-secret-code/">Square Secret Code</a> | <a href="http://www.ry.ca/2020/02/quine/">Quine</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

