<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Perl Weekly Review: Challenge - #046">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.55.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Perl Weekly Review: Challenge - #046</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Perl Weekly Review: Challenge - #046</h2>
                    <div class="portfolio-meta">
                        <span>Monday, Feb 17, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/flip_500.png">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    

<p>Continues from <a href="/blog/review-challenge-045/">previous week</a>.</p>

<p>Welcome to the Perl review for Week 046 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-046/">original tasks</a> and <a href="/blog/recap-challenge-046/">recap</a> of the weekly challenge.</p>

<h2 id="getting-in-touch">Getting in Touch</h2>

<p><a href="mailto:rjt@cpan.org"><img src="http://ry.ca/misc/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>

<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="http://ry.ca/misc/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>

<p><a href="https://twitter.com/perlwchallenge"><img src="http://ry.ca/misc/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>

<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<h3 id="task-1-cryptic-message-task1"><a href="#task1">Task 1 › Cryptic Message</a></h3>

<p>[ <a href="#alicia-bielsa1">Alicia Bielsa</a>  | <a href="#andrezgz1">Andrezgz</a>  | <a href="#athanasius1">Athanasius</a>  | <a href="#cheok-yin-fung1">Cheok-Yin Fung</a>  | <a href="#cristian-heredia1">Cristina Heredia</a>  | <a href="#dave-jacoby1">Dave Jacoby</a>  | <a href="#duane-powell1">Duane Powell</a>  | <a href="#duncan-c-white1">Duncan C. White</a>  | <a href="#e-choroba1">E. Choroba</a>  | <a href="#jaldhar-h-vyas1">Jaldhar H. Vyas</a>  | <a href="#javier-luque1">Javier Luque</a>  | <a href="#laurent-rosenfeld1">Laurent Rosenfeld</a>  | <a href="#mohammad-anwar1">Mohammad S Anwar</a>  | <a href="#rage3111">Rage311</a>  | <a href="#roger-bell-west1">Roger Bell West</a>  | <a href="#ruben-westerberg1">Ruben Westerberg</a>  | <a href="#ryan-thompson1">Ryan Thompson</a>  | <a href="#saiftynet1">Saif Ahmed</a>  | <a href="#ulrich-rieke1">Ulrich Rieke</a>  | <a href="#user-person1">User Person</a>  | <a href="#wanderdoc1">Wanderdoc</a>  ]</p>

<h3 id="task-2-500-doors-task2"><a href="#task2">Task 2 › 500 Doors</a></h3>

<p>[ <a href="#alicia-bielsa2">Alicia Bielsa</a>  | <a href="#andrezgz2">Andrezgz</a>  | <a href="#athanasius2">Athanasius</a>  | <a href="#cheok-yin-fung2">Cheok-Yin Fung</a>  | <a href="#colin-crain2">Colin Crain</a>  | <a href="#cristian-heredia2">Cristina Heredia</a>  | <a href="#dave-jacoby2">Dave Jacoby</a>  | <a href="#duane-powell2">Duane Powell</a>  | <a href="#duncan-c-white2">Duncan C. White</a>  | <a href="#e-choroba2">E. Choroba</a>  | <a href="#jaldhar-h-vyas2">Jaldhar H. Vyas</a>  | <a href="#javier-luque2">Javier Luque</a>  | <a href="#laurent-rosenfeld2">Laurent Rosenfeld</a>  | <a href="#mohammad-anwar2">Mohammad S Anwar</a> | <a href="#peter-scott2">Peter Scott</a> | <a href="#rage3112">Rage311</a>  | <a href="#roger-bell-west2">Roger Bell West</a>  | <a href="#ruben-westerberg2">Ruben Westerberg</a>  | <a href="#ryan-thompson2">Ryan Thompson</a>  | <a href="#saiftynet2">Saif Ahmed</a>  | <a href="#ulrich-rieke2">Ulrich Rieke</a>  | <a href="#user-person2">User Person</a>  | <a href="#wanderdoc2">Wanderdoc</a>  ]</p>

<h3 id="blogs-blogs"><a href="#blogs">Blogs</a></h3>

<hr />

<hr />

<h1 id="task1">Task #1 - Cryptic Message</h1>

<p>This task had us resolving &ldquo;unreliable transmissions&rdquo; that were sent repeatedly, each time with errors in different locations in the string, such as this one:</p>

<pre><code>P + 2 l ! a t o
1 e 8 0 R $ 4 u
5 - r ] + a &gt; /
P x w l b 3 k \
2 e 3 5 R 8 y u
&lt; ! r ^ ( ) k 0
</code></pre>

<p>That spells <code>PerlRaku</code>, which you can arrive at by noticing that only one character in each column will be repeated.</p>

<hr />

<h2 id="my-general-observations">My general observations</h2>

<p>Both example ciphers show that each plaintext character appears exactly twice in each column, and the other characters appear exactly once. Naturally, some hackers relied on this and printed all characters that appeared twice. Some hackers took a more permissive or general interpretation, and calculated the frequency of each character, printing whichever character appeared most often in each column.</p>

<hr />

<h2 id="alicia-bielsa1">Alicia Bielsa</h2>

<p><a href="/challenge-046/alicia-bielsa/perl/ch-1.pl">Alicia Bielsa&rsquo;s solution</a> searches an array of arrays (AoA) for characters that have appeared twice.</p>

<pre><code class="language-perl">my @aCharactersRepeated = ();
my $lengthMessage = scalar(@aMessage1);
my @aAllMessages = (@aMessage1, @aMessage2 ,@aMessage3, @aMessage4, @aMessage5 ,@aMessage6);
my %hCharacters = ();
foreach my $indexAllMesages (0..$#aAllMessages){
    my $indexMessage =  $indexAllMesages % $lengthMessage;
    my $currentCharacter = $aAllMessages[$indexAllMesages];
    unless (exists($hCharacters{$indexMessage})){
        $hCharacters{$indexMessage} =();
    }
    unless (exists($hCharacters{$indexMessage}{$currentCharacter})){
        $hCharacters{$indexMessage}{$currentCharacter} = 0 ;
    }
    $hCharacters{$indexMessage}{$currentCharacter} ++;
    if ($hCharacters{$indexMessage}{$currentCharacter} == 2 ){
        $aCharactersRepeated[$indexMessage] = $currentCharacter;
    }
}
print &quot;Decrypted Message:&quot;;
foreach my $character (@aCharactersRepeated){
    print &quot;$character&quot;;
}
print &quot;\n&quot;;
</code></pre>

<p>Alicia uses <code>%hCharacters</code> to store her frequency map, where <code>$hCharacters{A}{$indexMessage} == $N</code> if <code>'A'</code> appears <code>$N</code> times in column <code>$indexMessage</code>.</p>

<h2 id="andrezgz1">Andrezgz</h2>

<p><a href="/challenge-046/andrezgz/perl/ch-1.pl">Andrezgz&rsquo;s solution</a> stores the messages as an AoA and then decrypts it with the following nested loops:</p>

<pre><code class="language-perl">my $msg_len = scalar @{$msg-&gt;[0]};
my @decrypted = ('?') x $msg_len;
for my $i (1 .. @{$msg}-1) {
    for my $j (0 .. $i-1) {
        for (0 .. $msg_len-1) {
            $decrypted[$_] = $msg-&gt;[$i]-&gt;[$_] if ($msg-&gt;[$i]-&gt;[$_] eq $msg-&gt;[$j]-&gt;[$_]);
        }
    }
    print @decrypted,&quot;\n&quot;;
}
</code></pre>

<p>The way in which the answer is built up and printed at each stage as more columns are &ldquo;solved&rdquo; is interesting, reminding me vaguely of <a href="https://en.wikipedia.org/wiki/Matrix_digital_rain">Matrix code</a>:</p>

<pre><code>????????
?????a??
P??l?a??
Pe?lRa?u
PerlRaku
</code></pre>

<h2 id="athanasius1">Athanasius</h2>

<p><a href="/challenge-046/athanasius/perl/ch-1.pl">Athanasius&rsquo; solution</a> includes a convenience function to turn a string input with newlines into an AoA:</p>

<pre><code class="language-perl">my $message = 'P + 2 l ! a t o
               1 e 8 0 R $ 4 u
               5 - r ] + a &gt; /
               P x w l b 3 k \
               2 e 3 5 R 8 y u
               &lt; ! r ^ ( ) k 0';
my $array   = make_array($message);

sub make_array {
    my  ($message) = @_;
    my   @array;
    push @array, [ grep { length } split /\s+/, $_ ] for split /\n/, $message;
    return \@array;
}
</code></pre>

<p>Athanasius then loops to generate a full frequency distribution of letters for each column, then <code>sort</code>s them numerically to find the most frequent:</p>

<pre><code class="language-perl">my $decrypt = '';
for my $char (0 .. $array-&gt;[0]-&gt;$#*) {
    my %opts;
     ++$opts{ $array-&gt;[$_][$char] } for 0 .. $#$array;
    $decrypt .= (sort { $opts{$b} &lt;=&gt; $opts{$a} } keys %opts)[0];
}
</code></pre>

<h2 id="cheok-yin-fung1">Cheok-Yin Fung</h2>

<p><a href="/challenge-046/cheok-yin-fung/perl/ch-1.pl">Cheok-Yin Fung&rsquo;s solution</a> handles the frequency analysis with an AoA which maps the column number <code>$j</code> and all ASCII ordinals from 33..126, to the number of times they appear:</p>

<pre><code class="language-perl">for my $i (0..$numberoflines-1) {
    for my $j (0..$msglength-1) {
        for my $d (33..126) {
            $charoccurence[$j][$d] = 0;  # ref to the ASCII table; #33 is ! and #126 is ~
        }
    }
}
</code></pre>

<p>(The row-based <code>$i</code> is not used, here.)</p>

<p>The message, a string, then has horizontal whitespace removed before being split into lines, and then characters. The innermost loop compares the current character to each of 33..126, and increments <code>$charoccurence[$j][$d]</code> if it matches:</p>

<pre><code class="language-perl"># &quot; =~ s/\s//g &quot; isn't good becoz it removes new line characters
$msg =~ s/\h//g;
my @lines = split(&quot;\n&quot;, $msg);
for my $i (0..$numberoflines-1) {
    my  @str = split // , $lines[$i];
    for my $j (0..$msglength-1) {
        for my $d (33..126) {
            if (ord($str[$j]) == $d) {
            #             if ( $str[$j] eq chr($d)) {
            #     print chr($d);             #testing
                 $charoccurence[$j][$d]++;
             }
        }
    }
}
</code></pre>

<p>Cheok-Yin Fung could have replaced the inner <code>for my $d</code> loop with a single statement:</p>

<pre><code class="language-perl">$charoccurence[$j][ ord( $str[$j] ) ]++;
</code></pre>

<p>If range checking the ordinal is a concern, a simple conditional would suffice, but I would personally rather validate or filter the input instead, in that case.</p>

<h2 id="cristian-heredia1">Cristina Heredia</h2>

<p><a href="/challenge-046/cristian-heredia/perl/ch-1.pl">Cristina Heredia&rsquo;s solution</a> defines an array for each row:</p>

<pre><code class="language-perl">my @array1 = ('P',  '+',  '2',  'l',  '!',  'a',  't',  'o' );
my @array2 = ('1',  'e',  '8',  '0',  'R',  '$',  '4',  'u' );
my @array3 = ('5',  '-',  'r',  ']',  '+',  'a',  '&gt;',  '/' );
my @array4 = ('P',  'x',  'w',  'l',  'b',  '3',  'k',  '\\' );
my @array5 = ('2',  'e',  '3',  '5',  'R',  '8',  'y',  'u' );
my @array6 = ('&lt;',  '!',  'r',  '^',  '(',  ')',  'k',  '0' );
</code></pre>

<p>This is then combined into the linear <code>@arrayCharacter</code> by appending the <code>$i</code>th character from each <code>@array?</code>, in a loop:</p>

<pre><code class="language-perl">my @arrayCharacter;
print &quot;The message is: &quot;;
foreach (my $i = 0; $i &lt; @array1; $i++) {
    @arrayCharacter = ();
    push(@arrayCharacter, @array1[$i]);
    push(@arrayCharacter, @array2[$i]);
    push(@arrayCharacter, @array3[$i]);
    push(@arrayCharacter, @array4[$i]);
    push(@arrayCharacter, @array5[$i]);
    push(@arrayCharacter, @array6[$i]);
</code></pre>

<p>After that, Cristina loops through <code>@arrayCharacter</code> and <code>%count</code>s the frequency of each character, and then removes all pairs where the count is 1, effectively leaving the correct character for the column:</p>

<pre><code class="language-perl">    my %count;
    $count{$_}++ foreach @arrayCharacter;
    #removing the lonely strings
    while (my ($key, $value) = each(%count)) {
        if ($value == 1) {
            delete($count{$key});
        }
    }

    #output the counts
    while (my ($key, $value) = each(%count)) {
        print &quot;$key&quot;;
    }
}
</code></pre>

<p>The step of creating <code>@arrayCharacter</code> could be avoided by replacing the <code>push(@arrayCharacter, @array1[$i])</code> lines with <code>$count{$array1[$i]}++</code>. I might also prefer using an AoA instead of the six named arrays, so that the code could handle messages with any number of rows. Apart from these suggestions, however, Cristina&rsquo;s algorithm is sound and the code is easy to follow.</p>

<h2 id="dave-jacoby1">Dave Jacoby</h2>

<p><a href="/challenge-046/dave-jacoby/perl/ch-1.pl">Dave Jacoby&rsquo;s solution</a> accepts multi-line strings, and splits those into an AoA called <code>@ctext</code>:</p>

<pre><code class="language-perl">my @ctext = map { [ split /\s+/, $_ ] } grep { /\S/ } split m{\n}, $ctext;
</code></pre>

<p>From there, he loops through the columns (<code>$i</code>) and increments <code>%col</code> for the corresponding character in each row. After that, he sorts the keys in reverse numerical order and takes the first one (<code>$k</code>):</p>

<pre><code class="language-perl">for my $i ( 0 .. scalar $ctext[0]-&gt;@* - 1 ) {
    my %col;
    map { $col{ $_-&gt;[$i] }++ } @ctext;
    my ($k) = sort { $col{$b} &lt;=&gt; $col{$a} } keys %col;
    push @ptext, $k;
}
</code></pre>

<p>The final answer is then simply <code>join '', @ptext</code>.</p>

<h2 id="duane-powell1">Duane Powell</h2>

<p><a href="/challenge-046/duane-powell/perl/ch-1.pl">Duane Powell&rsquo;s solution</a> takes the message as a string, splits it into lines, then characters, and increments a HoH (hash of hash) <code>$data</code> which maps a column <code>$p</code> and <code>$char</code> to its count:</p>

<pre><code class="language-perl">my $data = {};
foreach my $line (split(/\n/,$message)) {
    my $p = 1;
    foreach my $char (split(/ /,$line)) {
        $data-&gt;{$p++}{$char}++;
    }
}
</code></pre>

<p>Now a simple nested loop iterates over the columns (<code>$p</code>), and finds the char that occurs most frequently within that column, and prints it:</p>

<pre><code class="language-perl">foreach my $p (sort keys %{$data}) {
    my ($max,$out) = (0,'');
    foreach my $char (keys %{$data-&gt;{$p}}) {
        if ($data-&gt;{$p}{$char} &gt; $max) {
            $out = $char;
            $max = $data-&gt;{$p}{$char};
        }
    }
    print $out;
}
</code></pre>

<p>Duane&rsquo;s solution is decently compact, and very comprehensible.</p>

<h2 id="duncan-c-white1">Duncan C. White</h2>

<p><a href="/challenge-046/duncan-c-white/perl/ch-1.pl">Duncan C. White&rsquo;s solution</a> accepts a list of strings on the commandline. The solution is neatly divided into two parts. First up is the frequency collection, which builds up an AoH (array of hashes) in <code>@freq</code>:</p>

<pre><code class="language-perl">my @freq;    # array of bags
foreach my $msg (@ARGV) {
    my @letter = split( //, $msg );
    foreach my $i (0..$#letter) {
        $freq[$i] //= {};
        $freq[$i]{$letter[$i]}++;
    }
}
</code></pre>

<p>Each line is split into characters, and then Duncan loops through the resulting array, incrementing <code>$freq[$i]{_}</code> for each column and character.</p>

<p>Next up is the <code>$result</code> builder, which finds the character in each column with the maximum frequency:</p>

<pre><code class="language-perl">my $result = &quot;&quot;;
foreach my $i (0..$#freq) {
    my $max = -1;
    my $let = '';
    my $href = $freq[$i];
    while( my($l,$f) = each %$href ) {
        if( $f &gt; $max ) {
            $max = $f;
            $let = $l;
        }
    }
    $result .= $let;
}
say $result;
</code></pre>

<h2 id="e-choroba1">E. Choroba</h2>

<p><a href="/challenge-046/e-choroba/perl/ch-1.pl">E. Choroba&rsquo;s solution</a> works with arrays of strings (rows):</p>

<pre><code class="language-perl">my @message_sets = (['Hxl4!', 'ce-lo', 'ze6lg', 'HWlvR', 'q9m#o'],
                    ['P+2l!ato', '1e80R$4u', '5-r]+a&gt;/', 'Pxwlb3k\\',
                     '2e35R8yu', '&lt;!r^()k0']);
</code></pre>

<p>Choroba&rsquo;s solution again uses an AoH to tally the frequency of each character in each column:</p>

<pre><code class="language-perl">my @frequency;
for my $message (@$messages) {
    ++$frequency[$_]{ substr $message, $_, 1 }
        for 0 .. length($message) - 1;
}
for my $position (@frequency) {
    my $max = max(values %$position);
    $position-&gt;{$_} == $max and print for keys %$position;
}
print &quot;\n&quot;;
</code></pre>

<p><a href="https://perldoc.perl.org/List/Util.html"><code>List::Util</code></a>&rsquo;s <code>max</code> helps to find the most frequent character.</p>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/02/perl-weekly-challenge-046-cryptic-message-is-the-room-open.html">Cryptic Message &amp; Is the Room Open?</a></p>

<h2 id="jaldhar-h-vyas1">Jaldhar H. Vyas</h2>

<p><a href="/challenge-046/jaldhar-h-vyas/perl/ch-1.pl">Jaldhar H. Vyas&rsquo; solution</a> accepts an AoA for input, and then starts with what amounts to a matrix transposition:</p>

<pre><code class="language-perl">my @rotated;
for my $i (0 .. scalar @message - 1) {
    for my $j (0 .. scalar @{$message[$i]} - 1) {
        push @{$rotated[$j]}, $message[$i][$j];
    }
}
</code></pre>

<p>Now that the columns are rows, each row can be sorted to aid in finding
duplicated characters (whitespace mine):</p>

<pre><code class="language-perl">say join q{},
     map { /(.)\1/; $1; }
     map { join q{}, sort @{$_}; } @rotated;
</code></pre>

<p>The sorted strings are then fed through the regexp <code>/(.)\1/</code> which is a capturing check for two of the same character in a row. <code>$1</code> is the character that was found.</p>

<p>Jaldhar&rsquo;s is a unique solution. Transposing the input makes the second part quite easy, using the highly optimized regexp engine to find the duplicated character.</p>

<h2 id="javier-luque1">Javier Luque</h2>

<p><a href="/challenge-046/javier-luque/perl/ch-1.pl">Javier Luque&rsquo;s solution</a> takes a multiline string, splits it, and then builds up a column-wise array:</p>

<pre><code class="language-perl"># Initialize the columns hash
my @column_hash;
my ($first_line) = split (&quot;\n&quot;, $message, 2);
my $length = length(join '', split (&quot; &quot;, $first_line));
$column_hash[$_] = {} for (0..$length-1);
# Parse the cryptic message
for my $line (split (&quot;\n&quot;, $message)) {
    my $i = 0;
    for my $char (split (&quot; &quot;, $line)) {
        $column_hash[$i++]-&gt;{$char}++;
    }
}
</code></pre>

<p>At this point, <code>@column_hash</code> contains character counts for each column. Next, Javier does a reverse numerical sort on each column, printing the first element, so that the most frequent characters are output.</p>

<pre><code class="language-perl"># Sort
for my $column (@column_hash) {
    my @sort =
        sort { $column-&gt;{$b} &lt;=&gt; $column-&gt;{$a} }
        keys %$column;
    print $sort[0];
}
</code></pre>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/04/perl-weekly-challenge-046/">046 – Perl Weekly Challenge</a></p>

<h2 id="laurent-rosenfeld1">Laurent Rosenfeld</h2>

<p><a href="/challenge-046/laurent-rosenfeld/perl/ch-1.pl">Laurent Rosenfeld&rsquo;s solution</a> accepts a string, splits it into an AoA, and then transposes it to obtain a column-wise matrix:</p>

<pre><code class="language-perl">my @AoA = map { [ split /\s+/, $_] } split /[\r\n]+/, $garbled;
my @transposed;
for my $i (0 .. $#AoA) {
  $transposed[$_][$i] = $AoA[$i][$_] for 0.. scalar @{$AoA[$i]} -1;
}
</code></pre>

<p>From there, Laurent loops to build a frequency table for each column, in <code>%counter</code>, and appends all characters with a count greater than 1 to the output message:</p>

<pre><code class="language-perl">my @msg = &quot;&quot;;
for my $line_ref (@transposed) {
    my %counter;
    $counter{$_}++ for @$line_ref;
    push @msg, grep { $counter{$_} &gt; 1 } keys %counter;
}
say @msg;
</code></pre>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-46-garbled-message-and-room-open.html">Garbled Message and Room Open</a></p>

<h2 id="mohammad-anwar1">Mohammad S Anwar</h2>

<p><strong>Mohammad,</strong> creator of the Perl Weekly Challenge, has finally entered the fray with a solution of his own! It may be a bit strange to welcome you to your own challenge, Mohammad, but I&rsquo;m going to do it anyway. Welcome. :-)</p>

<p><a href="/challenge-046/mohammad-anwar/perl/ch-1.pl">Mohammad S Anwar&rsquo;s solution</a> accepts an array of strings, and then splits each string on whitespace.  Maintaining a column counter, Mohammad increments the frequency table for each character in turn:</p>

<pre><code class="language-perl">my $table = [];
foreach my $message (@messages) {
    my $column = 0;
    foreach my $char (split /\s/, $message) {
        $table-&gt;[$column++]-&gt;{$char}++;
    }
}
</code></pre>

<p>Finally, all Mohammad needs to do is a reverse numerical sort on each column&rsquo;s frequency table, and print the key that appears most often.</p>

<pre><code class="language-perl">map { print [ sort { $_-&gt;{$b} &lt;=&gt; $_-&gt;{$a} } keys %$_ ]-&gt;[0] } @$table;
</code></pre>

<p>Mohammad&rsquo;s solution is concise without getting in the way of comprehension.</p>

<h2 id="rage3111">Rage311</h2>

<p><a href="/challenge-046/rage311/perl/ch-1.pl">Rage311&rsquo;s solution</a> starts with an AoA of the message, and then loops over it to build the frequency map:</p>

<pre><code class="language-perl">my @freq;
for my $col ( 0 .. $#{ $scrambled[0] } ) {
    $freq[$col]{ $scrambled[$_][$col] }++ for 0 .. $#scrambled;
}
</code></pre>

<p>Next, is the by now quite familiar max frequency loop to print the message:</p>

<pre><code class="language-perl">say join '', map { (sort { $_-&gt;{$b} &lt;=&gt; $_-&gt;{$a} } keys $_-&gt;%*)[0] } @freq;
</code></pre>

<p>Rage311 took full advantage of the AoA input, here, without having to deal with the intermediate <code>split</code> and storage that other solutions needed to use.</p>

<h2 id="roger-bell-west1">Roger Bell West</h2>

<p><a href="/challenge-046/roger-bell-west/perl/ch-1.pl">Roger Bell West&rsquo;s solution</a> takes input from STDIN, splitting each line on whiespace and adding it to the <code>@place</code> frequency map:</p>

<pre><code class="language-perl">my @place;
while (&lt;&gt;) {
    chomp;
    my @k=split / /,$_;
    map {$place[$_]{$k[$_]}++} (0..$#k);
}
</code></pre>

<p>Roger now loops through <code>@place</code>, one column at a time, printing the most frequent character:</p>

<pre><code class="language-perl">foreach my $h (@place) {
    my @v=values %{$h};
    my @k=keys %{$h};
    my @i=sort {$v[$b] &lt;=&gt; $v[$a]} (0..$#v);
    print $k[$i[0]];
}
print &quot;\n&quot;;
</code></pre>

<h2 id="ruben-westerberg1">Ruben Westerberg</h2>

<p><a href="/challenge-046/ruben-westerberg/perl/ch-1.pl">Ruben Westerberg&rsquo;s solution</a> accepts an AoA in <code>@inComming</code> and loops through it column-wise to build a frequency table for each column in turn, and push each character to the resulting <code>@decoded</code> array:</p>

<pre><code class="language-perl">my @decoded;
for my $c (0..@{$inComming[0]}-1) {
    my @col;
    my %count;
    for my $r (@inComming) {
        my $v=$$r[$c];
        $count{$v}++;
        if ($count{$v}==2) {
            push @decoded, $v;
            last;
        }
    }
}
print join &quot;&quot;, @decoded;
</code></pre>

<h2 id="ryan-thompson1">Ryan Thompson</h2>

<p><a href="/challenge-046/ryan-thompson/perl/ch-1.pl">My solution</a> uses a non-core (yet still extremely popular) module, <a href="https://metacpan.org/pod/List::MoreUtils"><code>List::MoreUtils</code></a> so I did not have to roll my own <code>frequency</code> method yet again. I also use core <code>List::Util</code>&rsquo;s <code>reduce</code>. I accept a list of strings as input:</p>

<pre><code class="language-perl">my @r = map y/ //dr, @_;
join '',   map { reduce { $_-&gt;{$a} &gt; $_-&gt;{$b} ? $a : $b } keys %$_ }
   reverse map { { frequency map chop, @r } } 1..length $r[0];
</code></pre>

<p>Reading from the bottom up, inside out, we loop once for each column, and the inner <code>map chop, @r</code> chops the last character off of each string in <code>@r</code>, and feeds them all to <code>frequency</code>. Here, <code>frequency(H c z H q)</code> would return <code>(H =&gt; 2, c =&gt; 1, q =&gt; 1, z =&gt; 1)</code>. The extra curly braces turn this into a hash ref. Since <code>chop</code> works from right to left, we must <code>reverse</code> the results.</p>

<p>Then, we <code>reduce</code> over the list of keys, pulling the key that has the maximum value, which is the most frequent character. Finally, we <code>join</code> together the results.</p>

<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/02/cryptic-message/">PWC 046 › Cryptic Message</a></p>

<h2 id="saiftynet1">Saif Ahmed</h2>

<p><a href="/challenge-046/saiftynet/perl/ch-1.pl">Saif Ahmed&rsquo;s solution</a> provides a decoder, but also some other code that explores these messages in more detail.  Here&rsquo;s the decoder, which accepts an ref to an array of strings:</p>

<pre><code class="language-perl">sub collector{
    my $messages=shift;                               # the list ref of messages
    my $result=&quot;&quot;;                                    # the result to return
    foreach my $col (0.. length $$messages[0]){       # for each poition
        my %collection=();                            # hash to store frequencies
        foreach my $message (@$messages){
            no warnings;                              # so that undef === 0
            $collection{(split //,$message)[$col]}++; # increment count when found
        }
</code></pre>

<p>As you can see, Saif stores the frequency map in <code>%collection</code>. He loops once for each <code>$col</code>umn, and then once for each line in <code>@messages</code>. He <code>split</code>s each message and pulls out the current column. There is some unnecessary splitting going on, but the impact is minor when the messages are short.</p>

<p>Next, Saif iterates through the <code>%collection</code> hash and finds the most common
character in each column, and appends that to <code>$result</code>:</p>

<pre><code class="language-perl">        my $max=0; my $commonest=&quot;&quot;;                  # now search and find commonest
        foreach my $char (keys %collection){
            if ($collection{$char} &gt; $max) {
                $max=$collection{$char};
                $commonest=$char;
            }
        }
        $result.=$commonest;                           # add the commonenst char to our result
    }
</code></pre>

<h3 id="extra-credit">Extra Credit</h3>

<p>Saif provided a couple of other routines. The first is a &ldquo;broken messager&rdquo;, which automates generating messages like the ones given in the challenge. You feed in a plaintext <code>$message</code>, and it munges the characters randomly:</p>

<pre><code class="language-perl">sub brokenMessager{
    my $message=shift;
    my $brokenness=0.4;                # likelihood of mangling
    my $allChars=&quot;&quot;;                   # a string of all printable chars
    $allChars .= chr for 1..255;       # First get all characters 0 to 255,
    $allChars =~s/[^!-~]//g;           # Then remove anything non printable
    my $result=&quot;&quot;;
    foreach my $char (split //,$message){    # split $message and random replace
        $result.=(rand()&gt;$brokenness)?(split //,$allChars)[rand()*length $allChars]:$char;
    }
    return $result;
}
</code></pre>

<p>Finally, Saif attempted a method of turning these messages into a form of reliable transport, by sending &ldquo;broken&rdquo; messages repeatedly until the decoded results are the same as the previous iteration. Saif acknowledges it is not 100% accurate. However, this provides an interesting glimpse into the practical aspects of trying to do error correction on such badly degraded messages:</p>

<pre><code class="language-perl">sub tryUntilStable{
    my $message=shift;
    my $tests=[];
    my $result=&quot;&quot;; my $guess=&quot;A guess&quot;;
    while ($result ne $guess){
        $result=$guess;
        my $messageReceived=brokenMessager($message);
        print $messageReceived,&quot;\n&quot;;
        sleep 0.5;
        push @$tests,$messageReceived;
        $guess=collector($tests);
    }
    print &quot;\nFinal result:- $result\n&quot;
}
</code></pre>

<h2 id="ulrich-rieke1">Ulrich Rieke</h2>

<p><a href="/challenge-046/ulrich-rieke/perl/ch-1.pl">Ulrich Rieke&rsquo;s solution</a> takes a list of strings and iterates column-wise with the help of <code>substr</code>:</p>

<pre><code class="language-perl">my $array = shift;
my $len   = length ${$array}[0];
my $decoded;
for my $i ( 0 .. $len - 1 ) {
    my %letterfrequency;
    foreach my $word ( @{$array} ) {
        $letterfrequency{ substr( $word, $i, 1 ) }++;
    }
    my @sorted = sort { $letterfrequency{$b} &lt;=&gt; $letterfrequency{$a} }
      keys %letterfrequency;
    $decoded .= $sorted[0];
}
</code></pre>

<p>Since he is iterating column-wise, Ulrich can build up the letter frequency and then append the most common character to the result, without storing any sort of multi-dimensional matrix.</p>

<h3 id="c-and-haskell">C++ and Haskell</h3>

<p>Ulrich also submitted solutions in <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-046/ulrich-rieke/cpp/ch-1.cpp">C++</a> and <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-046/ulrich-rieke/haskell/ch-1.hs">Haskell</a>.</p>

<h2 id="user-person1">User Person</h2>

<p><strong>User Person</strong> is new to the challenge. Welcome!</p>

<p><a href="/challenge-046/user-person/perl/ch-1.pl">User Person&rsquo;s solution</a> accepts a multi-line string as input, and then iterates over each character (including <code>\n</code>s) as follows:</p>

<pre><code class="language-perl">my $message       = $_[0];
$message          =~ s{ }{}g;
my $decodedString = '_' x index($message,&quot;\n&quot;);
my @seen          = ();
my $col           =  0;
CHAR_LOOP:
foreach ( split //, $message ) {
    if ( $_ eq &quot;\n&quot;) {
        $col = 0;
        next CHAR_LOOP;
    }
    substr($decodedString,$col,1,$_) if ++$seen[$col]{$_} == 2;
    ++$col;
}
</code></pre>

<p>They use 4-argument <code>substr</code> here, to directly replace the character in <code>$decodedString</code> with the most frequent character in the column.</p>

<h3 id="python">Python</h3>

<p>User Person also submitted a solution in <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-046/user-person/python/ch-1.py">Python</a>.</p>

<h2 id="wanderdoc1">Wanderdoc</h2>

<p>Wanderdoc provided <a href="/challenge-046/wanderdoc/perl/ch-1.pl">two solutions</a>, one that works with arrays, and one that works with strings. Both accept a multi-line string as input; the names refer to the internal logic. Conveniently, these are named <code>arrays</code> and <code>strings</code>. Here is <code>arrays</code>:</p>

<pre><code class="language-perl">sub arrays {
     my @strings =  map [split(/\s/, $_)], split(/\n/, $message);
     my $max_idx = $#{$strings[0]};
     my @cols = map { my $idx = $_;
          my @slice = map $_-&gt;[$idx] // '', @strings; [@slice];
          } 0 .. $max_idx;
     my @doubles = map { my %seen; grep $seen{$_}++ &gt; 0, @$_;} @cols;
     # print join('',@doubles), $/; # PerlRaku
}
</code></pre>

<p>Here, Wanderdoc splits the message into an AoA, a matrix of characters.  Wanderdoc then iterates through the column indicies to build up the columns as an AoA in <code>@cols</code>. After that, <code>@doubles</code> is essentially the final result, created from any character seen more than once in a given column.</p>

<p>Now here is <code>strings</code>, the string-based solution:</p>

<pre><code class="language-perl">sub strings {
    my @strings = map { tr/ //ds; $_; } split( /\n/, $message );
    my $len     = length( $strings[0] );
    # BrowserUK: http://www.perlmonks.org/?node_id=1202721:
    my $buf   = chr(0) x $len;
    my @cRefs = map \substr( $buf, $_, 1 ), 0 .. $len - 1;
    my $txt;
    for my $idx ( 0 .. $len - 1 ) {
        my ($letter) = do {
            my %seen;
            grep $seen{$_}++ &gt; 0,
              map { substr( $buf, 0 ) = $_; ${ $cRefs[$idx] }; } @strings;
        };
        $txt .= $letter;
    }
}
</code></pre>

<p>Here, Wanderdoc uses a buffer, with each index referenced by <code>@cRefs</code>. Then, Wanderdoc loops over each column index, and then uses the LHS <code>substr</code> to overwrite <code>$buf</code> with the current row. The current letter is <code>${ $cRefs[$idx] }</code>. Then, the <code>grep $seen{$_}++ &gt; 0</code> will return characters seen more than once.</p>

<p>With the included benchmark, <code>strings</code> runs approximately 50% faster. This is because the <code>@cRefs</code> setup does the expensive indexing operation once, and then those refs can be re-used without paying that penalty again.</p>

<p>It&rsquo;s certainly an interesting way to exploit the language. Whether the 2-3 minutes I spent staring at this code is worth the 66 μs CPU time savings really depends on how many of these messages one expects to decode, I suppose. :-)</p>

<hr />

<hr />

<h1 id="task2">Task #2 - Is The Room Open? (500 Doors)</h1>

<p>Here is Mohammad&rsquo;s description:</p>

<p>There are 500 rooms in a hotel with 500 employees having keys to all the rooms. The first employee opened main entrance door of all the rooms. The second employee then closed the doors of room numbers 2,4,6,8,10 and so on to 500. The third employee then closed the door if it was opened or opened the door if it was closed of rooms 3,6,9,12,15 and so on to 500. Similarly the fourth employee did the same as the third but only room numbers 4,8,12,16 and so on to 500. This goes on until all employees has had a turn.</p>

<p>Write a script to find out all the rooms still open at the end.</p>

<hr />

<h2 id="types-of-solutions">Types of Solutions</h2>

<h3 id="1-nested-loops">1. Nested Loops</h3>

<p>Most people solved this with some form of a nested loop. The outer loop for each employee (<code>i</code>), and the inner loop corresponds to each <code>1/i</code> door that employee will toggle. This results in an efficiency of O(n × (<sup>1</sup>&frasl;<sub>1</sub> + <sup>1</sup>&frasl;<sub>2</sub> + ⋯ + 1/n)) ≈ O(n × log n). For a problem size of n = 500, that&rsquo;s absolutely fine.  However, with a little bit of math, it&rsquo;s possible to simplify things even more:</p>

<h3 id="2-square-numbers">2. Square Numbers</h3>

<p>Many people noticed that the doors left open are the square numbers (1², 2²=4, 3²=9, etc.). Some decided to implement this pattern as an algorithm, resulting in trivial code with O(sqrt(n)) complexity.</p>

<p>The main difficulty behind using this method is demonstrating its correctness, yet several people managed to do just that, with explanations or informal proofs of why <em>only</em> perfect square numbered doors would be open.</p>

<p>Correctness proofs are an important topic in computer science, so I&rsquo;m glad to see some effort being put into it here!</p>

<hr />

<p>Of course, neither of these solutions is necessarily &ldquo;better&rdquo; in the context of this challenge. The square numbers solution (2) is the result of analysis and math, while the looping solution (1) is a better showcase of the language features and coding ability. Both skills are tremendously important, and I&rsquo;m quite sure everyone I&rsquo;m reviewing today is capable of either method; it&rsquo;s just a matter of what they decide to submit.</p>

<hr />

<h2 id="alicia-bielsa2">Alicia Bielsa</h2>

<p><a href="/challenge-046/alicia-bielsa/perl/ch-2.pl">Alicia Bielsa&rsquo;s solution</a> does a nested loop to flip the doors, with a <code>flipStatus</code> routine to actually toggle a door:</p>

<pre><code class="language-perl">my $TOTAL = 500;
my @aRooms =  (0) x $TOTAL;
foreach my $employee (1..$TOTAL){
    foreach my $door ($employee..$TOTAL){
        if ($door % $employee == 0 ){
            $aRooms[$door-1] = flipStatus ($aRooms[$door-1]);
        }
    }
}

sub flipStatus {
    my $status = shift;
    if ($status){
        return 0;
    }
    return 1;
}
</code></pre>

<p>Finally, a simple loop through <code>@aRooms</code> to print the &ldquo;open&rdquo; (value 1) rooms:</p>

<pre><code class="language-perl">foreach my $room (0..$#aRooms){
    if ($aRooms[$room]){
        $room ++;
        print &quot;Room $room opened\n&quot;;
    }
}
</code></pre>

<p>Note that Alicia&rsquo;s <code>@aRooms</code> is 500 elements long, meaning indicies 0..499.  The challenge, however, asks for rooms 1..500. Alicia simply increments <code>$room</code> so the correct number is printed.</p>

<h2 id="andrezgz2">Andrezgz</h2>

<p><a href="/challenge-046/andrezgz/perl/ch-2.pl">Andrezgz&rsquo;s solution</a> loops, but instead of working with 1-based math, Andrezgz simply adds a dummy room #0 so the numbers line up:</p>

<pre><code class="language-perl">my @rooms = (-1) x MAX; # all rooms are closed
unshift @rooms, 0;      # add room &quot;0&quot; for simplicity
foreach my $e (1 .. MAX) {
    foreach my $r ($e .. MAX) {
        $rooms[$r] *= -1 if ($r % $e == 0);
    }
}
print join ',', grep { $rooms[$_] == 1 } (1 .. MAX);;
</code></pre>

<p>Also of note is that instead of toggling between 1 and 0, Andrezgz multiplies by -1 so closed rooms are -1, and open rooms are 1.</p>

<h2 id="athanasius2">Athanasius</h2>

<p><a href="/challenge-046/athanasius/perl/ch-2.pl">Athanasius&rsquo; solution</a> uses constants for <code>$CLOSED</code> and <code>$OPEN</code>, as well as the room count:</p>

<pre><code class="language-perl">use Const::Fast;
const my $CLOSED =&gt;   0;
const my $OPEN   =&gt;   1;
const my $ROOMS  =&gt; 500;
</code></pre>

<p>The looping here is optimal, thanks to the C-style inner loop skipping in
<code>$employee</code> intervals:</p>

<pre><code class="language-perl">my @rooms = (-1, ($CLOSED) x $ROOMS);
for my $employee (1 .. $ROOMS) {
    for (my $door = $employee; $door &lt;= $ROOMS; $door += $employee) {
        $rooms[$door] = ($rooms[$door] == $CLOSED ? $OPEN : $CLOSED);
    }
}
</code></pre>

<p>Printing out the results is a simple loop:</p>

<pre><code class="language-perl">my @open = grep { $rooms[$_] == $OPEN } 1 .. $#rooms;
printf &quot;There are %d rooms still open at the end (the square-numbered &quot; .
       &quot;rooms):\n%s\n&quot;, scalar @open,
        join ', ', map { sprintf '%3d', $_ } @open;
</code></pre>

<h2 id="cheok-yin-fung2">Cheok-Yin Fung</h2>

<p><a href="/challenge-046/cheok-yin-fung/perl/ch-2.pl">Cheok-Yin Fung&rsquo;s solution</a> also loops optimally, using a Perlish <code>for</code> loop and multiplying by the employee interval, <code>$i</code>:</p>

<pre><code class="language-perl">my @doors;
my $labor;
$doors[0] = 'true'; # main entrance
for my $i (1..500) {
    $doors[$i] = undef;
}
for my $i (1..250) {
    $labor = int(500/$i);
    for my $j (1..$labor) {
        $doors[$i*$j] = not($doors[$i*$j]);
    }
}
for my $i (251..500) {
    $doors[$i] = not($doors[$i]);
}
</code></pre>

<p>Cheok-Yin Fung uses <code>not</code> to invert the truth value of each door.</p>

<h2 id="colin-crain2">Colin Crain</h2>

<p><a href="/challenge-046/colin-crain/perl/ch-2.pl">Colin Crain&rsquo;s solution</a> uses a nested loop:</p>

<pre><code class="language-perl">my $SIZE = 500;
my @hotel = (0) x $SIZE;
for my $emp (1..$SIZE) {
    my @doors = map { $_ % $emp == 0 ? 1 : 0 } ( 1..$SIZE );
    for my $idx ( 0..$SIZE-1 ) {
        $hotel[$idx] = $hotel[$idx] ^ $doors[$idx];
    }
}
</code></pre>

<p>Colin makes a <code>@doors</code> array for every employee, which is essentially a vector of truth values, which he applies like a mask over <code>@hotel</code> to toggle the doors for the current employee.</p>

<p>This is the first use of the bitwise exclusive-or (<code>^</code>) operator we&rsquo;ve seen, but it won&rsquo;t be the last. XORing a value with 1 is a common way to toggle a boolean value, especially in assembler and lower-level languages like C. However, it works just as well in Perl.</p>

<h2 id="cristian-heredia2">Cristina Heredia</h2>

<p><a href="/challenge-046/cristian-heredia/perl/ch-2.pl">Cristina Heredia&rsquo;s solution</a> uses a nested loop as well:</p>

<pre><code class="language-perl">#0 is closed
#1 is opened
foreach (my $i = 0; $i &lt; $size; $i++) {
    @rooms[$i] = 0;
}
foreach (my $j = 0; $j &lt; $size; $j++) {
    foreach (my $k = $j; $k &lt; $size; $k = $j + $k +1) {
        #If closed
        if (@rooms[$k] == 0) {
            @rooms[$k] = 1;
        }
        else {
            @rooms[$k] = 0;
        }
    }
}
</code></pre>

<p>Cristina makes the optimization in the inner <code>foreach</code> loop to only look at every <code>$j</code>th door, so this is an efficient solution. The only thing I would change is using the <code>$</code> sigil to access individual elements, so <code>@rooms[$k]</code> would become <code>$rooms[$k]</code>.</p>

<h2 id="dave-jacoby2">Dave Jacoby</h2>

<p><a href="/challenge-046/dave-jacoby/perl/ch-2.pl">Dave Jacoby&rsquo;s solution</a> uses a nested loop, as well as the 501-length array, so Dave can enjoy 1-based indicies:</p>

<pre><code class="language-perl">my @doors = map { 1 } 0 .. 500;
for my $e ( 2 .. 500 ) {
    map { $doors[$_] = !$doors[$_] }
      grep { 0 == $_ % $e } 1 .. 500;
}
say join ' ', grep { $doors[$_] } 1 .. 500;
</code></pre>

<p>This is a nicely concise solution. Dave starts off by initializing all doors to be open and starting with employee #2, which saves one trip through the loop. After that, he uses <code>!</code> to toggle the individual doors.</p>

<h2 id="duane-powell2">Duane Powell</h2>

<p><a href="/challenge-046/duane-powell/perl/ch-2.pl">Duane Powell&rsquo;s solution</a> uses nested loops, too:</p>

<pre><code class="language-perl">my @room;
$room[$_] = CLOSED foreach(1 .. ROOM);
# Toggle doors up to nth $EMPLOYEE
foreach my $employee (1 .. $EMPLOYEE) {
    foreach my $room (1 .. ROOM) {
        if ( $room % $employee == 0) {
            $room[$room] = ($room[$room] == OPEN) ? CLOSED : OPEN;
        }
    }
}
</code></pre>

<p>However, what I find most interesting about Duane&rsquo;s solution is that while <code>ROOM</code> is always 500, the <code>$EMPLOYEE</code> variable is taken from the commandline, so it&rsquo;s possible to step through the solution, seeing the state of the doors after <code>$EMPLOYEE</code> employees have done their thing.</p>

<pre><code class="language-perl">my $EMPLOYEE = shift || 500; # pass in $EMPLOYEE if you want to step thru the solution
use constant {
    ROOM     =&gt; 500,
    OPEN     =&gt; 0,
    CLOSED   =&gt; 1,
};
</code></pre>

<h2 id="duncan-c-white2">Duncan C. White</h2>

<p><a href="/challenge-046/duncan-c-white/perl/ch-2.pl">Duncan C. White&rsquo;s solution</a></p>

<pre><code class="language-perl"># all rooms open initially [we don't use element 0]
my @roomopen = ( 0, (1) x $n );
say &quot;naive answer:&quot;;
foreach my $empl (2..$n) {
    for( my $room=$empl; $room&lt;=$n; $room+=$empl ) {
        $roomopen[$room] = 1-$roomopen[$room];
    }
}
my @open = grep { $roomopen[$_] } 0..$n;
say join(',', @open);
</code></pre>

<p>On seeing the results, Duncan then did some exploration to find out why only the perfect squares were output. He correctly realized that a door will be open if and only if the number of factors of the room number is odd, and wrote another solution to test that observation:</p>

<pre><code class="language-perl"># ok, so a room no R is open at the end if the number of factors of R,
# including 1 and R, is ODD:
say &quot;odd-factors answer:&quot;;
my @sq;
foreach my $r (1..$n) {
    my $odd = 1;
    foreach my $i (2..$r) {
        $odd = ! $odd if $r % $i == 0;
    }
    push @sq, $r if $odd;
}
say join(',', @sq);
</code></pre>

<p>In conclusion, he poses the following question:</p>

<pre><code class="language-perl">say &quot;but why are the squares the only numbers with an odd number of factors?&quot;;
</code></pre>

<p>This tells me Duncan has basically cracked the problem. The short answer to that question is that factors always come in pairs, and perfect squares have an odd number of factors because one factor (the square root) is multiplied by itself, but it&rsquo;s only counted once.</p>

<h3 id="postscript">PostScript</h3>

<p>Duncan also submitted a solution in <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-046/duncan-c-white/postscript/ch-2.ps">PostScript</a>.</p>

<p><a href="http://www.ry.ca/wp-content/uploads/2020/02/duncan-c-white-046-2.pdf">Here is the output</a> with <code>ps2pdf</code>. Note that <code>-sPAPERSIZE=a4</code> was needed to avoid clipping.</p>

<h2 id="e-choroba2">E. Choroba</h2>

<p>E. Choroba submitted <a href="/challenge-046/e-choroba/perl/">three solutions</a>. The first is a basic nested loop approach:</p>

<pre><code class="language-perl">my $MAX = 500;
my @doors = (0) x $MAX;  # All closed.
for my $employee (0 .. $MAX - 1) {
    $doors[$_] = ! $doors[$_]
        for grep 0 == (1 + $_) % (1 + $employee), 0 .. $MAX - 1;
}
say join ' ', map 1 + $_, grep $doors[$_], 0 .. $MAX;
</code></pre>

<p>He then simplified that with the same observation Duncan just had about doors with odd numbers of divisors:</p>

<pre><code class="language-perl">say join ' ', grep {
    my $door = $_;
    1 == (grep 0 == $door % $_, 1 .. 500) % 2
} 1 .. 500;
</code></pre>

<p>And finally, Choroba observed the perfect square pattern in the output and coded that up:</p>

<pre><code class="language-perl">say join ' ', map $_ ** 2, 1 .. sqrt 500;
</code></pre>

<p>His blog also mentions a simple benchmark he did, showing the first solution took 6.5 seconds to run 200 times, the second took 5.4 seconds, and the third just 0.9 seconds.</p>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/02/perl-weekly-challenge-046-cryptic-message-is-the-room-open.html">Cryptic Message &amp; Is the Room Open?</a></p>

<h2 id="jaldhar-h-vyas2">Jaldhar H. Vyas</h2>

<p><a href="/challenge-046/jaldhar-h-vyas/perl/ch-2.pl">Jaldhar H. Vyas&rsquo; solution</a> uses a nested loop:</p>

<pre><code class="language-perl">my @rooms = (0) x 500;
my $end = scalar @rooms - 1;
for my $i (0 .. $end) {
    for my $j (0 .. $end) {
        if (($j + 1) % ($i + 1) == 0) {
            $rooms[$j] = ($rooms[$j]) ? 0 : 1;
        }
    }
}
</code></pre>

<p>The <code>(($j + 1) % ($i + 1) == 0)</code> conditional translates <code>$i</code> and <code>$j</code> to 1-based numbering, and then only toggles the room if the room (<code>$j</code>) is a multiple of the employee number (<code>$i</code>).</p>

<h2 id="javier-luque2">Javier Luque</h2>

<p><a href="/challenge-046/javier-luque/perl/ch-2.pl">Javier Luque&rsquo;s solution</a> is another nested loop:</p>

<pre><code class="language-perl">my @doors;
$doors[$_] = 0 for (0 .. 500);
for my $employee (1 .. 500) {
    for my $door ($employee .. 500 ) {
        next unless $door % $employee == 0;
        $doors[$door] = ($doors[$door]) ? 0 : 1;
    }
}
</code></pre>

<p>Javier tests the divisibility in the inner loop to determine if the <code>$employee</code> should open the current <code>$door</code>.</p>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/04/perl-weekly-challenge-046/">046 – Perl Weekly Challenge</a></p>

<h2 id="laurent-rosenfeld2">Laurent Rosenfeld</h2>

<p><a href="/challenge-046/laurent-rosenfeld/perl/ch-2.pl">Laurent Rosenfeld&rsquo;s solution</a> also uses nested loops, however Laurent uses a <code>while</code> inner loop and increments <code>$door</code> by <code>$start</code> (the employee number) for a more efficient solution:</p>

<pre><code class="language-perl">use constant MAX =&gt; 50;
# 1 =&gt; open, 0 =&gt; closed
my @rooms = (1) x (MAX + 1); # (first employee)
my $start = 1;
for (2..MAX) {
    $start++;
    my $door = $start;
    while ($door &lt;= MAX) {
        $rooms[$door] = $rooms[$door] ? 0 : 1;
        $door += $start;
    }
}
say join &quot; &quot;, @rooms[1..MAX];
</code></pre>

<p>Laurent&rsquo;s blog has some interesting analysis on the results, which is definitely worth a read:</p>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-46-garbled-message-and-room-open.html">Garbled Message and Room Open</a></p>

<h2 id="mohammad-anwar2">Mohammad S Anwar</h2>

<p><a href="/challenge-046/mohammad-anwar/perl/ch-2.pl">Mohammad S Anwar&rsquo;s solution</a> similarly uses an inner <code>while</code> loop so he can increase <code>$room_number</code> by the <code>$employee</code> number for a significant efficiency advantage:</p>

<pre><code class="language-perl">my @rooms = map { 1 } (0..500);
foreach my $employee (2 .. 500) {
    my $room_number = $employee;
    while ($room_number &lt;= 500) {
        $rooms[ $room_number ] = ($rooms [ $room_number ]) ? 0 : 1;
        $room_number += $employee;
    }
}
map { print &quot;$_\n&quot; if $rooms[$_] } (1..500);
</code></pre>

<h2 id="peter-scott">Peter Scott</h2>

<p><a href="/challenge-046/peter-scott/perl/ch-2.sh">Peter Scott&rsquo;s solution</a> is a one-liner:</p>

<pre><code class="language-sh">#!/bin/sh
perl -E '$N=shift; @R=(0)x$N; for $e (1..$N){ for ($r = $e; $r &lt; $N; $r += $e ) { $R[$r-1] ^= 1 } } say for grep { $R[$_-1] } 1..$N' 500
</code></pre>

<p><code>perltidy</code> sure does come in handy sometimes:</p>

<pre><code class="language-perl">$N = shift;
@R = (0) x $N;
for $e ( 1 .. $N ) {
    for ( $r = $e ; $r &lt; $N ; $r += $e ) {
        $R[ $r - 1 ] ^= 1
    }
}
say for grep { $R[ $_ - 1 ] } 1 .. $N
</code></pre>

<p>Peter uses a C-style <code>for</code> loop to check every <code>$e</code> doors, and also uses XOR (<code>^</code>) to toggle each door. He also maintains 0-based indexing throughout.</p>

<h2 id="rage3112">Rage311</h2>

<p><a href="/challenge-046/rage311/perl/ch-2.pl">Rage311&rsquo;s solution</a> uses nested loops:</p>

<pre><code class="language-perl">my @rooms = (0) x 501;
for my $emp ( 1 .. 500 ) {
    for ( my $room = $emp ; $room &lt;= 500 ; $room += $emp ) {
        $rooms[$room] ^= 1;
    }
}
say 'Open: ', join ',', grep { $rooms[$_] } 1..$#rooms;
</code></pre>

<p>The by now familiar inner C-style <code>for</code> loop and XOR toggle are shown here.</p>

<h2 id="roger-bell-west2">Roger Bell West</h2>

<p><a href="/challenge-046/roger-bell-west/perl/ch-2.pl">Roger Bell West&rsquo;s solution</a> is similarly loopy:</p>

<pre><code class="language-perl">my @rooms = (1) x 500;
foreach my $n ( 2 .. 500 ) {
    for ( my $k = $n - 1 ; $k &lt; 500 ; $k += $n ) {
        $rooms[$k] = 1 - $rooms[$k];
    }
}
print map { $_ + 1, &quot;\n&quot; } grep { $rooms[$_] == 1 } ( 0 .. $#rooms );
</code></pre>

<p>Toggling a boolean with <code>$rooms[$k] = 1 - $rooms[$k]</code> is an old trick I remember using with 808x assembly programming a long time ago. Somehow this challenge turned into a &ldquo;how many different ways can you toggle a boolean&rdquo; challenge!</p>

<h2 id="ruben-westerberg2">Ruben Westerberg</h2>

<p><a href="/challenge-046/ruben-westerberg/perl/ch-2.pl">Ruben Westerberg&rsquo;s solution</a> loops, with an inner <code>while</code> loop:</p>

<pre><code class="language-perl">my @doors=(0) x 500;
$doors[$_]= $doors[$_]?0:1 for 0..499;
for my $i (2..500) {
    my $j=$i;
    while ($j &lt;= 500) {
        $doors[$j-1]=$doors[$j-1]?0:1;
        $j+=$i;
    }
}
print @doors;
</code></pre>

<p><code>print @doors</code> outputs a string of 500 1s and 0s, providing a more visual depiction of which doors are open and closed.</p>

<h2 id="ryan-thompson2">Ryan Thompson</h2>

<p><a href="/challenge-046/ryan-thompson/perl/ch-2.pl">My solution</a> comes in two parts. First, simply printing the square numbers:</p>

<pre><code class="language-perl">say join ' ', map { $_ * $_ } 1..int sqrt $doors;
</code></pre>

<p>Since the correctness of this method is perhaps not obvious, I also provide an informal correctness proof at the end of <a href="http://www.ry.ca/2020/02/500-doors/">my blog post</a>.</p>

<p>I also did a looping solution:</p>

<pre><code class="language-perl">my %door;
for my $m (1..$doors) {
    $door{$m*$_} ^= 1 for 1..$doors/$m;
}
</code></pre>

<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/02/500-doors/">PWC 046 › Is the Room Open? (500 Doors)</a></p>

<h2 id="saiftynet2">Saif Ahmed</h2>

<p><a href="/challenge-046/saiftynet/perl/ch-2.pl">Saif Ahmed&rsquo;s solution</a> is also a two-parter. First, a looping solution:</p>

<pre><code class="language-perl">my $doorCount=500;
my @doors=(0)x($doorCount+1);          # $doorCount+1 doors
foreach my $doorman (1..$#doors) {     # each of the employees
    my $n=1;                           # multiples starting with one
    while ($doorman*$n&lt;=($doorCount)){ # and continuing until no more doors
                                       # toggles the door state (using 'not')
      $doors[$doorman*$n++]=not $doors[$doorman*$n];
    }
}
</code></pre>

<p>And then, Saif notices the square number pattern, providing the following brief justification and solution:</p>

<pre><code class="language-perl"># The results are interesting. The door will only stay open if it has an
# odd number of factors. Factors of a number generally occur as pairs
# that multiply together to produce that number...so the only way to get a
# odd number of factors is when it possible for both the factors to be
# the same...i.e the number has to be a square number.
# the same results can therefore be obtained by:
my $cheat=1;
print &quot; &quot;.($cheat++)**2 while $cheat&lt;sqrt($doorCount);
</code></pre>

<h2 id="ulrich-rieke2">Ulrich Rieke</h2>

<p><a href="/challenge-046/ulrich-rieke/perl/ch-2.pl">Ulrich Rieke&rsquo;s solution</a> uses anonymous arrays to store the door number with its <code>open</code> or <code>closed</code> status:</p>

<pre><code class="language-perl">my @doors;
for my $i ( 1 .. 500 ) {
    push( @doors, [ $i, &quot;open&quot; ] );
}
for my $i ( 2 .. 500 ) {
    if ( $i &lt; 251 ) {
        for ( my $j = $i ; $j &lt; 500 ; $j += $i ) {
            ${ $doors[ $j - 1 ] }[1] = flip( ${ $doors[ $j - 1 ] }[1] );
        }
    }
    else {
        ${ $doors[ $i - 1 ] }[1] = flip( ${ $doors[ $i - 1 ] }[1] );
    }
}
</code></pre>

<p>The conditional <code>if ( $i &lt; 251 )</code> is unnecessary here. I believe Ulrich has recognized that employees 251..500 will only have to toggle a single door, so he made a special case for that, as an optimization. However, since he already has a C-style for loop that increments by <code>$i</code> every time, the special case can be removed. However, the inner loop&rsquo;s conditional must then read <code>$j &lt;= 500</code>, so that door 500 is correctly toggled.</p>

<p>Ulrich also factored the door toggle to its own routine, <code>flip()</code>:</p>

<pre><code class="language-perl">sub flip {
    my $state = shift;
    if ( $state eq &quot;open&quot; ) {
        return &quot;closed&quot;;
    }
    else {
        return &quot;open&quot;;
    }
}
</code></pre>

<h3 id="c-and-haskell-1">C++ and Haskell</h3>

<p>Ulrich also submitted solutions in <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-046/ulrich-rieke/cpp/ch-2.cpp">C++</a> and <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-046/ulrich-rieke/haskell/ch-2.hs">Haskell</a>.</p>

<h2 id="user-person2">User Person</h2>

<p><a href="/challenge-046/user-person/perl/ch-2.pl">User Person&rsquo;s solution</a> also has its own toggle routine:</p>

<pre><code class="language-perl">sub change {
    return $_[0] eq &quot;OPENED&quot; ? &quot;CLOSED&quot; : &quot;OPENED&quot;;
}
</code></pre>

<p>(Note again the use of string identifiers, removing any ambiguity about whether 0 or 1 means open.) The main nested loop is as follows:</p>

<pre><code class="language-perl">push @doors, &quot;CLOSED&quot; foreach (0..$MAX);
ROOM:
for ( my $i = 1; $i &lt;= $MAX; ++$i ) {
    if ($i &gt; $MAX / 2 ) {
       $doors[$i] =  change $doors[$i];
       next ROOM;
   }
   for ( my $j = 1; $j &lt;= $MAX; ++$j ) {
       if ($j % $i == 0) {
           $doors[$j] =  change $doors[$j];
       }
   }
}
</code></pre>

<p>User Person also has a conditional to save some looping for employees 251..500, but it does provide some savings in this case, because their inner loop (<code>$j</code>) increments by 1, instead of by the employee number.</p>

<h3 id="bash-and-python">Bash and Python</h3>

<p>User Person also submitted solutions in <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-046/user-person/bash/ch-2.bash">Bash</a> and <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-046/user-person/python/ch-2.py">Python</a>.</p>

<h2 id="wanderdoc2">Wanderdoc</h2>

<p><a href="/challenge-046/wanderdoc/perl/ch-2.pl">Wanderdoc&rsquo;s solution</a> does a deep dive into the performance of the nested loop method versus a more analytical method using factors. But before we get into that, I want to highlight Wanderdoc&rsquo;s refreshingly creative way to avoid 0-based indicies:</p>

<pre><code class="language-perl">unshift @hotel, 'Lobby'; # to make the array indices equal to room numbers.
</code></pre>

<p>Here is the looping method:</p>

<pre><code class="language-perl">use constant {NUM =&gt; 500, OPEN =&gt; 1, SWITCH =&gt; -1};
my @hotel = (OPEN) x NUM;
unshift @hotel, 'Lobby';    # to make the array indices equal to room numbers.
for my $emp ( 2 .. NUM ) {
    @hotel[ grep $_ % $emp == 0, $emp .. NUM ] =
      map $_ * SWITCH, @hotel[ grep $_ % $emp == 0, $emp .. NUM ];
}
my @open = grep $hotel[$_] == OPEN, 1 .. NUM;
</code></pre>

<p>This is a fairly standard nested loop method, although you&rsquo;ll note the &ldquo;inner loop&rdquo; in this case is actually an array slice.</p>

<p>Wanderdoc&rsquo;s next method works by counting the unique factors for each door, and opens it if and only if the number of factors is even. (Noting, however, that they start checking for factors at 2, so 1 is not counted as a factor, here):</p>

<pre><code class="language-perl">my @OPEN = (1);
for ( 2 .. NUM ) { push @OPEN, $_ if ( is_open($_) ); }

sub is_open {
    my $n       = $_[0];
    my $counter = 0;
    for my $k ( 2 .. $n ) {
        0 == $n % $k and $counter++;
    }
    return $n if $counter % 2 == 0;
}
print join(&quot; &quot;, @OPEN), $/;
</code></pre>

<hr />

<hr />

<h2 id="blogs">See Also</h2>

<h3 id="blogs-this-week">Blogs this week:</h3>

<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-46-garbled-message-and-room-open.html">Garbled Message and Room Open</a></p>

<p><strong>Arne Sommer</strong> › <a href="https://raku-musings.com/cryptic-room.html">The Cryptic Raku Room</a></p>

<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/04/perl-weekly-challenge-046/">046 – Perl Weekly Challenge</a></p>

<p><strong>E. Choroba</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/02/perl-weekly-challenge-046-cryptic-message-is-the-room-open.html">Cryptic Message &amp; Is the Room Open?</a></p>

<p><strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/02/cryptic-message/">Cryptic Message</a> | <a href="http://www.ry.ca/2020/02/500-doors/">Is the Room Open? (500 Doors)</a></p>

<p><strong>Luca Ferrari</strong> › <a href="https://fluca1978.github.io/2020/02/03/PerlWeeklyChallened_46.html">Encoded messages and open rooms</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

