<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Perl Weekly Review: Challenge - #047">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.55.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Perl Weekly Review: Challenge - #047</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Perl Weekly Review: Challenge - #047</h2>
                    <div class="portfolio-meta">
                        <span>Friday, Feb 21, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p5-review-challenge-047.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    

<p>Continues from <a href="/blog/review-challenge-046/">previous week</a>.</p>

<p>Welcome to the Perl review for Week 047 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-047/">original tasks</a> and <a href="/blog/recap-challenge-047/">recap</a> of the weekly challenge.</p>

<h2 id="getting-in-touch">Getting in Touch</h2>

<p><a href="mailto:rjt@cpan.org"><img src="http://ry.ca/misc/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>

<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="http://ry.ca/misc/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>

<p><a href="https://twitter.com/perlwchallenge"><img src="http://ry.ca/misc/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>

<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<h3 id="task-1-task1"><a href="#task1">Task 1</a></h3>

<p>[ <a href="#alicia-bielsa1">Alicia Bielsa</a>  | <a href="#andrezgz1">Andrezgz</a>  | <a href="#athanasius1">Athanasius</a>  | <a href="#cheok-yin-fung1">Cheok-Yin Fung</a>  | <a href="#dave-cross1">Dave Cross</a>  | <a href="#dave-jacoby1">Dave Jacoby</a>  | <a href="#duane-powell1">Duane Powell</a>  | <a href="#duncan-c-white1">Duncan C. White</a>  | <a href="#e-choroba1">E. Choroba</a>  | <a href="#jaldhar-h-vyas1">Jaldhar H. Vyas</a>  | <a href="#javier-luque1">Javier Luque</a>  | <a href="#laurent-rosenfeld1">Laurent Rosenfeld</a>  | <a href="#lubos-kolouch1">Lubos Kolouch</a>  | <a href="#phillip-harris1">Phillip Harris</a>  | <a href="#ruben-westerberg1">Ruben Westerberg</a>  | <a href="#ryan-thompson1">Ryan Thompson</a>  | <a href="#saiftynet1">Saif Ahmed</a>  | <a href="#user-person1">User Person</a>  | <a href="#wanderdoc1">Wanderdoc</a>  ]</p>

<h3 id="task-2-task2"><a href="#task2">Task 2</a></h3>

<p>[ <a href="#alicia-bielsa2">Alicia Bielsa</a>  | <a href="#andrezgz2">Andrezgz</a>  | <a href="#athanasius2">Athanasius</a>  | <a href="#cheok-yin-fung2">Cheok-Yin Fung</a>  | <a href="#colin-crain2">Colin Crain</a>  | <a href="#cristian-heredia2">Cristina Heredia</a>  | <a href="#dave-cross2">Dave Cross</a>  | <a href="#dave-jacoby2">Dave Jacoby</a>  | <a href="#duane-powell2">Duane Powell</a>  | <a href="#duncan-c-white2">Duncan C. White</a>  | <a href="#e-choroba2">E. Choroba</a>  | <a href="#jaldhar-h-vyas2">Jaldhar H. Vyas</a>  | <a href="#javier-luque2">Javier Luque</a>  | <a href="#laurent-rosenfeld2">Laurent Rosenfeld</a>  | <a href="#lubos-kolouch2">Lubos Kolouch</a>  | <a href="#mohammad-anwar2">Mohammad S Anwar</a>  | <a href="#phillip-harris2">Phillip Harris</a>  | <a href="#ruben-westerberg2">Ruben Westerberg</a>  | <a href="#ryan-thompson2">Ryan Thompson</a>  | <a href="#saiftynet2">Saif Ahmed</a>  | <a href="#steven-wilson2">Steven Wilson</a>  | <a href="#ulrich-rieke2">Ulrich Rieke</a>  | <a href="#user-person2">User Person</a>  | <a href="#wanderdoc2">Wanderdoc</a>  ]</p>

<h3 id="blogs-blogs"><a href="#blogs">Blogs</a></h3>

<hr />

<hr />

<h1 id="task1">Task #1 - Roman Calculator</h1>

<p>The first task is to write a script that accepts two Roman numbers and an arithmetic operator. It should then calculate the result and return it as another Roman number. For example:</p>

<pre><code>perl ch-1.pl V + VI
XI
</code></pre>

<p>This challenge tends to require a fair amount of code. The average solution length was 90 lines (for comparison, Task #2 averaged 29 lines), with several nearing 200 lines. The average would have been higher if not for several hackers&rsquo; use of CPAN modules and code from <a href="/blog/review-challenge-010/">Week 010</a>.</p>

<p>As such, I will have to be more selective in the code that I highlight. Please remember you can always click the solution link for the full code. If I didn&rsquo;t highlight a part of your code you believe is worth looking at more closely in the context of this review, please <a href="mailto:rjt@cpan.org">let me know</a>!</p>

<hr />

<h2 id="alicia-bielsa1">Alicia Bielsa</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/alicia-bielsa/perl/ch-1.pl">Alicia Bielsa&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Readonly"><code>Readonly::Hash</code></a>es to map the Roman numerals to their Arabic values (e.g., <code>X =&gt; 10</code>), and takes the <code>reverse</code> to map in the other direction. She writes <code>romanToDecimal</code> and <code>decimalToRoman</code> subroutines so the solution can be calculated. Here is the <code>romanToDecimal</code> sub:</p>

<pre><code class="language-perl">sub romanToDecimal {
    my $romanNumber = shift;
    my $previousValue = 0;
    my $decimalNumber = 0;
    foreach my $romanSymbol (split('',$romanNumber)) {
        if ($HASH_ROMAN_DECIMAL{$romanSymbol} &gt; $previousValue ){
            #Previous value was substractive mode, we substract twice.
            $decimalNumber -= $previousValue * 2;
        }
        $decimalNumber += $HASH_ROMAN_DECIMAL{$romanSymbol};
        $previousValue = $HASH_ROMAN_DECIMAL{$romanSymbol};
    }
    return $decimalNumber;
}
</code></pre>

<p>Alicia also included error checking for the arguments, with and <code>isOperationAccepted</code> and <code>isRomanNumber</code>. Here is the latter:</p>

<pre><code class="language-perl">sub isRomanNumber {
    my $numberToCheck = shift;
    my $isRoman = 0;
    my $romanDigits = join ( '', keys %HASH_ROMAN_DECIMAL);
    if ($numberToCheck =~ /^[$romanDigits]+$/ ){
        $isRoman = 1;
    }
    return $isRoman;
}
</code></pre>

<p>Overall, Alicia&rsquo;s solution feels complete and robust.</p>

<h2 id="andrezgz1">Andrezgz</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/andrezgz/perl/ch-1.pl">Andrezgz&rsquo;s solution</a> wisely re-uses code from previous challenges (dispatch tables from week 39, and Roman numeral encoding from week 10).</p>

<p>Andrezgz&rsquo;s check for a valid Roman number is a regex, and checks for reasonable counts of each numeral:</p>

<pre><code class="language-perl">sub _is_valid_roman {
    return $_[0] =~ /
        ^                       # String start
        M{0,3}                  # Matching from 1000 to 3000
        (?:CM|CD|D|D?C{0,3})?   # Matching from 100 to 900
        (?:XC|XL|L|L?X{0,3})?   # Matching from 10 to 90
        (?:IX|IV|V|V?I{0,3})?   # Matching from 1 to 9
        $                       # String end
    /xi;
}
</code></pre>

<p>I know this code is the same as Andrezgz&rsquo;s week 10 solution, but it did not get highlighted in that review.</p>

<p>Thanks to the re-used code, the new code that Andrezgz wrote this week ended up being quite short:</p>

<pre><code class="language-perl">my $operations = {
    '+' =&gt; sub { $_[0] + $_[1] },
    '-' =&gt; sub { $_[0] - $_[1] },
    'x' =&gt; sub { $_[0] * $_[1] },
    '/' =&gt; sub { $_[0] / $_[1] },
};
my $rn1 = shift;
my $op = shift;
my $rn2 = shift;
my $result = $operations-&gt;{$op}-&gt;( decode_roman(uc $rn1) , decode_roman(uc $rn2) );
print encode_roman($result);
</code></pre>

<p>The solution itself has comprehensive error checking, which I omitted for brevity.</p>

<h2 id="athanasius1">Athanasius</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/athanasius/perl/ch-1.pl">Athanasius&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Math::Roman"><code>Math::Roman</code></a> to convert to and from Roman numbers. The top-level logic looks like this, using string <code>eval</code> for the calculation itself:</p>

<pre><code class="language-perl">my @OPERATIONS   =&gt; qw( + - * / % );      # '/' denotes *integer* division
my @ROMAN_DIGITS =&gt; qw( I V X L C D M );

my $args = scalar @ARGV;
$args == 3 or die &quot;ERROR: Expected 3 command-line args but found $args\n&quot;;
my $lhs  = validate_roman(uc $ARGV[0]);
my $op   = $ARGV[1];
any { $op eq $_ } @OPERATIONS or die &quot;ERROR: Unknown operator '$op'\n&quot;;
my $rhs  = validate_roman(uc $ARGV[2]);
my $rslt = roman(int eval &quot;$lhs $op $rhs&quot;);
printf &quot;%s %s %s = %s\n&quot;, uc $ARGV[0], $op, uc $ARGV[2], $rslt;
</code></pre>

<p>The <code>validate_roman</code> sub checks whether a string is a valid Roman number, and,
if so, takes it through <code>Math::Roman</code>:</p>

<pre><code class="language-perl">sub validate_roman {
    my ($roman) = @_;
    for my $digit (split //, $roman) {
        any { $digit eq $_ } @ROMAN_DIGITS
            or die &quot;ERROR: Unknown Roman digit '$digit'\n&quot;;
    }
    my $math_roman = roman($roman);
       $math_roman-&gt;is_nan() and die 'ERROR: ', Math::Roman::error(), &quot;\n&quot;;
    return $math_roman-&gt;as_number();
}
</code></pre>

<h2 id="cheok-yin-fung1">Cheok-Yin Fung</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/cheok-yin-fung/perl/ch-1.pl">Cheok-Yin Fung&rsquo;s solution</a> uses string <code>eval</code> as well:</p>

<pre><code class="language-perl">my $formula;
chomp($_ = &lt;STDIN&gt;);
if (/([A-Z]+)(\s*)([\+,\-,\*])(\s*)([A-Z]+)/) {
    $formula = roman_to_dec($1).$3.roman_to_dec($5);
}
my $result = eval $formula;
print dec_to_roman($result), &quot;\n&quot;;
</code></pre>

<p>The regex to extract the arguments would be the perfect place to add error checking, so that arbitrary code is not passed to the <code>eval</code>.</p>

<p>Cheok-Yin Fung&rsquo;s <code>roman_to_dec</code> is interesting (<code>%sk</code> maps Roman numerals to Arabic values):</p>

<pre><code class="language-perl">sub roman_to_dec {
    my $total = 0;
    my @char = split //, $_[0];
    for my $i (0..$#char-1) {
        $total += $sk{$char[$i]};
        if ($sk{$char[$i]} &lt; $sk{$char[$i+1]}) {
            $total = $total - 2*$sk{$char[$i]};
        }
    }
    $total += $sk{$char[$#char]};
    $total;
}
</code></pre>

<p>There is a <code>dec_to_roman</code> as well that I won&rsquo;t show here, as it is long. It subtracts the value of the next digit (or pair) it can, in a loop, until it reaches zero.</p>

<h2 id="dave-cross1">Dave Cross</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/dave-cross/perl/ch-1.pl">Dave Cross&rsquo;s solution</a> also taps into CPAN, using <a href="https://metacpan.org/pod/Roman"><code>Roman</code></a> for a concise solution with dispatch tables:</p>

<pre><code class="language-perl">use Roman;
my %ops = (
    '+' =&gt; sub { $_[0] + $_[1] },
    '-' =&gt; sub { $_[0] - $_[1] },
    '/' =&gt; sub { $_[0] / $_[1] },
    'x' =&gt; sub { $_[0] * $_[1] },
);
my ($l, $op, $r) = @ARGV;
unless (exists $ops{$op}) {
    warn &quot;'$op' is  not a recognised operation\n&quot;;
    die 'Valid operations are: ', join(', ', keys %ops), &quot;\n&quot;;
}
say Roman( $ops{$op}-&gt;(arabic($l), arabic($r)) );
</code></pre>

<h2 id="dave-jacoby1">Dave Jacoby</h2>

<p>It seems both Daves opted to <a href="https://metacpan.org/pod/Roman"><code>use Roman</code></a> this week! <a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/dave-jacoby/perl/ch-1.pl">Dave Jacoby&rsquo;s solution</a> defines a map of valid operators, and then starts converting:</p>

<pre><code class="language-perl">use Roman;
my %operators = map { $_ =&gt; 1 } qw{ + - / * };
if ( scalar @ARGV &gt; 2 ) {
    my ( $r1, $op, $r2 ) = @ARGV;
    if ( !$operators{$op} ) {
        say 'not an operator';
        exit;
    }
    if ( !isroman($r1) ) { say qq{&quot;$r1&quot; is not a roman numeral}; exit; }
    if ( !isroman($r2) ) { say qq{&quot;$r2&quot; is not a roman numeral}; exit; }
    my $a1 = arabic($r1);
    my $a2 = arabic($r2);
    my $a3 = 0;
    if ( $op eq '+' ) { $a3 =  $a1 + $a2 }
    if ( $op eq '-' ) { $a3 =  $a1 - $a2 }
    if ( $op eq '*' ) { $a3 =  $a1 * $a2 }
    if ( $op eq '/' ) { $a3 =  $a1 / $a2 }
    my $r3 = uc roman($a3);
    say qq{ $r1 $op $r2 = $r3 };
}
else { say 'We need an operator and two roman numbers' }
</code></pre>

<p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/02/12/counting-from-100-is-the-fun-part.html">Counting from 100 is the Fun Part</a></p>

<h2 id="duane-powell1">Duane Powell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/duane-powell/perl/ch-1.pl">Duane Powell&rsquo;s solution</a> defines <code>arabic</code> and <code>roman</code> functions to convert between Arabic and Roman numbers. <code>roman</code> is essentially an <code>if</code> chain in a <code>while</code> loop to greedily build the Roman number from the largest to smallest digits, shown here, in part:</p>

<pre><code class="language-perl">sub roman {
    my $arabic = shift;
    $arabic = int($arabic);
    my $roman = '';
    while ($arabic &gt; 0) {
        if ($arabic &gt;= 1000) {
            $roman .= $roman{1000};
            $arabic -= 1000;
            next;
        }
        if ($arabic &gt;= 900) {
            $roman .= $roman{900};
            $arabic -= 900;
            next;
        }
        ...
        if ($arabic &gt;= 1) {
            $roman .= $roman{1};
            $arabic -= 1;
            next;
        }
    }
    return $roman;
}
</code></pre>

<p>The <code>arabic</code> function <code>split</code>s the input Roman number, and then looks for patterns of numerals like <code>IX</code> that need to be considered together, before considering numerals individually:</p>

<pre><code class="language-perl">sub arabic {
    my @roman = split(//, uc(shift));
    my ($arabic, $next, $error, $min) = (0, '', '', 1000);
    while (scalar @roman and not $error) {
        # Check for matching pair of Roman numerals, eg 'IV'
        if (scalar @roman &gt; 1) {
            $next = $roman[0].$roman[1];
            if ( defined($arabic{$next}) ) {
                $arabic += $arabic{$next};
                $error = &quot;Roman numeral out of sequence at $next&quot; if ($arabic{$next} &gt; $min);
                $min = $arabic{$next};
                shift @roman;
                shift @roman;
                next;
             }
        }
        # Pair not found, maybe there is one matching numeral, eg 'I'
        if (scalar @roman &gt; 0) {
            $next = $roman[0];
            if ( defined($arabic{$next}) ) {
                $arabic += $arabic{$next};
                $error = &quot;Roman numeral out of sequence at $next&quot; if ($arabic{$next} &gt; $min);
                $min = $arabic{$next};
                shift @roman;
                next;
             }
            else {
                $error = &quot;Invalid Roman numeral at $next&quot;;
            }
        }
    }
    if ($error) {
        say $error;
        exit;
    }
    return $arabic;
}
</code></pre>

<p>The main logic is then simple:</p>

<pre><code class="language-perl">my $n = arabic($r1);
my $m = arabic($r2);
my $a = eval &quot;$n $op $m&quot;;
my $r = roman($a);
say $r, &quot; (&quot;, $a, &quot;)&quot;;
</code></pre>

<h2 id="duncan-c-white1">Duncan C. White</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/duncan-c-white/perl/ch-1.pl">Duncan C. White&rsquo;s solution</a> uses <code>Roman</code> as well:</p>

<pre><code class="language-perl">use Roman;
die &quot;Usage: romancalc R1 OP R2    [R1 and R2 are Roman numerals or integers]\n&quot;.
    &quot;or:    romancalc test\n&quot;
    unless @ARGV==3 || (@ARGV==1 &amp;&amp; $ARGV[0] eq &quot;test&quot;);
my( $r1, $op, $r2 ) = @ARGV;
my $origr1 = $r1;
my $origr2 = $r2;
$r1 = fromroman($r1) if $r1 =~ /^[MCDLXVI]+$/;
$r2 = fromroman($r2) if $r2 =~ /^[MCDLXVI]+$/;
die &quot;romancalc: bad r1: $r1\n&quot; unless $r1 &gt; 1 &amp;&amp; $r1 &lt; 4000;
die &quot;romancalc: bad r2: $r2\n&quot; unless $r2 &gt; 1 &amp;&amp; $r2 &lt; 4000;
my $n = eval &quot;$r1 $op $r2&quot; || die &quot;romancalc: bad operator $op\n&quot;;
$n = int($n);
my $r = toroman($n);
say &quot;result of $origr1 ($r1) $op $origr2 ($r2): $r ($n)&quot;;
</code></pre>

<h2 id="e-choroba1">E. Choroba</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/e-choroba/perl/ch-1.pl">E. Choroba&rsquo;s solution</a> reuses his Roman/Arabic code from Week 10, adding a dispatch table to handle the arithmetic:</p>

<pre><code class="language-perl">use lib '.';
use MyRoman qw{ to_roman from_roman }; # Extracted from PWC010/1.
my ($n1, $op, $n2) = @ARGV;
my $function = { '+' =&gt; sub { $_[0] + $_[1] },
                 '-' =&gt; sub { $_[0] - $_[1] },
                 '*' =&gt; sub { $_[0] * $_[1] },
                 '/' =&gt; sub { int($_[0] / $_[1]) }
               }-&gt;{$op}
    or die &quot;Unknown operator $op.&quot;;
say to_roman($function-&gt;(map from_roman($_), $n1, $n2));
</code></pre>

<h2 id="jaldhar-h-vyas1">Jaldhar H. Vyas</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/jaldhar-h-vyas/perl/ch-1.pl">Jaldhar H. Vyas&rsquo;s solution</a> goes through a multi-step procedure whereby each Arabic number is converted naïvely to the simplest expression of Roman numerals. E.g, 4 would be <code>IIII</code>, and is then <code>normalize</code>d to <code>IV</code>. A similar process happens in the reverse order.</p>

<p>There is also a <code>reorder</code> function that puts the numerals in their proper order, just before the <code>normalize</code> step:</p>

<pre><code class="language-perl">sub reorder {
    my ($num) = @_;
    my %order = (
        'M' =&gt; 0, 'D' =&gt; 1, 'C' =&gt; 2, 'L' =&gt; 3, 'X' =&gt; 4, 'V' =&gt; 5, 'I' =&gt; 6
    );
    return join q{}, sort { $order{$a} &lt;=&gt; $order{$b} } split //, $num;
}

sub normalize {
    my ($num) = @_;
    my @from = qw/ IIIII IIII VV VIV XXXXX XXXX LL LXL CCCCC CCCC DD DCD /;
    my @to =   qw/ V     IV   X  IX  L     XL   C  XC  D     CD   M  CM  /;
    for my $i (0 .. scalar @from - 1) {
        $num =~ s/$from[$i]/$to[$i]/g;
    }
    return $num;
}
</code></pre>

<p>The main logic supports addition and subtraction. Pay close attention to how these operations are implemented:</p>

<pre><code class="language-perl">my ($num1, $op, $num2) = @ARGV;
if ($op eq '+') {
    say normalize(reorder(unprefix($num1) . unprefix($num2)));
} elsif ($op eq '-') {
    my $un1 = unprefix($num1);
    my $un2 = unprefix($num2);
    while (length $un2) {
        ($un1, $un2) = expandLargest(removeCommon($un1, $un2));
    }
    say normalize($un1);
} else {
    usage();
}
</code></pre>

<p>And now we see the reason Jaldhar needed those &ldquo;extra&rdquo; subroutines: he never converts the numbers to Arabic at all! For example, the addition operator simply expands and concatenates the Roman numbers, and then normalizes them again so the answer is in proper Roman format. I like this approach a lot.</p>

<h2 id="javier-luque1">Javier Luque</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/javier-luque/perl/ch-1.pl">Javier Luque&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Number::Convert::Roman"><code>Number::Convert::Roman</code></a> to do the conversion, so the code is relatively short:</p>

<pre><code class="language-perl">use Number::Convert::Roman;
my $input_string = join ' ', @ARGV;
my $c = Number::Convert::Roman-&gt;new;
my %operations = (
    '+' =&gt; sub {return ($c-&gt;arabic($_[0]) + $c-&gt;arabic($_[1]))},
    '-' =&gt; sub {return ($c-&gt;arabic($_[0]) - $c-&gt;arabic($_[1]))},
    'x' =&gt; sub {return ($c-&gt;arabic($_[0]) * $c-&gt;arabic($_[1]))},
    '/' =&gt; sub {return ($c-&gt;arabic($_[0]) / $c-&gt;arabic($_[1]))},
);
if ($input_string =~ /^(\w+)\s*([\+\-x\/])\s*(\w+)$/) {
    say $c-&gt;roman(int($operations{$2}-&gt;($1, $3)));
} else {
    say &quot;Invalid input&quot;;
}
</code></pre>

<p>Javier uses a dispatch table in <code>%operations</code> for simple yet extensible code, and the <code>$input_string</code> regexp serves to help parse and validate the input.</p>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/10/perl-weekly-challenge-047/">047 – Perl Weekly Challenge</a></p>

<h2 id="laurent-rosenfeld1">Laurent Rosenfeld</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/laurent-rosenfeld/perl/ch-1.pl">Laurent Rosenfeld&rsquo;s solution</a> also re-uses his <code>from_roman</code> and <code>to_roman</code> subroutines from Week 10. However, I would like to highlight his <code>from_roman</code> subroutine in particular, as it uses a less common algorithm:</p>

<pre><code class="language-perl">my %rom_tab = (I =&gt; 1,  V =&gt; 5, X =&gt; 10, L =&gt; 50, C =&gt; 100, D =&gt; 500, M =&gt; 1000);
sub from_roman {
    my $roman = uc shift;
    my $numeric = 0;
    my $prev_letter = &quot;M&quot;;
    for my $letter (split //, $roman) {
        $numeric -= 2 * $rom_tab{$prev_letter}
            if $rom_tab{$letter} &gt; $rom_tab{$prev_letter};
        $numeric += $rom_tab{$letter};
        $prev_letter = $letter;
    }
    return $numeric;
}
</code></pre>

<p>Since Roman numbers are additive (i.e., you simply add the values of each numeral) <em>unless</em> the following numeral is greater than the current one (e.g., <code>IV</code>: <code>I</code> (1) is less than <code>V</code> (5)), in which case that relationship is a subtractive one.</p>

<p>What Laurent does here, when building up the answer in <code>$numeric</code>, is to <em>always</em> add the numbers, <em>and</em> if <code>$letter</code> is greater than the <code>$prev_letter</code>, subtract it twice, to make up for the addition.</p>

<p>Laurent&rsquo;s main logic is similarly concise:</p>

<pre><code class="language-perl">my @input;
for (@ARGV) {
    push @input, $_ if /[-+*\/]/;
    push @input, from_roman $_ if /[ivxlcdm]+/i;
}
die &quot;Need at least three parameters&quot; if @input &lt; 3; # we need at least 1 operator and two operands
my $result = eval join ' ', @input;
say &quot;@ARGV = &quot;, to_roman $result;
</code></pre>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-47-roman-calculator-and-gapful-numbers.html">Roman Calculator and Gapful Numbers</a></p>

<h2 id="lubos-kolouch1">Lubos Kolouch</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/lubos-kolouch/perl/ch-1.pl">Lubos Kolouch&rsquo;s solution</a> also uses <code>Roman</code>. Lubos has a <code>roman_magic</code> sub that does the, well, <em>magic</em> step of taking two Roman numbers and an operator, and returning the result in Roman form:</p>

<pre><code class="language-perl">use Roman;
sub roman_magic {
    my ($v1, $op, $v2) = @_;
    my $rom_v1 = arabic($v1);
    my $rom_v2 = arabic($v2);
    return uc(roman(eval &quot;$rom_v1 $op $rom_v2&quot;))
}
</code></pre>

<p>His main code is then, simply:</p>

<pre><code class="language-perl">my ($v1, $op, $v2) = @ARGV;
print roman_magic($v1, $op, $v2).&quot;\n&quot;;
</code></pre>

<h2 id="phillip-harris1">Phillip Harris</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/phillip-harris/perl/ch-1.pl">Phillip Harris&rsquo;s solution</a> uses an <code>if ... elsif</code> chain to perform the desired arithmetic operation:</p>

<pre><code class="language-perl">my $input = join( &quot; &quot;, @ARGV );
if ( $input !~ /.*?([IVXLCDM]+)(.*?)([IVXLCDM]+)/ ) { die &quot;Invalid input&quot; }
my $number1  = $1;
my $operator = $2;
my $number2  = $3;
$operator =~ s/[^\+\-\*\/]//g;
if ( $operator eq '+' ) {
    print dec2rom( rom2dec($number1) + rom2dec($number2) );
}
elsif ( $operator eq '-' ) {
    print dec2rom( rom2dec($number1) - rom2dec($number2) );
}
elsif ( $operator eq '*' ) {
    print dec2rom( rom2dec($number1) * rom2dec($number2) );
}
elsif ( $operator eq '/' ) {
    print dec2rom( int( rom2dec($number1) / rom2dec($number2) + .5 ) );
}
else { die &quot;Invalid operator&quot; }
print &quot;\n&quot;;
</code></pre>

<p>Phillip&rsquo;s <code>dec2rom</code> and <code>rom2dec</code> subs do the heavy lifting. I&rsquo;d like to show the <code>dec2rom</code> sub:</p>

<pre><code class="language-perl">sub dec2rom {
    my @rdb = qw(I IV V IX X  XL L  XC C   CD  D   CM  M);
    my @ddb = qw(1 4  5 9  10 40 50 90 100 400 500 900 1000);
    my $dec = $_[0];
    my $rom;
    for ( my $x = $#ddb ; $x &gt;= 0 ; $x-- ) {
        if ( $dec / $ddb[$x] &gt;= 1 ) {
            $rom .= $rdb[$x] x int( $dec / $ddb[$x] );
            $dec = $dec - ( $ddb[$x] * int( $dec / $ddb[$x] ) );
        }
    }
    return $rom;
}
</code></pre>

<p>Phillip&rsquo;s algorithm here is an efficient and concise variant of the subtraction method we&rsquo;ve seen before. Phillip realizes that once you have used a numeral (or subtractive group like <code>IV</code>), it can&rsquo;t appear again, so he checks for each of them in turn (from largest to smallest), subtracting from the input number while the output string is built up.</p>

<h2 id="ruben-westerberg1">Ruben Westerberg</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ruben-westerberg/perl/ch-1.pl">Ruben Westerberg&rsquo;s solution</a> contains <code>romanToDecimal</code> and <code>decimalToRoman</code> subs. <code>romanToDecimal</code> is interesting:</p>

<pre><code class="language-perl">sub romanToDecimal {
    my %r=(M=&gt;1000, D=&gt;500, C=&gt;100, L=&gt;50, X=&gt;10, V=&gt;5, I=&gt;1);
    my @c=split '', shift;
    my $diff=0;
    my $sum=0;
    for (my $i=0; $i&lt;@c; $i++) {
        if (($i+1) &lt; @c) {
            if ($r{$c[$i+1]} &gt; $r{$c[$i]}) {
                $diff=$r{$c[$i]};
            }
            else {
                $sum+= $r{$c[$i]} -$diff;
                $diff=0;
            }
        }
        else {
            $sum+=$r{$c[$i]} -$diff;
        }
    }
    return $sum;
}
</code></pre>

<p>The input Roman number is <code>split</code> into a <code>@c</code> character array. Similar to Laruent&rsquo;s solution, above, Ruben looks at the current character and the next character. If the next character is greater, the current character is subtracted from it on the <em>next</em> iteration. Otherwise, <code>$diff</code> will be zero.</p>

<p>The main logic uses <code>given ... when</code> to perform the correct operation:</p>

<pre><code class="language-perl">use v5.26;
no warnings qw&lt;experimental&gt;;
my ($operand1,$operator, $operand2)=@ARGV;
($operand1,$operand2)=map {
    given ($_) {
        romanToDecimal($_) when /[MDCLXVI]/;
        $_ when /\d+/;
        &quot;Not a digit or roman numeral&quot;;
    }
} ($operand1,$operand2);
my $result = do {
    given ($operator) {
        $operand1+$operand2 when /\+/;
        $operand1-$operand2 when /\-/;
        $operand1*$operand2 when /\*/;
        int ($operand1/$operand2) when /\//;
        &quot;Unkown&quot;;
    }
};
print decimalToRoman($result);
</code></pre>

<h2 id="ryan-thompson1">Ryan Thompson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ryan-thompson/perl/ch-1.pl">My solution</a> is partly re-used from some code I wrote years ago. After defining a <code>%rom</code> hash which maps every single and double character to its value (e.g., <code>I =&gt; 1, IV =&gt; 4, ...</code>), conversion is easy. (<code>@mor</code> is all the pairs in <code>%rom</code>, sorted in descending order of their value:</p>

<pre><code class="language-perl">my @mor = map { [ $rom{$_} =&gt; $_ ] } sort { $rom{$b} &lt;=&gt; $rom{$a} } keys %rom;

sub arabic_to_roman {
    my $n = shift;
    my $r = '';
    while ($n) {
        my ($val, $rom) = @{( first { $_-&gt;[0] &lt;= $n } @mor )};
        $n -= $val;
        $r .= $rom;
    }
    $r;
}
</code></pre>

<p>As you can see, the <code>$r</code> result is built by greedily subtracting the highest value possible, until the number, <code>$n</code> reaches zero. Since <code>@mor</code> contains pairs like <code>IV</code> and <code>XL</code>, it just works.</p>

<p>Going the other way is even easier:</p>

<pre><code class="language-perl">sub roman_to_arabic {
    sum map { $rom{$_} } pop =~ /(I[VX]|X[LC]|C[DM]|[IVXLCDM])/g
}
</code></pre>

<p>The regex pulls out any single numerals <em>and</em> also pulls out pairs, so it will sum the correct fragments of the string.</p>

<p>My main logic uses string <code>eval</code> with some sanitization of the input, so it can handle arbitrary arithmetic expressions, not just a single operator:</p>

<pre><code class="language-perl">say roman_expr(join ' ', @ARGV) and exit if @ARGV;

# Perform arbitrary expressions using Roman numerals
sub roman_expr {
    my $expr = shift;
    $expr =~ s/\b([IVXLCDM]+)\b/roman_to_arabic($1)/eg;
    die &quot;Invalid expression&quot; if $expr =~ m![^ 0-9+*%/()-]!;
    arabic_to_roman( eval $expr );
}
</code></pre>

<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/02/roman-calculator/">Roman Calculator</a></p>

<h2 id="saiftynet1">Saif Ahmed</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/saiftynet/perl/ch-1.pl">Saif Ahmed&rsquo;s solution</a>, as I&rsquo;ve come to expect, is comprehensive, and interesting. Saif went to some effort to support larger Roman numbers, which are typically depicted with an overline, which means &ldquo;multiply this digit by 1000&rdquo;. So, when I put <code>MCM * X</code> into Saif&rsquo;s prompt, it shows (roughly):</p>

<pre><code>         _ _
Answer = XMX
</code></pre>

<p>Saif uses the ANSI &ldquo;overline&rdquo; sequence <code>\e[0;53m</code>, so I can&rsquo;t show it exactly, here. You can turn this off in his script, and it&rsquo;s automatically disabled on Windows.</p>

<p>Saif uses string <code>eval</code> to calculate the result after converting the Roman numbers to Arabic with the <code>arabic</code> sub:</p>

<pre><code class="language-perl">our @converter=(
   [900 ,&quot;CM&quot;],   [1000,&quot;M&quot; ], [400 ,&quot;CD&quot;],   [500 ,&quot;D&quot; ],
   [90  ,&quot;XC&quot;],   [100 ,&quot;C&quot; ], [40  ,&quot;XL&quot;],   [50  ,&quot;L&quot; ],
   [9   ,&quot;IX&quot;],   [10  ,&quot;X&quot; ], [4   ,&quot;IV&quot;],   [5   ,&quot;V&quot; ],
   [1   ,&quot;I&quot; ],
);

sub arabic {
    my $roman = shift;
    return 0 if !$roman;
    my $arabic = 0;
    foreach my $conv (@converter) {
        my $re = $$conv[1];
        $arabic += $$conv[0] while $roman =~ s/$re//i;
    }
    return $arabic;
}
</code></pre>

<p>This is a nicely compact implementation, taking the next highest pair <code>@converter</code> that matches the input string.</p>

<h2 id="user-person1">User Person</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/user-person/perl/ch-1.pl">User Person&rsquo;s solution</a> uses <code>Roman</code> to convert to and from Roman numbers. Here&rsquo;s the main logic:</p>

<pre><code class="language-perl">print STDERR &quot;[Arabic number detected in input]\n&quot; if $argString =~ m{\d+};
$argString =~ s{(\s*[-+*/%]\s*)}{ $1 }g;
$argString =~ s{([MDCLXVI]+)}{arabic $1}ge;
my $result = eval $argString;
my $oldResult = $result;
$result = int $result;
my $decimal = $oldResult - $result;
print STDERR &quot;Calculation result had a decimal $decimal that was truncated.\n&quot; if $decimal;
if ( $result == 0) {
    print &quot;N (no formal zero)\n&quot;; # https://en.wikipedia.org/wiki/Roman_numerals#Zero
} elsif ($result &gt; 3_999) {
    die &quot;Calculation result $result exceeds MMMCMXCIX (3,999) the maximum value of the Roman number format.\n&quot;;
} elsif ($result &lt; 0) {
    die &quot;Calculation result $result is negative. Roman numbers are positive integers.\n&quot;;
} else {
    $result = Roman(int $result);
    print &quot;$result\n&quot;;
}
</code></pre>

<p>The logic is quite comprehensive, even going so far as to disallow Arabic numbers in the input, even though <code>eval</code> would handle them. I respect User Person&rsquo;s strict adherence to the business logic!</p>

<h2 id="wanderdoc1">Wanderdoc</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/wanderdoc/perl/ch-1.pl">Wanderdoc&rsquo;s solution</a> contains the comment that the code was <code>Way too cumbersome, I think.</code>. At 133 lines (~108 SLOC), it is lengthy, but I disagree with &ldquo;cumbersome,&rdquo; as it is written in a modular style with several short (5-10 line) subroutines that all serve a purpose.</p>

<pre><code class="language-perl"># Some basic data.
my %romans = (I =&gt; 1, V =&gt; 5, X =&gt; 10,
              L =&gt; 50, C =&gt; 100, D =&gt; 500,
              M =&gt; 1000);
my %arabic = reverse %romans;
my %expand = ('I~V' =&gt; 'I', 'V~X' =&gt; 'I', 'X~L' =&gt; 'X', 'L~C' =&gt; 'X', 'C~D' =&gt; 'C', 'D~M' =&gt; 'C',
              'M~M'=&gt; 'M');
my %before;
for my $key ( sort { $romans{$expand{$a}} &lt;=&gt; $romans{$expand{$b}} } keys %expand ) {
     my ($left, $right) = split(/~/, $key);
     $before{ $right } = $expand{$key} if not exists $before{ $right };
     $before{ $left }  = $expand{$key} if not exists $before{ $left };
}
</code></pre>

<p>The data structures in Wanderdoc&rsquo;s solution were interesting. As you can see, the <code>%expand</code> hash contains the pairings of subtractive numerals, and maps them to the numerals that would follow them (e.g., <code>VX</code> would always come before <code>I</code>), which is helpful to Wanderdoc&rsquo;s subs.</p>

<p>Below is the main logic (I&rsquo;ve removed some input validation, for brevity). I respect Wanderdoc&rsquo;s willingness to credit others for techniques used. After all, re-use and sharing of code and ideas is what makes the whole field of computer science better overall.</p>

<pre><code class="language-perl"># Roman numerals regex - e.g. here: https://stackoverflow.com/questions/267399
my $rom_re = qr/^M{0,3}(?:C[MD]|D?C{0,3})(?:X[CL]|L?X{0,3})(?:I[XV]|V?I{0,3})$/;
my $re_opr = qr#^(?:[+-/]|\*{1,2})$#;
my ($op_1, $opr, $op_2) = @ARGV;
# Dispatch table for calculations, learned from choroba.
my %calc = (
     '+' =&gt; sub { return $_[0] + $_[1]; },
     '-' =&gt; sub { return $_[0] - $_[1]; },
     '*' =&gt; sub { return $_[0] * $_[1]; },
     '/' =&gt; sub { # Well, there is no 0 in Roman numerals :-)
                  return &quot;ERROR: Division by zero!&quot; if 0 == $_[1];
                  return int($_[0] / $_[1]); },
     '**' =&gt; sub { return $_[0] ** $_[1]; },
);
# Transformation, calculation and back-transformation.
($op_1, $op_2) = map rom2int($_) , ($op_1, $op_2);
my $result = $calc{$opr}-&gt;($op_1, $op_2);
$result = int2rom($result);
print $result, $/;
</code></pre>

<hr />

<hr />

<h1 id="task2">Task #2 - Gapful Numbers</h1>

<p>The Gapful numbers are defined by <a href="https://oeis.org/A108343">OEIS sequence A108343</a></p>

<p>This task had us write a script to print the first 20 Gapful numbers. Gapful numbers are numbers, 100 or greater, that are divisible by the concatenation of their first and last digits. So, for example, 100 is a gapful number because 100 is divisible by 10. 102 is not, because 102 is not divisible by 12.</p>

<hr />

<p>The solutions to this were considerably shorter than Task 1&rsquo;s solutions, so I&rsquo;ll be able to showcase more of the exceptional talent we have participating in this challenge.</p>

<p>The solutions were all quite similar, as there are only a few reasonable ways to get the first and last digits of a number and check for divisibility. Still, there are a couple solutions you&rsquo;ll see that iterate in interesting ways.</p>

<h2 id="alicia-bielsa2">Alicia Bielsa</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/alicia-bielsa/perl/ch-2.pl">Alicia Bielsa&rsquo;s solution</a> uses <code>split</code> to get the <code>$firstDigit</code> and <code>$lastDigit</code>, and then the modulo operator to test for divisibility:</p>

<pre><code class="language-perl">my $totalGapfulNumbers = 20;
my $totalGapfulNumbersFound = 0;
my $currentNumber = 100;
while ($totalGapfulNumbersFound &lt; $totalGapfulNumbers ) {
    my ($firstDigit, $lastDigit ) = (split('',$currentNumber))[0, length($currentNumber)-1];
    my $firstLastNumber = $firstDigit.$lastDigit;
    if ($currentNumber % $firstLastNumber   == 0) {
        print &quot;Gapful number found: $currentNumber\n&quot;;
        $totalGapfulNumbersFound++;
    }
    $currentNumber++;
}
</code></pre>

<p>We will definitely be seeing this approach again!</p>

<h2 id="andrezgz2">Andrezgz</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/andrezgz/perl/ch-2.pl">Andrezgz&rsquo;s solution</a> uses <code>substr</code> to pull out the first and last characters:</p>

<pre><code class="language-perl">use strict;
use warnings;
my $n = 99;
my $gapfuls = 0;
while ($gapfuls &lt; 20) {
    print $n.$/ if ++$n % ( substr($n, 0, 1) . substr($n, -1) ) == 0 &amp;&amp; $gapfuls++;
}
</code></pre>

<p>Note the negative index to <code>substr</code> means &ldquo;from the right&rdquo;, so -1 is the last character in the string. Perl&rsquo;s array indexing works the same way.</p>

<h2 id="athanasius2">Athanasius</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/athanasius/perl/ch-2.pl">Athanasius&rsquo;s solution</a> uses <code>split</code> to get the first character, and <code>$num % 10</code> to get the last character, then checks divisibility with the modulo operator:</p>

<pre><code class="language-perl">while ( $count &lt; $TARGET ) {
    my $div = ( split //, $num )[0] * 10 + $num % 10;
    if ( $num++ % $div == 0 ) {
        push @gapfuls, $num - 1;
        ++$count;
    }
}
printf &quot;The first %d Gapful Numbers greater than or equal to %d are:\n%s\n&quot;,
    $TARGET, $MINIMUM, join ', ', @gapfuls;
</code></pre>

<h2 id="cheok-yin-fung2">Cheok-Yin Fung</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/cheok-yin-fung/perl/ch-2.pl">Cheok-Yin Fung&rsquo;s solution</a> gets the first and last digits with integer arithmetic, with the following justification for the maximum length of the 20th gapful number:</p>

<pre><code class="language-perl"># All integers with the pattern _ABAB_ is gapful(_AB_*101) and there are
# 10*9/2 + 9 = 54 (A runs from 0 to 9, B runs from 0 to 9, 0000 is not counted)
# such integers. In short, all 20 first &gt;= 100 gapful numbers are larger than
# 99 and smaller than 9999.

my $th;
my $c = 0;
for my $N (100..999) {
    $th = 10 * int($N / 100) + ($N % 10);
    if ($N % $th == 0) {$c++; print $c, &quot;. &quot;, $N , &quot;\n&quot;;}
    if ($c==20) {exit;}
}
for my $N (1000..9999) {
    $th = 10 * int($N / 1000) + ($N % 10);
    if ($N % $th == 0) {$c++; print $c, &quot;. &quot;, $N , &quot;\n&quot;;}
    if ($c==20) {exit;}
}
</code></pre>

<h2 id="colin-crain2">Colin Crain</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/colin-crain/perl/ch-2.pl">Colin Crain&rsquo;s solution</a> uses <code>substr</code> to get the first and last digits:</p>

<pre><code class="language-perl">my $testval = 99;
my @output;
while (scalar @output &lt; 20 &amp;&amp; $testval++ ) {
    my $gap = substr( $testval, 0, 1 ) . substr( $testval, -1, 1 );
    push @output, $testval if $testval % $gap == 0;
}
say for @output;
</code></pre>

<h2 id="cristian-heredia2">Cristina Heredia</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/cristian-heredia/perl/ch-2.pl">Cristina Heredia&rsquo;s solution</a>
uses <code>split</code> to get the digits of the number:</p>

<pre><code class="language-perl">my $max = 20;
my $counter = 0;
my @divided;
my @solution;
for (my $number = 100; $counter &lt; $max; $number++) {
    my $newNumber;
    @divided = split(/d?/, $number);
    $newNumber = @divided[0].@divided[@divided-1];
    if (($number % $newNumber) == 0) {
        push(@solution, $number);
        $counter++;
    }
}
print &quot;The first $max Gapful Numbers are:\n&quot;;
for (my $i = 0; $i &lt; @solution; $i++) {
    print &quot;@solution[$i]\n&quot;;
}
</code></pre>

<p>The <code>split /d?/, $number</code> works, but most likely does so in an unintended way: The regex matches zero or one literal <code>d</code> characters, so in this case (where no literal <code>d</code> characters are expected in the input), it will have the same effect as <code>split //</code>, which is to split on every character.</p>

<p>I would also use <code>$solution[$i]</code> to reference a single array element instead of <code>@solution[$i]</code>.</p>

<h2 id="dave-cross2">Dave Cross</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/dave-cross/perl/ch-2.pl">Dave Cross&rsquo;s solution</a> builds up an array of <code>@gapful</code> numbers, using a slice of <code>split</code> for the first and last characters:</p>

<pre><code class="language-perl">my @gapful;
$_ = 100;
while (@gapful &lt; 20) {
  push @gapful, $_ unless $_ % join '', (split //)[0, -1];
  ++$_;
}
say &quot;@gapful&quot;;
</code></pre>

<h2 id="dave-jacoby2">Dave Jacoby</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/dave-jacoby/perl/ch-2.pl">Dave Jacoby&rsquo;s solution</a> showcases a few different methods of attacking this problem. The first is Dave&rsquo;s &ldquo;readable&rdquo; solution:</p>

<pre><code class="language-perl">my @x;
my $n = 100;
while ( scalar @x &lt; 20 ) {
    my @n = split //, $n;
    my $i = join '', $n[0], $n[-1];
    push @x, $n if $n % $i == 0;
    $n++;
}
say join &quot;\n&quot;, @x;
say '-' x 30;
</code></pre>

<p>Dave also included a &ldquo;way cool&rdquo; functional version:</p>

<pre><code class="language-perl">say join &quot;\n&quot;, grep { state $c = 0; $c++ &lt; 20 }
    grep { my $i = join '', substr( $_, 0, 1 ), substr( $_, -1 ); $_ % $i == 0 }100 .. 1000;
</code></pre>

<p>Dave, I agree, it&rsquo;s way cool.</p>

<p>And finally, an iterator, which is a good fit for this problem:</p>

<pre><code class="language-perl">my $next = make_iterator(100);
while ( my $n = $next-&gt;() ) {
    state $c = 0;
    my $i =  my $i = join '', substr( $n, 0, 1 ), substr( $n, -1 );
    if ( 0==$n%$i){
        say $n;
        $c++;
    }
    last if $c &gt;19;
}

sub make_iterator ( $start ) {
    return sub {
        state $i = $start;
        return $i++;
    }
}
</code></pre>

<p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/02/12/counting-from-100-is-the-fun-part.html">Counting from 100 is the Fun Part</a></p>

<h2 id="duane-powell2">Duane Powell</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/duane-powell/perl/ch-2.pl">Duane Powell&rsquo;s solution</a> uses <code>split</code> to get the first and last digits of a three-digit number, and concatenates them into <code>$x</code>. He then uses <code>int</code>eger division to check for divisibility:</p>

<pre><code class="language-perl">my @gap;
my $n = 100;
while (scalar @gap &lt; 20) {
    my ($a,undef,$b) = split(//,$n);
    my $x = &quot;$a$b&quot;; # form new number by combining first and last digit of $n
    push @gap, $n if ($n/$x == int($n/$x));
    $n++;
}
say join(',',@gap);
</code></pre>

<h2 id="duncan-c-white2">Duncan C. White</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/duncan-c-white/perl/ch-2.pl">Duncan C. White&rsquo;s solution</a> uses a regex with captures to get the first and last digits, combines them arithmetically, and then returns the result of a modulo operation to test for divisibility:</p>

<pre><code class="language-perl">use Function::Parameters;
fun gapful( $i ) {
    $i =~ /^(\d).*(\d)$/;    # find first and largest digits
    my $div = 10*$1 + $2;
    return $i % $div == 0 ? 1 : 0;
}
die &quot;Usage: ch-2.pl [FirstN]\n&quot; if @ARGV&gt;1;
my $n = shift // 20;
my $found = 0;
for( my $i = 100; $found&lt;$n; $i++ ) {
    next unless gapful( $i );
    say $i;
    $found++;
}
</code></pre>

<h2 id="e-choroba2">E. Choroba</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/e-choroba/perl/ch-2.pl">E. Choroba&rsquo;s solution</a> creates an iterator that returns the next gapful number, lazily:</p>

<pre><code class="language-perl">sub gapful_iterator {
    my ($n) = @_;
    my $iterator = sub {
        $n++ until 0 == $n % join &quot;&quot;, $n =~ /^(.)/, $n=~ /(.)$/;
        $n++
    };
}
my $iter = gapful_iterator(100);
say $iter-&gt;() for 1 .. 20;
</code></pre>

<h2 id="jaldhar-h-vyas2">Jaldhar H. Vyas</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/jaldhar-h-vyas/perl/ch-2.pl">Jaldhar H. Vyas&rsquo;s solution</a> uses <code>split</code> and modulo in a loop to build the list of <code>@gapfuls</code>:</p>

<pre><code class="language-perl">my @gapfuls;
my $number = 100;
while (scalar @gapfuls != 20) {
    my @digits = split //, $number;
    my $divisor = join q{}, ($digits[0], $digits[-1]);
    if ($number % $divisor == 0) {
        push @gapfuls, $number;
    }
    $number++;
}
say join ', ', @gapfuls;
</code></pre>

<h2 id="javier-luque2">Javier Luque</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/javier-luque/perl/ch-2.pl">Javier Luque&rsquo;s solution</a> uses a capturing regex, concatenates the first and last digits, and then uses mod arithmetic:</p>

<pre><code class="language-perl">my $n = 100;
my $p = 0;
while ($p &lt; 20) {
    $n =~ /^(\d)\d*(\d)$/;
    my $g_divisor = $1 . $2;
    if ($n % $g_divisor == 0){
        $p++;
        say $n . ' / ' . $g_divisor . ' = ' .
            ($n / $g_divisor);
    }
    $n++;
}
</code></pre>

<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/10/perl-weekly-challenge-047/">047 – Perl Weekly Challenge</a></p>

<h2 id="laurent-rosenfeld2">Laurent Rosenfeld</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/laurent-rosenfeld/perl/ch-2.pl">Laurent Rosenfeld&rsquo;s solution</a> builds up a list of <code>@gapful</code> numbers with the help of a capturing regex and our best friend in this task, the modulo operator:</p>

<pre><code class="language-perl">my @gapful = ();
my $current = 100;
do {
    my ($start, $end) = $current =~ /^(\d)\d+(\d)$/;
    push @gapful, $current unless $current % ($start . $end);
    $current ++;
} until $#gapful &gt;= 19;
say &quot;@gapful&quot;;
</code></pre>

<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-47-roman-calculator-and-gapful-numbers.html">Roman Calculator and Gapful Numbers</a></p>

<h2 id="lubos-kolouch2">Lubos Kolouch</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/lubos-kolouch/perl/ch-2.pl">Lubos Kolouch&rsquo;s solution</a> uses <code>substr</code> to get the first and third digits:</p>

<pre><code class="language-perl">my $count = 0;
for (100..10000) {
    if ($_ % int(substr($_,0,1).substr($_,2,1)) == 0) {
        say;
        $count++;
        last if $count == 20;
    }
}
</code></pre>

<p>Lubos&rsquo; loop goes to 10000, so <code>substr($_,2,1)</code> will not always return the last digit. Fortunately, the first 20 gapful numbers are all three digit numbers, so it works in this case.</p>

<h2 id="mohammad-anwar2">Mohammad S Anwar</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/mohammad-anwar/perl/ch-2.pl">Mohammad S Anwar&rsquo;s solution</a> also works on three digit numbers, using <code>split</code>, and then <code>sprintf</code> to combine the first and third digits:</p>

<pre><code class="language-perl">my $start = 99;
my $count = 0;
while ($count &lt;= 20) {
    $start++;
    my ($d1, $d2, $d3) = split //, $start;
    my $divisor = sprintf(&quot;%d%d&quot;, $d1, $d3);
    if ($start % $divisor != 0) {
        next;
    }
    else {
        $count++;
        print sprintf(&quot;%d / %d\n&quot;, $start, $divisor);
    }
}
</code></pre>

<h2 id="phillip-harris2">Phillip Harris</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/phillip-harris/perl/ch-2.pl">Phillip Harris&rsquo;s solution</a> uses
<code>substr</code> with <code>0</code> and <code>-1</code> for indicies to get the first and last digits:</p>

<pre><code class="language-perl">$x = 100;
while ( $gaps &lt; 20 ) {
    if ( $x % ( substr( $x, 0, 1 ) . substr( $x, -1 ) ) == 0 ) {
        print &quot;$x\n&quot;;
        $gaps++;
    }
    $x++;
}
</code></pre>

<h2 id="ruben-westerberg2">Ruben Westerberg</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ruben-westerberg/perl/ch-2.pl">Ruben Westerberg&rsquo;s solution</a> uses <code>split</code> and an array slice of the result to get the first and last digits:</p>

<pre><code class="language-perl">my @gapful;
while (@gapful &lt; 20) {
    state $i=99;
    push @gapful, $i unless ++$i % int join &quot;&quot;, do {my @a=split(&quot;&quot;,$i);@a[0,-1]};
}
print join &quot; &quot;,@gapful;
</code></pre>

<h2 id="ryan-thompson2">Ryan Thompson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ryan-thompson/perl/ch-2.pl">My solution</a> first defines an <code>is_gapful</code> sub that uses <code>split</code> and a slice:</p>

<pre><code class="language-perl">sub is_gapful(_) { $_ = pop; not $_ % join '', (split '')[0,-1] }
</code></pre>

<p>Then I gather the <code>@r</code>esult in the following <code>for</code> loop:</p>

<pre><code class="language-perl">sub first_n_gapful {
    my $N = shift;
    my @r;
    for ($_ = 100; @r &lt; $N; $_++) {
        push @r, $_ if is_gapful;
    }
    @r;
}
say for first_n_gapful(shift // 20);
</code></pre>

<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/02/gapful-numbers/">Gapful Numbers</a></p>

<h2 id="saiftynet2">Saif Ahmed</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/saiftynet/perl/ch-2.pl">Saif Ahmed&rsquo;s solution</a> concatenates two <code>substr</code> results:</p>

<pre><code class="language-perl">my $test=99;
my $found=0;
while ($found++&lt;20) {
    while( ++$test % (substr($test,0,1).substr($test,-1,1))) { }
    print $found,&quot; &quot;,$test,&quot;\n&quot;;
}
</code></pre>

<h2 id="steven-wilson2">Steven Wilson</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/steven-wilson/perl/ch-2.pl">Steven Wilson&rsquo;s solution</a> concatenates <code>substr</code> calls as well:</p>

<pre><code class="language-perl">my @gapful_numbers;
my $current_number = 100;
while ( scalar @gapful_numbers &lt; 20 ) {
    my $divisor = ( substr $current_number, 0, 1 )
        . ( substr $current_number, -1, 1 );
    if ( $current_number % $divisor == 0 ) {
        push @gapful_numbers, $current_number;
    }
    $current_number++;
}
say join ' ', @gapful_numbers;
</code></pre>

<h2 id="ulrich-rieke2">Ulrich Rieke</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/ulrich-rieke/perl/ch-2.pl">Ulrich Rieke&rsquo;s solution</a> defines an <code>isGapful</code> sub that uses a capturing regex:</p>

<pre><code class="language-perl">sub isGapful {
  my $number = shift ;
  $number =~ /(\d)\d+(\d)/ ;
  my $first = $1 ;
  my $last = $2 ;
  return ( ($number % ( $first . $last )) == 0 ) ;
}
</code></pre>

<p>The results are then gathered with the following <code>while</code> loop, then printed:</p>

<pre><code class="language-perl">my @numbers ;
my $start = 99 ;
while ( scalar @numbers != 20 ) {
  $start++ ;
  if ( isGapful( $start ) ) {
      push( @numbers, $start ) ;
  }
}
map { print &quot;$_ &quot; } @numbers ;
print &quot;\n&quot; ;
</code></pre>

<h2 id="user-person2">User Person</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/user-person/perl/ch-2.pl">User Person&rsquo;s solution</a> defines a <code>firstDigit</code> helper sub to return the first digit of a number (there is no <code>lastDigit</code> sub, as a simple <code>% 10</code> is used for that):</p>

<pre><code class="language-perl">sub firstDigit {
    my $number = $_[0];
    while ($number &gt;= 10) {
        $number /= 10;
    }
    return int($number);
}
</code></pre>

<p>The numbers are then printed in the body of the following <code>for</code> loop:</p>

<pre><code class="language-perl">my $QUANTITY = 20;
my ($first, $last);
my $count = 0;
for (my $i = 100; $count &lt; $QUANTITY ; ++$i) {
    $first = firstDigit $i;
    $last  = $i % 10;
    my $formedBy = ($first * 10) + $last;
    if ( $i % $formedBy == 0 ) {
        print &quot;$i &quot;;
        ++$count;
    }
}
print &quot;\n&quot;;
</code></pre>

<h2 id="wanderdoc2">Wanderdoc</h2>

<p><a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-047/wanderdoc/perl/ch-2.pl">Wanderdoc&rsquo;s solution</a> also has a <code>gapful</code> sub, using a <code>split</code> slice:</p>

<pre><code class="language-perl">sub gapful {
     my $num = $_[0];
     my $div = join('',(split(//,$num))[0, -1]);
     return 0 == $num % $div;
}
</code></pre>

<p>The results are then printed in this <code>while</code> loop:</p>

<pre><code class="language-perl">my $number = 100;
my $counter = 0;
while ( $counter &lt; 20 ) {
     gapful($number) and print join(' ', ++$counter,$number), $/;
     $number++;
}
</code></pre>

<hr />

<hr />

<h2 id="blogs">See Also</h2>

<h3 id="perl-blogs-this-week">Perl blogs this week:</h3>

<p><strong>Dave Jacoby</strong> › <a href="https://jacoby.github.io/2020/02/12/counting-from-100-is-the-fun-part.html">Counting from 100 is the Fun Part</a></p>

<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/10/perl-weekly-challenge-047/">047 – Perl Weekly Challenge</a></p>

<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-47-roman-calculator-and-gapful-numbers.html">Roman Calculator and Gapful Numbers</a></p>

<p><strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/02/roman-calculator/">Roman Calculator</a> | <a href="http://www.ry.ca/2020/02/gapful-numbers/">Gapful Numbers</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

